

# æ’åºç®—æ³•

### 88åŠ›æ‰£åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„

æ³¨è§£ï¼šè¯¾æœ¬å­¦åˆ°çš„æ˜¯æ„å»ºä¸€ä¸ªé¢å¤–çš„æ•°ç»„ï¼Œæœ¬é¢˜å›ºå®šäº†è¿™ä¸ªç©ºé—´åœ¨num1,**æ‰€ä»¥ä½¿ç”¨å€’å™**å°±å¯ä»¥äº†

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i=m-1;
        int j=n-1;
        int k=m+n-1;
        while(i>=0&&j>=0){
            if(nums1[i]>=nums2[j]){
                nums1[k]=nums1[i];
                k--;
                i--;
            }
            else{
                nums1[k]=nums2[j];
                k--;
                j--;
            }
        }
        while(i>=0){
            nums1[k]=nums1[i];
            k--;
            i--;
        }
        while(j>=0){
            nums1[k]=nums2[j];
            k--;
            j--;
        }

    }
};
```

### åŠ›æ‰£LCR075æ•°ç»„çš„ç›¸å¯¹æ’åº

![image-20240229234611341](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229234611341.png)

```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        for (int i = 0; i < arr2.size(); ++i) {
            rank[arr2[i]] = i;
        }
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            if (rank.count(x)) {
                return rank.count(y) ? rank[x] < rank[y] : true;
            }
            else {
                return rank.count(y) ? false : x < y;
            }
        });
        return arr1;
    }
};
//sortå‡½æ•°æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼Œå‰ä¸¤ä¸ªå‚æ•°æ˜¯æ’åºçš„èµ·ç‚¹å’Œç»ˆç‚¹è¿­ä»£å™¨ï¼Œæœ€åä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰å‡½æ•°ï¼Œç”¨æ¥å®šä¹‰æ’åºè§„åˆ™

/*[&]æ˜¯lambdaè¡¨è¾¾å¼çš„æ•è·åˆ—è¡¨ï¼ˆCapture Listï¼‰ã€‚åœ¨C++ä¸­ï¼Œlambdaè¡¨è¾¾å¼å¯ä»¥æ•è·å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ï¼Œä»¥ä¾¿åœ¨lambdaå‡½æ•°ä½“ä¸­ä½¿ç”¨ã€‚æ•è·åˆ—è¡¨æŒ‡å®šäº†å¦‚ä½•æ•è·è¿™äº›å˜é‡ã€‚

[&]æ˜¯ä¸€ç§æ•è·åˆ—è¡¨çš„å½¢å¼ï¼Œå…¶ä¸­çš„&è¡¨ç¤ºæ•è·å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„æ‰€æœ‰å˜é‡å¹¶æŒ‰å¼•ç”¨ï¼ˆreferenceï¼‰æ•è·ã€‚è¿™æ„å‘³ç€lambdaå‡½æ•°ä½“ä¸­ä½¿ç”¨çš„å¤–éƒ¨å˜é‡éƒ½æ˜¯é€šè¿‡å¼•ç”¨è®¿é—®çš„ï¼Œå¯¹è¿™äº›å˜é‡çš„ä¿®æ”¹ä¼šå½±å“åˆ°å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„åŸå§‹å˜é‡ã€‚

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œlambdaè¡¨è¾¾å¼ [&](int x, int y) æ•è·äº†æ‰€æœ‰å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ï¼Œå¹¶ä»¥å¼•ç”¨çš„æ–¹å¼è®¿é—®å®ƒä»¬ã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯åœ¨lambdaå‡½æ•°ä½“ä¸­å¯ä»¥ä½¿ç”¨ rank è¿™ä¸ªå¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ï¼Œè€Œä¸éœ€è¦é¢å¤–ä¼ é€’å‚æ•°ã€‚*/

=
```



![image-20240229234951333](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229234951333.png)



```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        for (int i = 0; i < arr2.size(); ++i) {
            rank[arr2[i]] = i;
        }
        auto mycmp = [&](int x) -> pair<int, int> {
            return rank.count(x) ? pair{0, rank[x]} : pair{1, x};
        };
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            return mycmp(x) < mycmp(y);
        });
        return arr1;
    }
};
```



![image-20240229235107812](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229235107812.png)

```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        int n = arr2.size();
        for (int i = 0; i < n; ++i) {
            rank[arr2[i]] = i - n;
        }
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            return (rank.count(x) ? rank[x] : x) < (rank.count(y) ? rank[y] : y);
        });
        return arr1;
    }
};

```



# ä½è¿ç®—

### åŠ›æ‰£ä½1çš„ä¸ªæ•°

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;

        // éå†äºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„æ¯ä¸€ä½
        while (n != 0) {
            // åˆ¤æ–­æœ€ä½ä½æ˜¯å¦ä¸º1
            if (n & 1) {
                count++;
            }
            // å³ç§»ä¸€ä½ï¼Œç»§ç»­åˆ¤æ–­ä¸‹ä¸€ä½
            n >>= 1;
        }

        return count;
    }
};

```



### å¼‚æˆ–è¿ç®—

å¼‚æˆ–è¿ç®—çš„æ€§è´¨å¦‚ä¸‹ï¼š

1. ä»»ä½•æ•°å’Œ0åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœä»ç„¶æ˜¯åŸæ¥çš„æ•°ï¼Œå³ a ^ 0 = aã€‚
2. ä»»ä½•æ•°å’Œå…¶æœ¬èº«åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœæ˜¯0ï¼Œå³ a ^ a = 0ã€‚
3. å¼‚æˆ–è¿ç®—æ»¡è¶³**äº¤æ¢å¾‹å’Œç»“åˆå¾‹**ï¼Œå³ a ^ b ^ a = b ^ a ^ a = b ^ (a ^ a) = b ^ 0 = bã€‚
4. å¼‚æˆ–è¿ç®—å¯ä»¥ç”¨æ¥äº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼ï¼Œä¾‹å¦‚ï¼ša = a ^ b; b = a ^ b; a = a ^ b;ã€‚

ç»™ä½ ä¸€ä¸ª éç©º æ•´æ•°æ•°ç»„ nums ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ä»¥å¤–ï¼Œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºé‚£ä¸ªåªå‡ºç°äº†ä¸€æ¬¡çš„å…ƒç´ ã€‚

ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°çº¿æ€§æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•æ¥è§£å†³æ­¤é—®é¢˜ï¼Œä¸”è¯¥ç®—æ³•åªä½¿ç”¨å¸¸é‡é¢å¤–ç©ºé—´ã€‚

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
       int ans=nums[0];
       if(nums.size()>1)
       {
           for(int i=1;i<nums.size();i++)
           {
               ans=ans^nums[i];
           }
       }

    return ans;
    }
};
```

### åŠ›æ‰£æ±‰æ˜è·ç¦»

int c = 100;

c>>=1//å³ç§»ä¸€ä½ï¼Œè¡¨ç¤ºé™¤äºŒ

c>>=2//å³ç§»ä¸¤ä½ï¼Œè¡¨ç¤ºé™¤4

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int c = x ^ y;
        int count = 0;
        while(c != 0){
            if(c & 1){
                count +=1;
            }
            c>>=1;
        }
        return count;      
    }
};
```

### åŠ›æ‰£é¢ å€’äºŒè¿›åˆ¶ä½

```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        int count = 32; // ç›´æ¥è®¾ç½®ä¸º32ï¼Œæ— éœ€å¾ªç¯è®¡ç®—
        long sum = 0;
        while (n != 0 && count > 0) {
            if (n & 1) {
                sum |= (1 << (count - 1)); // ä½¿ç”¨ä½è¿ç®—ä»£æ›¿æ±‚å¹‚æ“ä½œ
            }
            count -= 1;
            n >>= 1;
        }
        return sum;
    }
};

```

`sum |= (1 << (count - 1));` æ˜¯ä¸€ä¸ªä½è¿ç®—æ“ä½œï¼Œç”¨äºå°† `sum` çš„ç¬¬ `(count-1)` ä½è®¾ç½®ä¸º1ã€‚(ä»ç¬¬0ä½å¼€å§‹è®¡æ•°)

1. `(count - 1)` è®¡ç®—å‡ºè¦è®¾ç½®çš„ä½çš„ä½ç½®ã€‚åœ¨äºŒè¿›åˆ¶ä¸­ï¼Œæœ€ä½ä½çš„ä½ç½®æ˜¯0ï¼Œä¾æ¬¡é€’å¢ã€‚
2. `1 << (count - 1)` æ˜¯å°†æ•°å­—1å·¦ç§» `(count - 1)` ä½ã€‚è¿™å®é™…ä¸Šæ˜¯åœ¨äºŒè¿›åˆ¶ä¸­å°†1ç§»åŠ¨åˆ°æŒ‡å®šçš„ä½ç½®ï¼Œå…¶ä½™ä½å¡«å……ä¸º0ã€‚
3. `sum |= (1 << (count - 1));` åˆ©ç”¨ `|=` æŒ‰ä½æˆ–ç­‰äºæ“ä½œç¬¦ï¼Œå°† `sum` çš„ç¬¬ `(count-1)` ä½è®¾ç½®ä¸º1ã€‚å¦‚æœ `sum` çš„è¿™ä¸€ä½åŸæœ¬æ˜¯0ï¼Œå®ƒå°†å˜ä¸º1ï¼›å¦‚æœåŸæœ¬æ˜¯1ï¼Œåˆ™ä¿æŒä¸å˜ã€‚

#### æ£€æµ‹å¥‡å¶æ€§

```c++
#include <iostream>

int main() {
    int number;

    std::cout << "Enter an integer: ";
    std::cin >> number;

    if (number & 1) {
        std::cout << "The number is odd." << std::endl;
    }
    else {
        std::cout << "The number is even." << std::endl;
    }

    return 0;
}

```



#### å¾ªç¯ä½ç§»

```c++
#include <iostream>
//ä¸è€ƒè™‘äºŒè¿›åˆ¶è´Ÿæ•°

int leftRotate(unsigned int value, int shift) {
    // ä½¿ç”¨ä½è¿ç®—å®ç°å·¦å¾ªç¯ä½ç§»
    return (value << shift) | (value >> (sizeof(value) * 8 - shift));
}

int main() {
    unsigned int number = 0b110110;  // äºŒè¿›åˆ¶è¡¨ç¤ºä¸º 110110

    // å·¦å¾ªç¯ä½ç§»3ä½
    unsigned int rotatedNumber = leftRotate(number, 3);
    return 0;
}

```



1. `(value << shift)`: è¿™éƒ¨åˆ†å°† `value` å·¦ç§» `shift` ä½ï¼Œå³å°†äºŒè¿›åˆ¶æ•°å·¦ç§» `shift` ä½ã€‚ä¾‹å¦‚ï¼Œå¦‚æœ `value` æ˜¯ `110110`ï¼Œè€Œ `shift` æ˜¯ `3`ï¼Œé‚£ä¹ˆè¿™éƒ¨åˆ†çš„ç»“æœå°±æ˜¯ `110`ã€‚
2. `(value >> (sizeof(value) * 8 - shift))`: è¿™éƒ¨åˆ†æ˜¯å°† `value` å³ç§» `(sizeof(value) * 8 - shift)` ä½ã€‚`sizeof(value)` è¿”å›çš„æ˜¯ `value` å˜é‡æ‰€å ç”¨çš„å­—èŠ‚æ•°ï¼Œé€šå¸¸ä¸º 4ï¼ˆ32 ä½ç³»ç»Ÿï¼‰æˆ– 8ï¼ˆ64 ä½ç³»ç»Ÿï¼‰ã€‚å› æ­¤ï¼Œ`(sizeof(value) * 8)` è¿”å›çš„æ˜¯ `value` å˜é‡æ‰€å ç”¨çš„ä½æ•°ã€‚`(sizeof(value) * 8 - shift)` å°±æ˜¯å‰©ä½™çš„ä½æ•°ï¼Œå³å³ç§»çš„ä½æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœ `value` æ˜¯ `110110`ï¼Œè€Œ `shift` æ˜¯ `3`ï¼Œé‚£ä¹ˆè¿™éƒ¨åˆ†çš„ç»“æœå°±æ˜¯ `110000000`ã€‚
3. `|`: è¿™æ˜¯æŒ‰ä½æˆ–æ“ä½œç¬¦ï¼Œå®ƒä¼šå°†ä¸¤ä¸ªæ“ä½œæ•°çš„å¯¹åº”ä½è¿›è¡Œæˆ–æ“ä½œï¼Œå³åªè¦æœ‰ä¸€ä¸ªä½æ˜¯ 1ï¼Œç»“æœçš„å¯¹åº”ä½å°±æ˜¯ 1ã€‚

# åŒºé—´é—®é¢˜

|          | åŒºé—´æ±‚å’Œ | åŒºé—´æœ€å¤§å€¼ | åŒºé—´ä¿®æ”¹ | å•ç‚¹ä¿®æ”¹ |
| -------- | -------- | ---------- | -------- | -------- |
| å‰ç¼€å’Œ   | 1        | 0          | 0        | 0        |
| å·®åˆ†     | 0        | 0          | 1        | 0        |
| æ ‘çŠ¶æ•°ç»„ | 1        | 1          | 0        | 1        |
| çº¿æ®µæ ‘   | 1        | 1          | 1        | 1        |

## å‰ç¼€å’Œ

```c++
prefixSum[i]=arr[0]+arr[1]+â‹¯+arr[iâˆ’1]+arr[i]
    
//å…¶ä¸­prefixsum[0]=0;
```



###  **æ±‚ä»»æ„åŒºé—´çš„å’Œ**

```c++
//åŒºé—´[l,r]ç­‰äºprefixsum[r]-prefixsum[l-1];
#include<iostream>
using namespace std;
int arr[1010];
int s[10010];
int main() {
	int n, m;
	scanf("%d ", &n,&m);
	for (int i = 1; i <= n; i++) {//ä¸‹æ ‡ä»ä¸€å¼€å§‹ï¼Œå¦‚æœä¸‹æ ‡ä»é›¶å¼€å§‹è¦é‡æ–°è®¾è®¡
		scanf("%d", &arr[i]);
		s[i] = s[i - 1] + arr[i];
	}
	while (m--) {
		int l, r;
		scanf("%d %d", &l, &r);
		printf("%d", s[r] - s[l - 1]);
	}
	return 0;
	
	
}
```



### åŠ›æ‰£3179

### äºŒç»´å‰ç¼€å’Œ

https://www.bilibili.com/video/BV18P411g7cu/?spm_id_from=333.337.search-card.all.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

```c++
//äºŒç»´å‰ç¼€å’Œs[i][j]è¡¨ç¤ºå‰iè¡Œå‰jåˆ—çš„çŸ©é˜µå…ƒç´ ä¹‹å’Œ
//i1è¡Œ,j1åˆ—ä¸i2è¡Œï¼Œj2åˆ—ä¹‹é—´çš„çŸ©é˜µå…ƒç´ ä¹‹å’Œ


#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n, m;
    int arr[105][105] = {0}; // åˆå§‹åŒ–äºŒç»´æ•°ç»„ä¸º0ï¼Œé¿å…åƒåœ¾å€¼
    long long s[106][106] = {0}; // å‰ç¼€å’Œæ•°ç»„

    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> arr[i][j];
        }
    }

    // æ„å»ºå‰ç¼€å’Œæ•°ç»„
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + arr[i][j];
        }
    }

    int t;
    cin >> t;
    for (int i = 0; i < t; i++) {
        int i1, j1, i2, j2;
        cin >> i1 >> j1 >> i2 >> j2;
        long long result = s[i2][j2] - s[i1-1][j2] - s[i2][j1-1] + s[i1-1][j1-1];
        cout << result << endl; // æ¯ä¸ªæŸ¥è¯¢ç»“æœä¹‹åæ¢è¡Œ
    }

    return 0;
}

```



### ACWing1236é€’å¢ä¸‰å…ƒç»„

åˆ·ç¬¬äºŒéï¼Œçœ‹é”™é¢˜ç›®äº†...

```c++
#include<iostream>
using namespace std;
int n;
int a[100010],b[100010],c[100010];
int cnta[100010],cntc[100010];
int sa[100010],sc[100010];
//ç”¨cnta,cntcè¡¨ç¤ºæ•°ç»„a,cå¯¹åº”å…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯å› ä¸ºæ•°ç»„æ˜¯é¡ºåºçš„ï¼Œæ‰€ä»¥ç›¸å½“äºæˆ‘ä»¬æ’äº†åº
//æ¯”å¦‚å‡è®¾æ•°ç»„aæ˜¯1ï¼Œ2ï¼Œ3ï¼Œ5ï¼Œ5ï¼Œ6ï¼ˆä¸‹æ ‡ä»1å¼€å§‹ï¼‰
//é‚£ä¹ˆcntaå¯¹åº”çš„æ˜¯1 1 1 0 2 1
//è¿™ä¸‹æ¸…æ¥šäº†å§ï¼å› ä¸ºæ’äº†åºï¼Œæ‰€ä»¥å¯¹äºç‰¹å®šçš„b[i],åœ¨iå‰é¢çš„å°±æ˜¯å°äºb[i]çš„
int main(){
    cin>>n;
    long long res=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        cnta[++a[i]]++;
    }
    
    sa[0]=cnta[0];//æˆ‘ç»ˆäºçŸ¥é“ä¸ºä»€ä¹ˆäº†ï¼å› ä¸ºs[0]ä¸€èˆ¬é»˜è®¤ä¸ºé›¶ï¼Œå‰0é¡¹çš„å’Œå˜›ï¼Œä½†æ˜¯è¿™ä¸€é¢˜çš„æ•°æ®å¯ä»¥ä¸º0
    //ä¸ºäº†é¿å…å†²çªï¼Œ++a[i]ä¸€å®šå¤§äºé›¶äº†ï¼Œæ‰€ä»¥cnta[0]=0,æ»¡è¶³äº†sa[0]=0;
    for(int i=1;i<100010;i++) sa[i]=sa[i-1]+cnta[i];//æ³¨æ„è¿™é‡Œï¼Œå› ä¸ºnçš„å–å€¼èŒƒå›´æ˜¯100000
    //æ‰€ä»¥cnta[i]çš„å–å€¼èŒƒå›´æ˜¯0-100000ï¼Œä¸‡ä¸€éƒ½æ˜¯ä¸€ä¸ªæ•°å‘¢ï¼Œæ¯”å¦‚11111111
    for(int i = 1; i <= n; ++i){
        scanf("%d", &b[i]);
        b[i]++;
    } 
    for(int i=1;i<=n;i++){
        scanf("%d",&c[i]);
        cntc[++c[i]]++;
    }
    sc[0]=cntc[0];
    for(int i=1;i<100010;i++) sc[i]=sc[i-1]+cntc[i];
    for(int i=1;i<=n;i++){
        res+=(long long)sa[b[i]-1]*(sc[100010-1]-sc[b[i]]);
    }
    cout<<res;
    return 0;
    
}
```



## ä¸€ç»´å·®åˆ†

å·®åˆ†æ•°ç»„ç”¨äºå¿«é€Ÿæ›´æ–°æ•°ç»„çš„æŸä¸€æ®µåŒºé—´å†…çš„å…ƒç´ å€¼ã€‚å·®åˆ†æ•°ç»„çš„ä¸»è¦æ€æƒ³æ˜¯é€šè¿‡è®°å½•å˜åŒ–é‡æ¥é—´æ¥è¡¨ç¤ºæ•°ç»„çš„æ›´æ–°ã€‚ç›¸è¾ƒäºç›´æ¥æ›´æ–°æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œ**å·®åˆ†æ•°ç»„å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å¯¹æ•°ç»„è¿›è¡ŒåŒºé—´æ›´æ–°ã€‚**

### æ€§è´¨

1. å¯¹äºå·®åˆ†æ•°ç»„`0 0 0 0 0`,å¯¹d[1]åŠ ä¸€çš„ç»“æœæ˜¯å¯¹åŸæ•°ç»„åŒºé—´[1,n-1]éƒ½åŠ ä¸Š1
2. ä½¿ç”¨å·®åˆ†æ•°ç»„å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å¯¹åŸæ•°ç»„çš„æŸä¸ªåŒºé—´è¿›è¡Œæ›´æ–°æ“ä½œã€‚
3. å·®åˆ†æ•°ç»„çš„å‰ç¼€å’Œæ˜¯åŸæ•°ç»„
4. å‰ç¼€å’Œæ•°ç»„åšä¸€æ¬¡å·®åˆ†ä¹Ÿä¼šè¿”å›åˆ°åŸæ•°ç»„
5. å·®åˆ†æ•°ç»„é€‚ç”¨äºå¤šæ¬¡æ›´æ–°ï¼Œå•æ¬¡æŸ¥è¯¢çš„åœºæ™¯
6. å¯¹åŒºé—´[l,r]éƒ½åŠ ä¸Švalueï¼Œåªéœ€è¦å°†å·®åˆ†æ•°ç»„ï¼š`d[l]+value,d[r+1]-value`,åœ¨åšå‰ç¼€å’Œå³å¯å¾—åˆ°ç»“æœ

### ä¸€ç»´ä»£ç å®ç°

å®šä¹‰å·®åˆ†æ•°ç»„`d[i]=arr[i]-arr[i-1]`

å…¶ä¸­`d[0]=arr[0]`

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<int> constructDifferenceArray(const vector<int>& arr) {
    int n = arr.size();
    vector<int> diff(n + 1, 0);
    diff[0] = arr[0];
    for (int i = 1; i < n; i++) {
        diff[i] = arr[i] - arr[i - 1];
    }
    return diff;
}

void updateDifferenceArray(vector<int>& diff, int l, int r, int x) {
    diff[l] += x;
    if (r + 1 < diff.size()) {
        diff[r + 1] -= x;
    }
}

vector<int> restoreArrayFromDifferenceArray(const vector<int>& diff) {
    int n = diff.size();
    vector<int> arr(n, 0);
    arr[0] = diff[0];
    for (int i = 1; i < n; i++) {
        arr[i] = arr[i - 1] + diff[i];
    }
    return arr;
}

int main() {
    vector<int> arr = {2, 4, 6, 8, 10};
    vector<int> diff = constructDifferenceArray(arr);

    // Perform update operation: add 3 to the range [1, 3]
    updateDifferenceArray(diff, 1, 3, 3);

    // Restore the updated array
    vector<int> updatedArr = restoreArrayFromDifferenceArray(diff);

    for (int val : updatedArr) {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}

```





## äºŒç»´å·®åˆ†

https://www.bilibili.com/video/BV1pi4y1j7si/?p=4&spm_id_from=pageDriver&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

`b[i][j]=a[i][j]âˆ’a[iâˆ’1][j]âˆ’a[i][jâˆ’1]+a[iâˆ’1][jâˆ’1]`

### æ€§è´¨

1. å¯¹äºäºŒç»´å·®åˆ†æ•°ç»„`b[i][j]`,å¦‚æœ`b[i][j]+1`,ä¼šå½±å“åˆ°åç»­çš„ä¸€æ•´å—åŒºåŸŸ



```c++
#include <iostream>
#include <vector>
using namespace std;

// æ„é€ å·®åˆ†æ•°ç»„
void constructDifferenceArray(const vector<vector<int>>& a, vector<vector<int>>& differenceArray) {
    int m = a.size();
    int n = a[0].size();

    differenceArray[0][0] = a[0][0];
    for (int i = 1; i < m; i++) differenceArray[i][0] = a[i][0] - a[i - 1][0];
    for (int j = 1; j < n; j++) differenceArray[0][j] = a[0][j] - a[0][j - 1];
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            differenceArray[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
        }
    }
}

// æ›´æ–°å·®åˆ†æ•°ç»„
void updateDifferenceArray(vector<vector<int>>& differenceArray, int x1, int y1, int x2, int y2, int value) {
    differenceArray[x1][y1] += value;
    int m = differenceArray.size();
    int n = differenceArray[0].size();

    if (x2 + 1 < m) {
        differenceArray[x2 + 1][y1] -= value;
    }
    if (y2 + 1 < n) {
        differenceArray[x1][y2 + 1] -= value;
    }
    if (x2 + 1 < m && y2 + 1 < n) {
        differenceArray[x2 + 1][y2 + 1] += value;
    }
}

// ä»å·®åˆ†æ•°ç»„æ¢å¤åŸå§‹æ•°ç»„
void restoreArrayFromDifferenceArray(vector<vector<int>>& a, const vector<vector<int>>& differenceArray) {
    int m = a.size();
    int n = a[0].size();
    a[0][0] = differenceArray[0][0];

    for (int j = 1; j < n; j++) {
        a[0][j] = a[0][j - 1] + differenceArray[0][j];
    }
    for (int i = 1; i < m; i++) {
        a[i][0] = a[i - 1][0] + differenceArray[i][0];
    }

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + differenceArray[i][j];
        }
    }
}

int main() {
    vector<vector<int>> a = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int m = a.size();
    int n = a[0].size();
    vector<vector<int>> differenceArray(m, vector<int>(n, 0));

    // æ„é€ åˆå§‹å·®åˆ†æ•°ç»„
    constructDifferenceArray(a, differenceArray);

    // æ›´æ–°å·®åˆ†æ•°ç»„
    updateDifferenceArray(differenceArray, 0, 0, 1, 1, 10);

    // æ¢å¤æ›´æ–°åçš„åŸæ•°ç»„
    restoreArrayFromDifferenceArray(a, differenceArray);

    // æ‰“å°æ›´æ–°åçš„åŸæ•°ç»„
    cout << "Updated Original Array:" << endl;
    for (const auto& row : a) {
        for (const auto& elem : row) {
            cout << elem << " ";
        }
        cout << endl;
    }

    return 0;
}

```



## çº¿æ®µæ ‘

**å®šä¹‰**

çº¿æ®µæ ‘æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œé€šå¸¸ç”¨æ¥å­˜å‚¨æ•°ç»„åŒºé—´çš„ä¿¡æ¯ã€‚æ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªåŒºé—´ï¼ŒèŠ‚ç‚¹çš„å€¼é€šå¸¸è¡¨ç¤ºè¯¥åŒºé—´çš„ä¸€äº›å±æ€§ï¼ˆå¦‚åŒºé—´å’Œã€åŒºé—´æœ€å°å€¼ç­‰ï¼‰ã€‚çº¿æ®µæ ‘çš„æ ¹èŠ‚ç‚¹è¡¨ç¤ºæ•´ä¸ªæ•°ç»„çš„åŒºé—´ï¼Œæ ¹èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹åˆ†åˆ«è¡¨ç¤ºæ•°ç»„çš„å·¦åŠéƒ¨åˆ†å’Œå³åŠéƒ¨åˆ†ï¼Œä¾æ­¤ç±»æ¨ã€‚

çº¿æ®µæ ‘ç®—æ³•ä¸­å¸¸ç”¨åˆ°ï¼š

1. nodeindexï¼šè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ä¸‹æ ‡
2. startè¡¨ç¤ºdataæ•°ç»„åŒºé—´å·¦ç«¯ç‚¹ä¸‹æ ‡
3. endè¡¨ç¤ºdataæ•°ç»„åŒºé—´å³ç«¯ç‚¹ä¸‹æ ‡
4. leftindexè¡¨ç¤ºå½“å‰è®¿é—®ç«¯ç‚¹å·¦å­©å­ä¸‹æ ‡
5. rightindexè¡¨ç¤ºå½“å‰è®¿é—®ç«¯ç‚¹å³å­©å­ä¸‹æ ‡ 



â€‹      

**ç”¨é€”**

1. **åŒºé—´æŸ¥è¯¢**ï¼šä¾‹å¦‚ï¼ŒæŸ¥è¯¢æ•°ç»„æŸä¸ªåŒºé—´å†…çš„æœ€å°å€¼ã€æœ€å¤§å€¼ã€å’Œã€ä¹˜ç§¯ç­‰ã€‚è¯·æ³¨æ„ï¼ŒåŒºé—´æŸ¥è¯¢ä¸‹æ ‡æ˜¯æ•°ç»„ä¸‹æ ‡ï¼ï¼
2. **åŒºé—´æ›´æ–°**ï¼šä¾‹å¦‚ï¼Œå°†æ•°ç»„æŸä¸ªåŒºé—´å†…çš„æ¯ä¸ªå…ƒç´ éƒ½å¢åŠ ä¸€ä¸ªå›ºå®šå€¼ï¼Œæˆ–å°†æŸä¸ªåŒºé—´å†…çš„å€¼å…¨éƒ¨è®¾ä¸ºæŸä¸ªå€¼ã€‚
3. **åŠ¨æ€æ•°æ®å¤„ç†**ï¼šçº¿æ®µæ ‘æ”¯æŒåœ¨æ•°æ®æ›´æ–°çš„åŒæ—¶ï¼Œä¿æŒå¿«é€Ÿçš„æŸ¥è¯¢æ€§èƒ½ï¼Œé€‚åˆåŠ¨æ€æ•°æ®å¤„ç†åœºæ™¯ã€‚

 		

**æ—¶é—´å¤æ‚åº¦**

- çº¿æ®µæ ‘çš„æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(logâ¡ğ‘›)ã€‚
- çº¿æ®µæ ‘çš„æ„å»ºæ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(ğ‘›)ã€‚





**æ‡’æƒ°æ ‡è®°çº¿æ®µæ ‘**

æ‡’æƒ°æ ‡è®°ï¼ˆLazy Propagationï¼‰æ˜¯ä¸€ç§ä¼˜åŒ–æŠ€æœ¯ï¼Œç”¨äºæé«˜çº¿æ®µæ ‘å¤„ç†åŒºé—´æ›´æ–°æ“ä½œçš„æ•ˆç‡ã€‚å®ƒé€šè¿‡æ¨è¿Ÿæ›´æ–°æ“ä½œç›´åˆ°çœŸæ­£éœ€è¦æ—¶æ‰è¿›è¡Œï¼Œä»è€Œé¿å…åœ¨æ¯æ¬¡æ›´æ–°æ—¶å¯¹æ•´ä¸ªåŒºé—´è¿›è¡Œé‡å¤æ“ä½œã€‚è¿™æ ·å¯ä»¥æ˜¾è‘—å‡å°‘æ›´æ–°æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ã€‚

åœ¨æ ‡å‡†çº¿æ®µæ ‘ä¸­ï¼Œæ¯æ¬¡æ›´æ–°æ“ä½œéƒ½ä¼šå½±å“åˆ°ç›¸å…³åŒºé—´çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¯¼è‡´æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ã€‚æ‡’æƒ°æ ‡è®°é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¼˜åŒ–ï¼š

1. **å»¶è¿Ÿæ›´æ–°**ï¼šå°†æ›´æ–°æ“ä½œè®°å½•åœ¨æ‡’æƒ°æ ‡è®°æ•°ç»„ä¸­ï¼Œè€Œä¸ç«‹å³æ›´æ–°æ‰€æœ‰ç›¸å…³èŠ‚ç‚¹ã€‚
2. **ä¼ æ’­æ›´æ–°**ï¼šåœ¨æŸ¥è¯¢æˆ–è¿›ä¸€æ­¥æ›´æ–°æ“ä½œæ—¶ï¼Œå†å°†ä¹‹å‰è®°å½•çš„æ›´æ–°æ“ä½œåº”ç”¨åˆ°ç›¸å…³èŠ‚ç‚¹ä¸Šã€‚



**æ‡’æƒ°æ ‡è®°æœºåˆ¶çš„å®ç°ä¸­ï¼Œåœ¨è¿›è¡Œçº¿æ®µæ ‘çš„æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œä¹‹å‰ï¼Œé€šå¸¸ä¼šå…ˆæ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦æœ‰æ‡’æƒ°æ ‡è®°ã€‚è¿™æ˜¯ä¸ºäº†ç¡®ä¿åœ¨éœ€è¦è¿›è¡ŒæŸ¥è¯¢æˆ–æ›´æ–°æ“ä½œæ—¶ï¼Œé¦–å…ˆå°†å»¶è¿Ÿæ›´æ–°åº”ç”¨åˆ°å½“å‰èŠ‚ç‚¹ä¸Šï¼Œç„¶åå†è¿›è¡Œç›¸åº”çš„æ“ä½œï¼Œä»è€Œä¿è¯æ•°æ®çš„å‡†ç¡®æ€§å’Œä¸€è‡´æ€§ã€‚**



### æ±‚å’Œçº¿æ®µæ ‘

```c++
#include<iostream>
#include<vector>
#include<numeric>
using namespace std;
#include <vector>
using namespace std;

#include <vector>
#include <iostream>
using namespace std;

class SegmentTree {
private:
    vector<int> Tree;
    vector<int> Lazy;
    vector<int> data;
    int n;

    void BuildTree(int node, int start, int end) {
        if (start == end) {
            Tree[node] = data[start];
        }
        else {
            int mid = (start + end) / 2;
            int leftindex = 2 * node;
            int rightindex = 2 * node + 1;
            BuildTree(leftindex, start, mid);
            BuildTree(rightindex, mid + 1, end);
            Tree[node] = Tree[leftindex] + Tree[rightindex];
        }
    }

    void propagate(int node, int start, int end) {

        if (Lazy[node] != 0) {
            
            Tree[node] += (end - start + 1) * Lazy[node];
            if (start != end) {
                Lazy[node * 2] += Lazy[node];
                Lazy[node * 2 + 1] += Lazy[node];
            }
            Lazy[node] = 0;
        }
    }

    void updateRange(int node, int start, int end, int L, int R, int val) {
        propagate(node, start, end);
        if (start > end || start > R || end < L) {
            return;
        }

        if (L <= start && end <= R) {
            //å¦‚æœå½“å‰åŒºé—´è¢«åŒ…å«åœ¨æŸ¥è¯¢åŒºé—´ä¸­ï¼Œé‚£ä¹ˆå°±ä¸ç»§ç»­å‘ä¸‹æ›´æ–°ï¼Œè€Œæ˜¯é€‰æ‹©åŸè·¯è¿”å›ï¼Œç”¨æ‡’æƒ°æ ‡è®°æ ‡è®°è¯¥èŠ‚ç‚¹
            //å¹¶ä¸”ç»™å·¦å­©å­å’Œå³å­©å­è®°è´¦ï¼Œç­‰è®¿é—®å·¦å­©å­å³å­©å­çš„æ—¶å€™ï¼Œä¼šå…ˆæŸ¥ä¸€ä¸‹è¯¥èŠ‚ç‚¹æœ‰æ²¡æœ‰çˆ¶èŠ‚ç‚¹ç•™ä¸‹çš„å¸
            //å¦‚æœæœ‰ï¼Œå°±è¦å…ˆæ›´æ–°ï¼Œä¹Ÿå°±æ˜¯æœ¬å‡½æ•°å¼€å¤´çš„propagateå‡½æ•°
            Tree[node] += (end - start + 1) * val;
            if (start != end) {
                Lazy[node * 2] += val;
                Lazy[node * 2 + 1] += val;
            }
            return;
        }

        int mid = (start + end) / 2;
        updateRange(node * 2, start, mid, L, R, val);
        updateRange(node * 2 + 1, mid + 1, end, L, R, val);
        Tree[node] = Tree[node * 2] + Tree[node * 2 + 1];
    }

    int queryRange(int node, int start, int end, int L, int R) {
        propagate(node, start, end);
        if (start > end || start > R || end < L) {
            return 0;
        }

        if (L <= start && end <= R) {
            return Tree[node];
        }

        int mid = (start + end) / 2;
        int leftSum = queryRange(node * 2, start, mid, L, R);
        int rightSum = queryRange(node * 2 + 1, mid + 1, end, L, R);
        return leftSum + rightSum;
    }

    


    //å…ˆæ‰¾åˆ°å¯¹åº”èŠ‚ç‚¹ï¼Œæ›´æ–°ï¼ŒååŸè·¯æ›´æ–°è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼
    void updateTree(int node, int start, int end, int idx, int val) {
        if (start == end) {
            data[idx] = val;
            Tree[node] = val;
        }
        else {
            int mid = (start + end) / 2;
            int leftChild = 2 * node + 1;
            int rightChild = 2 * node + 2;
            if (start <= idx && idx <= mid) {
                updateTree(leftChild, start, mid, idx, val);
            }
            else {
                updateTree(rightChild, mid + 1, end, idx, val);
            }
            Tree[node] = Tree[leftChild] + Tree[rightChild];
        }
    }

public:
    SegmentTree(const vector<int>& data) {
        this->data = data;
        this->n = data.size();
        Tree.resize(4 * n);
        Lazy.resize(4 * n, 0);
        BuildTree(1, 0, n - 1);
    }

    void update(int idx, int val) {
        updateTree(0, 0, n - 1, idx, val);
    }

    void updateRange(int L, int R, int val) {
        updateRange(1, 0, n - 1, L, R, val);
    }

  

    int queryRange(int L, int R) {
        return queryRange(1, 0, n - 1, L, R);
    }
};


int main() {
    std::vector<int> data(100);
    iota(data.begin(), data.end(), 1);
    
    SegmentTree segTree(data);
  
    
    return 0;

}
```



### ä¹˜æ³•(æ ¹å·)çº¿æ®µæ ‘

å½“æˆ‘ä»¬å¯¹åŒºé—´è¿›è¡ŒåŒæ—¶åŠ å’Œä¹˜çš„æ—¶å€™ï¼Œåº”è¯¥æœ‰ä¸¤ä¸ªæ‡’æƒ°æ ‡è®°

ä¹˜æ³•æ ‡è®°ï¼šåˆå§‹å€¼ä¸º1

åŠ æ³•æ ‡è®°ï¼šåˆå§‹å€¼ä¸º0

åœ¨pushdownå‡½æ•°ä¸­ï¼Œé¦–å…ˆè·å¾—è¯¥èŠ‚ç‚¹çš„ä¹˜æ³•æ‡’æƒ°æ ‡è®°å’ŒåŠ æ³•æ‡’æƒ°æ ‡è®°

ç„¶åæ›´æ–°å·¦å³å­©å­èŠ‚ç‚¹çš„æ‡’æƒ°æ ‡è®°

å·¦å­©å­çš„ä¹˜æ³•æ‡’æƒ°æ ‡è®°ç­‰äºå·¦å­©å­ä¹˜æ³•æ‡’æƒ°æ ‡è®°ä¹˜å½“å‰èŠ‚ç‚¹çš„ä¹˜æ³•æ‡’æƒ°æ ‡è®°

å·¦å­©å­çš„åŠ æ³•æ‡’æƒ°æ ‡è®°ç­‰äºå·¦å­©å­åŠ æ³•æ‡’æƒ°æ ‡è®°ä¹˜å½“å‰èŠ‚ç‚¹çš„ä¹˜æ³•æ‡’æƒ°æ ‡è®°å€¼åŠ ä¸Šå½“å‰èŠ‚ç‚¹çš„åŠ æ³•æ‡’æƒ°æ ‡è®°

```c++
#include <vector>
#include <iostream>

using namespace std;

const long long p = 1e9 + 7;

struct SegmentTreeNode {
    long long sum = 0;
    long long mlz = 1; // Multiplicative lazy tag, initially 1
    long long plz = 0; // Additive lazy tag, initially 0
    int l = 0, r = 0;
};

vector<SegmentTreeNode> tree;

// Initialize the segment tree with a given array size
void init(int n) {
    tree.resize(4 * n); // Allocate sufficient space for segment tree
}

// Build the segment tree
void build(vector<int>& arr, int i, int l, int r) {
    tree[i].l = l;
    tree[i].r = r;
    if (l == r) {
        tree[i].sum = arr[l];
        return;
    }
    int mid = (l + r) / 2;
    build(arr, 2 * i, l, mid);
    build(arr, 2 * i + 1, mid + 1, r);
    tree[i].sum = (tree[2 * i].sum + tree[2 * i + 1].sum) % p;
}

// Pushdown function to propagate lazy updates
void pushdown(int i) {
    long long k1 = tree[i].mlz, k2 = tree[i].plz;
    if (tree[i].l != tree[i].r) { // Not a leaf node
        // Update left child
        tree[2 * i].sum = (tree[2 * i].sum * k1 + k2 * (tree[2 * i].r - tree[2 * i].l + 1)) % p;
        tree[2 * i].mlz = (tree[2 * i].mlz * k1) % p;
        tree[2 * i].plz = (tree[2 * i].plz * k1 + k2) % p;

        // Update right child
        tree[2 * i + 1].sum = (tree[2 * i + 1].sum * k1 + k2 * (tree[2 * i + 1].r - tree[2 * i + 1].l + 1)) % p;
        tree[2 * i + 1].mlz = (tree[2 * i + 1].mlz * k1) % p;
        tree[2 * i + 1].plz = (tree[2 * i + 1].plz * k1 + k2) % p;
    }
    tree[i].mlz = 1;
    tree[i].plz = 0;
}

// Update function for range updates (multiplicative and additive)
void update(int i, int l, int r, long long k1, long long k2) {
    if (l <= tree[i].l && tree[i].r <= r) {
        tree[i].sum = (tree[i].sum * k1 + k2 * (tree[i].r - tree[i].l + 1)) % p;
        tree[i].mlz = (tree[i].mlz * k1) % p;
        tree[i].plz = (tree[i].plz * k1 + k2) % p;
        return;
    }
    pushdown(i);
    int mid = (tree[i].l + tree[i].r) / 2;
    if (l <= mid) update(2 * i, l, r, k1, k2);
    if (r > mid) update(2 * i + 1, l, r, k1, k2);
    tree[i].sum = (tree[2 * i].sum + tree[2 * i + 1].sum) % p;
}

// Query function to get the sum of a range
long long query(int i, int l, int r) {
    if (l <= tree[i].l && tree[i].r <= r) {
        return tree[i].sum;
    }
    pushdown(i);
    int mid = (tree[i].l + tree[i].r) / 2;
    long long res = 0;
    if (l <= mid) res = (res + query(2 * i, l, r)) % p;
    if (r > mid) res = (res + query(2 * i + 1, l, r)) % p;
    return res;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    init(n);
    build(arr, 1, 0, n - 1);

    // Example usage: updating range [1, 3] with k1 = 2 (multiplicative) and k2 = 3 (additive)
    update(1, 1, 3, 2, 3);
    cout << query(1, 1, 3) << endl; // Query the sum of range [1, 3]

    return 0;
}

```



### çº¿æ®µæ ‘çš„åº”ç”¨

1. åŒºé—´æœ€å€¼æŸ¥è¯¢å’Œæ›´æ–°
åº”ç”¨ï¼šåœ¨ç»™å®šæ•°ç»„ä¸­ï¼ŒæŸ¥è¯¢æŸä¸ªåŒºé—´å†…çš„æœ€å°å€¼æˆ–æœ€å¤§å€¼ï¼Œä»¥åŠåœ¨æ•°ç»„çš„æŸä¸ªä½ç½®æ›´æ–°ä¸€ä¸ªå€¼ã€‚
ç¤ºä¾‹ï¼šåœ¨ç”µå•†å¹³å°ä¸­ï¼ŒæŸ¥è¯¢æŸä¸€æ—¶é—´æ®µå†…å•†å“çš„æœ€ä½ä»·æ ¼ã€‚
2. åŒºé—´å’ŒæŸ¥è¯¢å’Œæ›´æ–°
åº”ç”¨ï¼šæ±‚æ•°ç»„æŸä¸ªåŒºé—´å†…çš„å…ƒç´ å’Œï¼Œä»¥åŠåœ¨æŸä¸ªä½ç½®æˆ–åŒºé—´å†…è¿›è¡Œæ›´æ–°æ“ä½œã€‚
ç¤ºä¾‹ï¼šç»Ÿè®¡æŸæ®µæ—¶é—´å†…ç½‘ç«™çš„æ€»è®¿é—®é‡ï¼Œå¹¶èƒ½å¿«é€Ÿæ›´æ–°æŸå¤©çš„è®¿é—®é‡ã€‚
3. åŒºé—´ä¹˜ç§¯æŸ¥è¯¢å’Œæ›´æ–°
åº”ç”¨ï¼šæŸ¥è¯¢æ•°ç»„æŸä¸ªåŒºé—´å†…å…ƒç´ çš„ä¹˜ç§¯ï¼Œå¹¶æ”¯æŒå•ç‚¹æ›´æ–°ã€‚
ç¤ºä¾‹ï¼šåœ¨é‡‘èç³»ç»Ÿä¸­ï¼Œè®¡ç®—æŸæ®µæ—¶é—´å†…çš„æŠ•èµ„æ”¶ç›Šï¼Œå¹¶èƒ½å¿«é€Ÿæ›´æ–°æŸå¤©çš„æ”¶ç›Šã€‚
4. åŒºé—´æœ€å¤§å…¬çº¦æ•° (GCD) æŸ¥è¯¢
åº”ç”¨ï¼šæŸ¥è¯¢æ•°ç»„æŸä¸ªåŒºé—´å†…çš„æœ€å¤§å…¬çº¦æ•°ã€‚
ç¤ºä¾‹ï¼šåœ¨æ•°å­¦åˆ†æä¸­ï¼Œæ‰¾åˆ°æŸä¸ªåŒºé—´å†…æ‰€æœ‰æ•°çš„æœ€å¤§å…¬çº¦æ•°ã€‚
5. åŒºé—´æœ€å°å…¬å€æ•° (LCM) æŸ¥è¯¢
åº”ç”¨ï¼šæŸ¥è¯¢æ•°ç»„æŸä¸ªåŒºé—´å†…çš„æœ€å°å…¬å€æ•°ã€‚
ç¤ºä¾‹ï¼šåœ¨æ’ç­ç³»ç»Ÿä¸­ï¼Œæ‰¾åˆ°æŸæ®µæ—¶é—´å†…å¤šä¸ªå‘¨æœŸä»»åŠ¡çš„å…±åŒå‘¨æœŸã€‚
6. åŒºé—´ä¼—æ•°æŸ¥è¯¢
åº”ç”¨ï¼šåœ¨æ•°ç»„çš„æŸä¸ªåŒºé—´å†…ï¼ŒæŸ¥æ‰¾å‡ºç°æ¬¡æ•°æœ€å¤šçš„å…ƒç´ ã€‚
ç¤ºä¾‹ï¼šç»Ÿè®¡æŸæ®µæ—¶é—´å†…æœ€çƒ­é—¨çš„å•†å“ã€‚
7. åŒºé—´é€†åºå¯¹æŸ¥è¯¢
åº”ç”¨ï¼šè®¡ç®—æ•°ç»„æŸä¸ªåŒºé—´å†…çš„é€†åºå¯¹æ•°é‡ã€‚
ç¤ºä¾‹ï¼šåœ¨æ’åºç®—æ³•çš„ä¼˜åŒ–ä¸­ï¼Œç»Ÿè®¡é€†åºå¯¹çš„æ•°é‡ä»¥å†³å®šæ˜¯å¦ä½¿ç”¨å½’å¹¶æ’åºã€‚
8. åŒºé—´æœ€å°å€¼å·®æŸ¥è¯¢
åº”ç”¨ï¼šæŸ¥è¯¢æŸä¸ªåŒºé—´å†…æœ€å°å€¼å’Œæ¬¡å°å€¼ä¹‹é—´çš„å·®å€¼ã€‚
ç¤ºä¾‹ï¼šåœ¨æ¯”èµ›æˆç»©åˆ†æä¸­ï¼Œæ‰¾åˆ°æŸæ®µæ—¶é—´å†…æˆç»©æœ€æ¥è¿‘çš„ä¸¤åé€‰æ‰‹ã€‚
9. åŠ¨æ€æ±‚è§£ç›´æ–¹å›¾ä¸­çš„æœ€å¤§çŸ©å½¢é¢ç§¯
åº”ç”¨ï¼šæ±‚è§£åŠ¨æ€å˜åŒ–çš„ç›´æ–¹å›¾ä¸­çš„æœ€å¤§çŸ©å½¢é¢ç§¯é—®é¢˜ã€‚
ç¤ºä¾‹ï¼šåœ¨å›¾åƒå¤„ç†å’Œåˆ†æä¸­ï¼Œæ‰¾å‡ºå›¾åƒä¸­æœ€å¤§è¿é€šå—çš„é¢ç§¯ã€‚
10. å­—ç¬¦ä¸²é—®é¢˜
åº”ç”¨ï¼šå¤„ç†å­—ç¬¦ä¸²çš„ä¸€äº›æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œï¼Œå¦‚åŒºé—´å­—ç¬¦ç»Ÿè®¡ã€åŒºé—´å›æ–‡åˆ¤æ–­ç­‰ã€‚
ç¤ºä¾‹ï¼šåœ¨æ–‡æœ¬ç¼–è¾‘å™¨ä¸­ï¼Œç»Ÿè®¡æŸæ®µæ–‡å­—ä¸­çš„ç‰¹å®šå­—ç¬¦å‡ºç°æ¬¡æ•°ã€‚
11. åŒºé—´è¦†ç›–é—®é¢˜
åº”ç”¨ï¼šè§£å†³åŒºé—´è¦†ç›–é—®é¢˜ï¼Œå¦‚åŒºé—´æ¶‚è‰²ã€åŒºé—´è¦†ç›–ç­‰ã€‚
ç¤ºä¾‹ï¼šåœ¨åœ°ç†ä¿¡æ¯ç³»ç»Ÿï¼ˆGISï¼‰ä¸­ï¼ŒæŸ¥è¯¢æŸå—åŒºåŸŸå†…çš„è¦†ç›–æƒ…å†µã€‚
12. æ•°æ®å‹ç¼©
åº”ç”¨ï¼šåˆ©ç”¨çº¿æ®µæ ‘è¿›è¡Œæ•°æ®å‹ç¼©å’Œç¨€ç–çŸ©é˜µçš„å­˜å‚¨ã€‚
ç¤ºä¾‹ï¼šåœ¨æ•°æ®å‹ç¼©ç®—æ³•ä¸­ï¼Œç”¨çº¿æ®µæ ‘è®°å½•ç¨€ç–çŸ©é˜µçš„éé›¶å…ƒç´ ã€‚
13. åŠ¨æ€æ’åˆ—ç»Ÿè®¡
åº”ç”¨ï¼šç»Ÿè®¡åŠ¨æ€æ’åˆ—ä¸­çš„é€†åºå¯¹ã€æ’åˆ—çš„é¡ºåºç»Ÿè®¡ç­‰ã€‚
ç¤ºä¾‹ï¼šåœ¨å®æ—¶æ’åºç³»ç»Ÿä¸­ï¼Œç»Ÿè®¡åŠ¨æ€æ’åºç»“æœçš„é€†åºå¯¹æ•°é‡ã€‚
14. å¤šç»´çº¿æ®µæ ‘
åº”ç”¨ï¼šè§£å†³å¤šç»´æ•°æ®çš„åŒºé—´æŸ¥è¯¢å’Œæ›´æ–°é—®é¢˜ï¼Œå¦‚äºŒç»´çº¿æ®µæ ‘ã€‚
ç¤ºä¾‹ï¼šåœ¨å›¾åƒå¤„ç†å’Œåˆ†æä¸­ï¼Œè¿›è¡ŒäºŒç»´åŒºåŸŸçš„å¿«é€Ÿç»Ÿè®¡å’Œæ›´æ–°ã€‚

## åŠ›æ‰£100306

## åŠ›æ‰£3619

## åˆ é™¤é¡ºåºè¡¨æ‰€æœ‰å€¼ä¸ºxçš„å…ƒç´ 

è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸ºOï¼ˆnï¼‰ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºOï¼ˆ1ï¼‰

```c++
//æ•´ä½“å»ºè¡¨
void func1(vector<int>& arr, int x) {
	int n = arr.size();
	int k = 0;
	for (int i = 0; i < n; i++) {
		if (arr[i] != x) {
			arr[k] = arr[i];
			k++;
		}		
	}

	arr.resize(k);
}

//å…ƒç´ ç§»åŠ¨æ³•
void func2(vector<int>& arr, int x) {
	int i = 0;
	int n = arr.size();
	int k = 0;
	while (i < n) {
		if (arr[i] == x) {
			k++;
		}
		else {
			arr[i - k] = arr[i];
		}

		i++;
	}

	arr.resize(n - k);
}
```



### æŠŠæ•°ç»„ä¸­å¥‡æ•°æ”¾åˆ°å¶æ•°çš„å‰é¢

```c++
//åŒºé—´åˆ’åˆ†æ³•
void func(vector<int>& arr) {
	int i = -1;
	int j = 0;
	int n = arr.size();
	for (j; j < n; j++) {
		if (arr[j] % 2 == 1) {
			i++;
			if (i != j) {
				swap(arr[i], arr[j]);
			}
		}
		
	}
	
}
```



# æ ‘



### åŠ›æ‰£äºŒå‰æœç´¢æ ‘

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚

æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š  

èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
//cè¯­è¨€å…ˆåºé€’å½’éå†
//ç®—æ³•æ€è·¯
//æˆ‘ä»¬è¦ç†è§£æœç´¢äºŒå‰æ ‘è¦ä¿è¯æ‰€æœ‰å·¦å­æ ‘éƒ½æ¯”æ ¹èŠ‚ç‚¹å°ï¼Œæ‰€æœ‰å³å­æ ‘éƒ½æ¯”æ ¹èŠ‚ç‚¹å¤§
//æ‰€ä»¥æˆ‘ä»¬è®¾ç½®ä¸€ä¸ªèŒƒå›´ï¼Œé¦–å…ˆæ˜¯æ ¹èŠ‚ç‚¹çš„èŒƒå›´æœ€å¤§ï¼Œç„¶ä¹ä¾æ¬¡å‡å°è¿™ä¸ªèŒƒå›´å»é€’å½’ï¼Œæ‰èƒ½ä¿è¯å®ç°
//ç¬¬ä¸€æ¬¡è¿™ä¸ªèŒƒå›´å¾ˆå¤§ï¼Œè®¾ç½®ä¸ºæ•´å‹æ•°å­—çš„å¤§å°
//éå†å·¦èŠ‚ç‚¹çš„æ—¶å€™ï¼Œè¿™ä¸ªèŒƒå›´çš„ä¸Šç•Œå˜æˆæ ¹èŠ‚ç‚¹çš„æ•°å€¼ï¼Œéå†å³èŠ‚ç‚¹æ—¶ï¼Œä¸‹ç•Œå˜æˆæ ¹èŠ‚ç‚¹çš„æ•°å€¼
//ä¿è¯èŠ‚ç‚¹çš„æ•°å€¼åœ¨è¿™ä¸ªèŒƒå›´ä¹‹å†…ä¹‹åï¼Œéå†å·¦å­æ ‘,éå†å³å­æ ‘
bool judge(struct TreeNode* root,long int min_val,long int max_val){
    if (root==NULL){
        return true;
    }
    if ((root->val>=max_val)||(root->val<=min_val)){
        return false;
    }

    return judge(root->left,min_val,root->val) && judge(root->right,root->val,max_val);

}

bool isValidBST(struct TreeNode* root){
    long int min_val = -2147483649;
    long int max_val = 2147483648;
    return judge(root,min_val,max_val);

}
```

```c++
//c++é€’å½’éå†
//ç®—æ³•æ€è·¯
//æˆ‘ä»¬è¦ç†è§£æœç´¢äºŒå‰æ ‘è¦ä¿è¯æ‰€æœ‰å·¦å­æ ‘éƒ½æ¯”æ ¹èŠ‚ç‚¹å°ï¼Œæ‰€æœ‰å³å­æ ‘éƒ½æ¯”æ ¹èŠ‚ç‚¹å¤§
//æ‰€ä»¥æˆ‘ä»¬è®¾ç½®ä¸€ä¸ªèŒƒå›´ï¼Œé¦–å…ˆæ˜¯æ ¹èŠ‚ç‚¹çš„èŒƒå›´æœ€å¤§ï¼Œç„¶ä¹ä¾æ¬¡å‡å°è¿™ä¸ªèŒƒå›´å»é€’å½’ï¼Œæ‰èƒ½ä¿è¯å®ç°
//ç¬¬ä¸€æ¬¡è¿™ä¸ªèŒƒå›´å¾ˆå¤§ï¼Œè®¾ç½®ä¸ºæ•´å‹æ•°å­—çš„å¤§å°
//éå†å·¦èŠ‚ç‚¹çš„æ—¶å€™ï¼Œè¿™ä¸ªèŒƒå›´çš„ä¸Šç•Œå˜æˆæ ¹èŠ‚ç‚¹çš„æ•°å€¼ï¼Œéå†å³èŠ‚ç‚¹æ—¶ï¼Œä¸‹ç•Œå˜æˆæ ¹èŠ‚ç‚¹çš„æ•°å€¼
//ä¿è¯èŠ‚ç‚¹çš„æ•°å€¼åœ¨è¿™ä¸ªèŒƒå›´ä¹‹å†…ä¹‹åï¼Œéå†å·¦å­æ ‘,éå†å³å­æ ‘
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;//å¦‚æœæ˜¯ç©ºæ ‘ï¼Œæ‰‹åŠ¨è®¤ä¸ºå±äºæœç´¢äºŒå‰æ ‘
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        //éå†å·¦å­æ ‘å’Œå³å­æ ‘ï¼Œå¹¶ä¸”æ»¡è¶³å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯æœç´¢äºŒå‰æ ‘æ‰å¯ä»¥
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};



//éé€’å½’
//è®°å¾—ä½¿ç”¨STLé‡Œé¢çš„stack
class Solution {
public:
    bool helper(TreeNode* root) {
        if (root == nullptr) {
            return true;//å¦‚æœæ˜¯ç©ºæ ‘ï¼Œè®¤ä¸ºå±äºæœç´¢äºŒå‰æ ‘
        }
        //åˆ›å»ºä¸€ä¸ªæ ˆs
        stack<TreeNode*>s;
        TreeNode *prev=NULL;//preæ˜¯èŠ‚ç‚¹å‰ä¸€ä¸ªèŠ‚ç‚¹
        while(root||s.empty())
        {
            while(root)
            {
                s.push(root);
                root=root->left;
            }
            root=s.pop();
            if(pre!=NULL&&root->val<=pre->val)//å¦‚æœèŠ‚ç‚¹å°äºå½“å‰èŠ‚ç‚¹
                return false
            pre=root;
            root=root->right
        }
        return true;      
};
```

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def helper(node, lower=float('-inf'), upper=float('inf')) -> bool:
            if not node:
                return True

            val = node.val
            if val <= lower or val >= upper:
                return False

            if not helper(node.right, val, upper):
                return False
            if not helper(node.left, lower, val):
                return False
            return True

        return helper(root)
    
    #åœ¨è¿™æ®µä»£ç ä¸­ï¼Œfloat('-inf') è¡¨ç¤ºè´Ÿæ— ç©·å¤§ï¼Œè€Œ float('inf') è¡¨ç¤ºæ­£æ— ç©·å¤§ã€‚åœ¨Pythonä¸­ï¼Œè¿™ä¸¤ä¸ªè¡¨ç¤ºæ— ç©·å¤§çš„å¸¸é‡å¯ä»¥ç”¨æ¥è¡¨ç¤ºä¸€ä¸ªèŒƒå›´çš„è¾¹ç•Œï¼Œä¾‹å¦‚åœ¨äºŒå‰æœç´¢æ ‘çš„é—®é¢˜ä¸­ï¼Œç”¨äºè¡¨ç¤ºèŠ‚ç‚¹å€¼çš„ä¸Šä¸‹è¾¹ç•Œã€‚
    
    
#ä¸­åºéé€’å½’ç®—æ³•
#è®¾ç½®ä¸€ä¸ªå‰èŠ‚ç‚¹
#äºŒå‰æ ‘çš„éé€’å½’éå†ä¸€èˆ¬ç”¨æ ˆæ¥å®ç°
#å½“æ ¹èŠ‚ç‚¹ä¸ç­‰äºç©ºæˆ–è€…æ ˆéç©ºæ—¶ï¼Œè¯´æ˜è¿˜æ²¡æœ‰éå†ç»“æŸ
#æŠŠå½“å‰æ ¹èŠ‚ç‚¹å…¥æ ˆï¼Œç„¶åè®¿é—®å·¦å­©å­
#å¦‚æœå·¦å­©å­ä¸ç­‰äºç©ºï¼Œç»§ç»­å¾ªç¯ï¼Œç›´åˆ°è®¿é—®åˆ°ç©ºèŠ‚ç‚¹
#æ­¤æ—¶æˆ‘ä»¬å‡ºæ ˆæ ¹èŠ‚ç‚¹ï¼Œç„¶ååˆ¤æ–­è¿™ä¸ªæ ¹èŠ‚ç‚¹çš„æ•°å€¼æ˜¯ä¸æ˜¯æ¯”å‰èŠ‚ç‚¹çš„æ•°å€¼å¤§ï¼Œå¦‚æœæ˜¯è¯´æ˜æ»¡è¶³
#å› ä¸ºä½¿ç”¨äº†éé€’å½’ç®—æ³•ï¼Œå½“ç¨‹åºè¿è¡Œåˆ°ç»“å°¾çš„æ—¶å€™è¿˜æ²¡æœ‰è¿”å›falseï¼Œè¯´æ˜æ˜¯æœç´¢äºŒå‰æ ‘
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        if not root:
            return True
        prev = None
        stack = []
        #äºŒå‰æœç´¢æ ‘ä¸­åºéå†éé€’å½’æ–¹å¼
        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            #åˆ¤æ–­å‰ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦å¤§äºç­‰äºå½“å‰èŠ‚ç‚¹ï¼Œæ˜¯åˆ™ä¸æ˜¯æœ‰æ•ˆçš„æœç´¢äºŒå‰æ ‘ï¼Œè¿”å›False
            if prev and root.val <= prev.val:
                return False
            #ä¿å­˜å‰ä¸€ä¸ªèŠ‚ç‚¹
            prev = root
            root = root.right
        return True
```

### åŠ›æ‰£å¯¹ç§°äºŒå‰æ ‘

æˆ‘çš„æ€è·¯æ˜¯ï¼šä¸­åºéå†äºŒå‰æ ‘ï¼Œå¾—åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç„¶åå†åˆ¤æ–­è¯¥å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡å­—ç¬¦ä¸²ï¼Œä½†æ˜¯ï¼š

å¯¹äºå¯¹ç§°äºŒå‰æ ‘ï¼Œä¸­åºéå†ç»“æœç¡®å®æ˜¯ä¸€ä¸ªå›æ–‡ä¸²ï¼Œä½†å¯¹äºéå¯¹ç§°äºŒå‰æ ‘ï¼Œä¸­åºéå†ç»“æœåŒæ ·å¯ä»¥æ˜¯å›æ–‡ä¸²ã€‚å› æ­¤ï¼Œä¸­åºéå†ç»“æœæ— æ³•å”¯ä¸€åœ°åæ˜ äºŒå‰æ ‘çš„å¯¹ç§°æ€§ã€‚

ä¸è¿‡ä¹Ÿæœ‰æ”¶è·ï¼Œä½ æ­£ç¡®çš„å†™å‡ºäº†å¦‚ä½•ä¸­åºéå†äºŒå‰æ ‘ç„¶åçš„åˆ°å­—ç¬¦ä¸²

```c++
    void InOrderTraverse(TreeNode* root, string &str) {
        if (root == nullptr) {
            return;
        }

        else
        {
            InOrderTraverse(root->left, str);
            str.push_back((char)root->val+'0');
            InOrderTraverse(root->right, str);
        }
    }

```

**ç®—æ³•æ€è·¯**

**é€’å½’**

äºŒå‰æ ‘çš„é—®é¢˜é€šå¸¸æ¶‰åŠæ ‘çš„æ·±åº¦å‘¨æ¸¸å’Œå¹¿åº¦å‘¨æ¸¸ç®—æ³•

ä½¿ç”¨é€’å½’æˆ–è¿­ä»£è¿›è¡Œæ¯”è¾ƒå·¦å³å­æ ‘

```c++
#include <iostream>
#include <vector>
#include <utility>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr)
            return true;

        return isMirror(root->left, root->right);
    }

    bool isMirror(TreeNode* left, TreeNode* right) {
        if (left == nullptr && right == nullptr)
            return true;

        if (left == nullptr || right == nullptr)
            return false;

        return (left->val == right->val) &&
               isMirror(left->left, right->right) &&
               isMirror(left->right, right->left);
    }
};

int main() {
    // åˆ›å»ºä¸€ä¸ªå¯¹ç§°çš„äºŒå‰æ ‘
    TreeNode* symmetricTree = new TreeNode(1);
    symmetricTree->left = new TreeNode(2);
    symmetricTree->right = new TreeNode(2);
    symmetricTree->left->left = new TreeNode(3);
    symmetricTree->left->right = new TreeNode(4);
    symmetricTree->right->left = new TreeNode(4);
    symmetricTree->right->right = new TreeNode(3);

    // åˆ›å»ºä¸€ä¸ªéå¯¹ç§°çš„äºŒå‰æ ‘
    TreeNode* nonSymmetricTree = new TreeNode(1);
    nonSymmetricTree->left = new TreeNode(2);
    nonSymmetricTree->right = new TreeNode(2);
    nonSymmetricTree->left->right = new TreeNode(3);
    nonSymmetricTree->right->right = new TreeNode(3);

    Solution solution;

    // æµ‹è¯•å¯¹ç§°çš„äºŒå‰æ ‘
    if (solution.isSymmetric(symmetricTree)) {
        cout << "symmetricTree is symmetric." << endl;
    } else {
        cout << "symmetricTree is not symmetric." << endl;
    }

    // æµ‹è¯•éå¯¹ç§°çš„äºŒå‰æ ‘
    if (solution.isSymmetric(nonSymmetricTree)) {
        cout << "nonSymmetricTree is symmetric." << endl;
    } else {
        cout << "nonSymmetricTree is not symmetric." << endl;
    }

    return 0;
}

```

**è¿­ä»£**

ã€Œæ–¹æ³•ä¸€ã€ä¸­æˆ‘ä»¬ç”¨é€’å½’çš„æ–¹æ³•å®ç°äº†å¯¹ç§°æ€§çš„åˆ¤æ–­ï¼Œé‚£ä¹ˆå¦‚ä½•ç”¨è¿­ä»£çš„æ–¹æ³•å®ç°å‘¢ï¼Ÿ**é¦–å…ˆæˆ‘ä»¬å¼•å…¥ä¸€ä¸ªé˜Ÿåˆ—ï¼Œè¿™æ˜¯æŠŠé€’å½’ç¨‹åºæ”¹å†™æˆè¿­ä»£ç¨‹åºçš„å¸¸ç”¨æ–¹æ³•ã€‚**åˆå§‹åŒ–æ—¶æˆ‘ä»¬æŠŠæ ¹èŠ‚ç‚¹å…¥é˜Ÿä¸¤æ¬¡ã€‚æ¯æ¬¡æå–ä¸¤ä¸ªç»“ç‚¹å¹¶æ¯”è¾ƒå®ƒä»¬çš„å€¼ï¼ˆé˜Ÿåˆ—ä¸­æ¯ä¸¤ä¸ªè¿ç»­çš„ç»“ç‚¹åº”è¯¥æ˜¯ç›¸ç­‰çš„ï¼Œè€Œä¸”å®ƒä»¬çš„å­æ ‘äº’ä¸ºé•œåƒï¼‰ï¼Œç„¶åå°†ä¸¤ä¸ªç»“ç‚¹çš„å·¦å³å­ç»“ç‚¹æŒ‰ç›¸åçš„é¡ºåºæ’å…¥é˜Ÿåˆ—ä¸­ã€‚å½“é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œæˆ–è€…æˆ‘ä»¬æ£€æµ‹åˆ°æ ‘ä¸å¯¹ç§°ï¼ˆå³ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸¤ä¸ªä¸ç›¸ç­‰çš„è¿ç»­ç»“ç‚¹ï¼‰æ—¶ï¼Œè¯¥ç®—æ³•ç»“æŸã€‚

```c++
class Solution {
public:
    bool check(TreeNode *u, TreeNode *v) {
        queue <TreeNode*> q;
        q.push(u); q.push(v);
        while (!q.empty()) {
            u = q.front(); q.pop();
            v = q.front(); q.pop();
            if (!u && !v) continue;
            if ((!u || !v) || (u->val != v->val)) return false;

            q.push(u->left); 
            q.push(v->right);

            q.push(u->right); 
            q.push(v->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};


```

æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯on

### åŠ›æ‰£éé€’å½’å±‚æ¬¡éå†äºŒå‰æ ‘

```c++
#include <iostream>
#include <queue>

// äºŒå‰æ ‘èŠ‚ç‚¹ç»“æ„
struct BiNode {
    char data;  // èŠ‚ç‚¹æ•°æ®
    BiNode* lchild;  // å·¦å­©å­æŒ‡é’ˆ
    BiNode* rchild;  // å³å­©å­æŒ‡é’ˆ

    BiNode(char value) : data(value), lchild(nullptr), rchild(nullptr) {}
};

// å±‚æ¬¡éå†å‡½æ•°
void LevelOrder(BiNode* root) {
    if (root == nullptr) {
        return;
    }

    std::queue<BiNode*> nodeQueue;
    nodeQueue.push(root);

    while (!nodeQueue.empty()) {
        BiNode* current = nodeQueue.front();//è®¿é—®å½“å‰èŠ‚ç‚¹
        nodeQueue.pop();//å¼¹å‡ºå½“å‰èŠ‚ç‚¹

        // è®¿é—®å½“å‰èŠ‚ç‚¹æ•°æ®
        std::cout << current->data << " ";

        // å°†å·¦å­©å­å…¥é˜Ÿ
        if (current->lchild != nullptr) {
            nodeQueue.push(current->lchild);
        }

        // å°†å³å­©å­å…¥é˜Ÿ
        if (current->rchild != nullptr) {
            nodeQueue.push(current->rchild);
        }
    }
}

int main() {
    // æ„å»ºä¸€ä¸ªç®€å•çš„äºŒå‰æ ‘
    BiNode* root = new BiNode('A');
    root->lchild = new BiNode('B');
    root->rchild = new BiNode('C');
    root->lchild->lchild = new BiNode('D');
    root->lchild->rchild = new BiNode('E');
    root->rchild->lchild = new BiNode('F');
    root->rchild->rchild = new BiNode('G');

    // æ‰§è¡Œå±‚æ¬¡éå†
    std::cout << "å±‚æ¬¡éå†ç»“æœ: ";
    LevelOrder(root);

    return 0;
}
```



# å­—ç¬¦ä¸²

### 15å±Šè“æ¡¥æ¯Ræ ¼å¼

é«˜ç²¾åº¦åŠ æ³•åŠ é«˜ç²¾åº¦ä¹˜æ³•åŠ å¿«é€Ÿå¹‚

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
string multiple(string a, string b) {
    int la = a.size(), lb = b.size();
    vector<int>result(la + lb, 0);
    int sum = 0, num = 0;
    for (int i = la - 1; i >= 0; i--) {
        for (int j = lb - 1; j >= 0; j--) {
            num = (a[i] - '0') * (b[j] - '0');
            sum = num + result[i + j + 1];
            result[i + j + 1] = sum % 10;
            result[i + j] += sum / 10;
        }
    }


    string ans;
    int n = result.size();
    for (int i=0; i <n; i++) {
        if (!(ans.empty() && result[i] == 0)) {
            ans.push_back(result[i] + '0');
        }
    }

    return ans.empty() ? "0" : ans;
}

int finddot(double d) {
    string dd = to_string(d);
    int i = 0;
    i = dd.find('.');
    return dd.size() - 1 - i;

}

string quickmultiple(int n) {
    string ans = "1";
    string b = "2";
    while (n) {
        if (n & 1) {
            ans = multiple(ans, b);
        }
        b = multiple(b,b);
        
        n >>=1;
    }
    return ans;
}

//å†å†™ä¸€ä¸ªé«˜ç²¾åº¦åŠ æ³•ï¼Œä¸‡ä¸€æ˜¯999.5
int main() {
    int n;
    string d;
    cin >> n >> d;
    int dotindex = d.find('.');
    int count = d.size() - dotindex - 1;
    d.erase(d.begin() + dotindex, d.begin() + dotindex + 1);
    string two = quickmultiple(n);
    string ans = multiple(two, d);
   
    //ä¸æ˜¯ç®€å•çš„å‘ä¸Šå–æ•´
    int judge = ans[ans.size() - count] - '0';
    if (judge > 4) {
        int carry = 1;
        int n = ans.size()-count;
        while (n--) {      
           int sum= ans[n] -'0'+carry;
           ans[n] = sum % 10 + '0';
           carry = sum / 10;
        }
        if (carry != 0) {
            ans.insert(ans.begin(), carry % 10 + '0');
        }

        ans.resize(ans.size() - count);

        cout << ans;
        
    }
    else {
        ans.resize(ans.size() - count);
        cout << ans;

    }
    
    return 0;
}

```





### åå…­è¿›åˆ¶è½¬å…«è¿›åˆ¶

æ•°æ®èŒƒå›´ï¼šä¿è¯æ¯ä¸ªåå…­è¿›åˆ¶æ•°ï¼Œä½æ•°ä¸å¤šä½™100000ä½

ç¬¬ä¸€è¡Œè¾“å…¥nè¡¨ç¤ºæœ‰nä¸ªåå…­è¿›åˆ¶æ•°

ç¬¬2-n+1è¡Œè¾“å…¥åå…­è¿›åˆ¶æ•°



//éœ€è¦æ³¨æ„çš„æ˜¯è¿™ä¸ªæ•°å¤ªå¤§ï¼Œæˆ‘ä»¬åªèƒ½é€šè¿‡å­—ç¬¦ä¸²è¯»å–

```c++
#include<bits/stdc++.h>
using namespace std;
string hextobin(string hexstring) {
	string binstring;
	int n=hexstring.size();
	for (int i=0;i<n;i++) {
		switch (hexstring[i]) {
		case '0': binstring += "0000";
			break;
		case '1': binstring += "0001";
			break;
		case '2': binstring += "0010";
			break;
		case '3': binstring += "0011"; 
			break;
		case '4': binstring += "0100";
			break;
		case '5': binstring += "0101";
			break;
		case '6': binstring += "0110";
			break;
		case '7': binstring += "0111";
			break;
		case '8': binstring += "1000";
			break;
		case '9': binstring += "1001";
			break;
		case 'A': binstring += "1010";
			break;
		case 'B': binstring += "1011";
			break;
		case 'C': binstring += "1100";
			break;
		case 'D': binstring += "1101";
			break;
		case 'E': binstring += "1110";
			break;
		case 'F': binstring += "1111";
			break;
		}
	}
	return binstring;
}

string bintooct(string binstring){
	string octstring;
	int n=binstring.size();
	string tmp;
	int tmpt;
	for(int i=0;i<n;i+=3){
		tmp=binstring.substr(i,3);
		tmpt=((tmp[0]-'0')*pow(2,2))+((tmp[1]-'0')*pow(2,1))+(tmp[2]-'0');
		octstring+=tmpt+'0';
	}
	return octstring;
}
int main() {
	int n;
	cin >> n;
	string hexstring,binstring,octstring;
	for (int i = 0; i < n; i++) {
		cin >> hexstring;
		binstring=hextobin(hexstring);
		int addzero=3-(binstring.size()%3);
		binstring.insert(0,addzero,'0');
		octstring=bintooct(binstring);
		cout<<octstring<<endl;
	}

	return 0;

}

```



### åå…­è¿›åˆ¶è½¬åè¿›åˆ¶

é¢˜ç›®æ¡ä»¶æ˜¯ä¸å¤§äºå…«ä½çš„åå…­è¿›åˆ¶æ•°ï¼Œå…«ä½çš„æœ€å¤§å€¼æ˜¯FFFFFFFFï¼Œæ°å¥½æ˜¯64ä½intçš„æœ€å¤§å€¼

```c++
#include<bits/stdc++.h>
using namespace std;
int hextodec(string hexstring){
	string decstring;
	int ans;
	int n=hexstring.size();
	for (int i=0;i<n;i++) {
		switch (hexstring[i]) {
		case '0': ans+=0;
			break;
		case '1': ans+=pow(16,n-i-1);
			break;
		case '2': ans+=2*pow(16,n-i-1);
			break;
		case '3': ans+=3*pow(16,n-i-1); 
			break;
		case '4': ans+=4*pow(16,n-i-1);
			break;
		case '5': ans+=5*pow(16,n-i-1);
			break;
		case '6': ans+=6*pow(16,n-i-1);
			break;
		case '7': ans+=7*pow(16,n-i-1);
			break;
		case '8': ans+=8*pow(16,n-i-1);
			break;
		case '9': ans+=9*pow(16,n-i-1);
			break;
		case 'A': ans+=10*pow(16,n-i-1);
			break;
		case 'B': ans+=11*pow(16,n-i-1);
			break;
		case 'C': ans+=12*pow(16,n-i-1);
			break;
		case 'D': ans+=13*pow(16,n-i-1);
			break;
		case 'E': ans+=14*pow(16,n-i-1);
			break;
		case 'F': ans+=15*pow(16,n-i-1);
			break;
			}
		}
	return ans;	
}


int main() {
	string hexstring;
	int decstring;
	cin >> hexstring;
	decstring=hextodec(hexstring);
	cout<<decstring;

	return 0;

}
```



### åè¿›åˆ¶è½¬16è¿›åˆ¶

é¢˜ç›®è¦æ±‚çš„æ˜¯è¯¥æ•°å­—åœ¨intçš„èŒƒå›´ä¹‹å†…

å·æ‡’åšæ³•ï¼š

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
	int num;
	cin>>num;
	cout<<hex<<num;
	return 0;

}
```



è¾—è½¬ç›¸é™¤

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
	int num;
	cin>>num;
	string hexstring="";
	while(num>0){
		int x=num%16;
		switch(x){
			case 0: hexstring.insert(0,"0");
				break;
			case 1: hexstring.insert(0,"1");
				break;
			case 2: hexstring.insert(0,"2");
				break;
			case 3: hexstring.insert(0,"3");
				break;
			case 4: hexstring.insert(0,"4");
				break;
			case 5: hexstring.insert(0,"5");
				break;
			case 6: hexstring.insert(0,"6");
				break;
			case 7: hexstring.insert(0,"7");
				break;
			case 8: hexstring.insert(0,"8");
				break;
			case 9: hexstring.insert(0,"9");
				break;
			case 10: hexstring.insert(0,"A");
				break;
			case 11: hexstring.insert(0,"B");
				break;
			case 12: hexstring.insert(0,"C");
				break;
			case 13: hexstring.insert(0,"D");
				break;
			case 14: hexstring.insert(0,"E");
				break;
			case 15: hexstring.insert(0,"F");
				break;
		}
		num/=16;  
	}
	cout<<hexstring;
	
	return 0;

}
```

å¦‚æœéœ€è¦æ’åºå­—å…¸åºçš„ï¼Œæœ‰æ—¶å€™å¯ä»¥åˆ©ç”¨æ•°ç»„ï¼Œæ•°ç»„ä¸‹æ ‡è¡¨ç¤ºå­—å…¸åºï¼Œå› ä¸º'a'çš„ASCIIç æ˜¯97ï¼Œzçš„ASCIIç æ˜¯122ï¼Œæ‰€ä»¥éƒ½å‡å»97ï¼Œå¾—åˆ°1~25çš„å€¼

### è“æ¡¥æ—¥æœŸé—®é¢˜ï¼ˆ103ï¼‰

![image-20240227213938918](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240227213938918.png)

```c++
#include<iostream>
using namespace std;
const int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
bool check(int y, int m, int d) {
	//æ£€æŸ¥æ—¥æœŸæ˜¯å¦åˆæ³•
	if (m == 0 || m>12||d==0) return false;
	if (m != 2 && d > days[m]) return false;
	if (m == 2) {
		if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) {
			if (d > 29) return false;
		}
		else {
			if (d > 28) return false;
		}
	}
	return true;

}
int main() {
	int a, b, c;
	scanf("%d/%d/%d", &a, &b, &c);//ç¬¬ä¸€æ­¥æ ¼å¼è¾“å…¥
	for (int i = 19600101; i <= 20591231; i++) {
		int y = i / 10000;//i/10000çš„æ„æ€æ˜¯ä»åé¢æˆªæ–­å››ä½æ•°ï¼Œèˆå»ï¼Œåªç•™å‰é¢çš„
		int m = i % 10000 / 100;//i%10000çš„æ„æ€æ˜¯ä»åé¢æˆªæ–­å››ä½æ•°ï¼Œåªç•™åé¢çš„
		int d = i % 100;//æ±‚ä¸€ä¸ªæ•°çš„åä¸¤ä½
		if (check(y, m, d)) {
			if ((y % 100 == a && m == b && d == c) || (y % 100 == c && m == b && d == a) ||
				(y % 100 == c && m == a && d == b)) {
				printf("%d-%02d-%02d\n", y, m, d);//æ³¨æ„æ ¼å¼æ‰“å°
			}
		}

	}
}
```

å¸¸è§çš„åˆ¤æ–­æ—¥æœŸæ˜¯å¦åˆæ³•å¯ä»¥ç”¨åˆ°çš„ä»£ç 

```c++
const int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
bool check(int y, int m, int d) {
	//æ£€æŸ¥æ—¥æœŸæ˜¯å¦åˆæ³•
	if (m == 0 || m>12||d==0) return false;
	if (m != 2 && d > days[m]) return false;
	if (m == 2) {
		if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) {
			if (d > 29) return false;
		}
		else {
			if (d > 28) return false;
		}
	}
	return true;

}
```



### åŠ›æ‰£åˆ¤æ–­å›æ–‡ä¸²

åˆ¤æ–­ä¸€ä¸ªä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²ï¼šåŒæŒ‡é’ˆ

```c++
bool check(string s){
    for(int i=0;j=s.size()-1;i<j;i++,j--){
        if(s[i]!=s[j]) return false;
    }
    return true;
}
```

### è“æ¡¥åˆ·é¢˜ç»Ÿè®¡2098

nçš„å¤§å°ç»™åˆ°äº†10e18,è¦å¼€long long

```c++
#include <iostream>
using namespace std;
typedef long long ll;
int main()
{
  // è¯·åœ¨æ­¤è¾“å…¥æ‚¨çš„ä»£ç 
  ll a,b,n;
  scanf("%lld%lld%lld",&a,&b,&n);
  ll m=a*5+b*2;
  ll wsum=n/m;
  ll ans=wsum*7;
  n%=m;
  int w=1;
  while(n>0){
    if(w==8){
      w=1;
    }
    if(w<=5){//å¦‚æœä»Šå¤©åœ¨å‘¨ä¸€åˆ°å‘¨äº”
      n-=a;
    }
    else{//å¦‚æœä»Šå¤©åœ¨å‘¨æœ«
      n-=b;
    }
    w++;
    ans++;
  }
  printf("%lld",ans);


  return 0;
}
```



### åŠ›æ‰£äº¤æ¢å­—ç¬¦ä¸²

ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå…¶ä½œç”¨æ˜¯å°†è¾“å…¥çš„å­—ç¬¦ä¸²åè½¬è¿‡æ¥ã€‚è¾“å…¥å­—ç¬¦ä¸²ä»¥å­—ç¬¦æ•°ç»„ s çš„å½¢å¼ç»™å‡ºã€‚

ä¸è¦ç»™å¦å¤–çš„æ•°ç»„åˆ†é…é¢å¤–çš„ç©ºé—´ï¼Œä½ å¿…é¡»åŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„ã€ä½¿ç”¨ O(1) çš„é¢å¤–ç©ºé—´è§£å†³è¿™ä¸€é—®é¢˜ã€‚

**åŒæŒ‡é’ˆ**

```java
    public void reverseString(char[] s) {
        int length = s.length;
        //ä¸¤ä¸ªæŒ‡é’ˆä¸€ä¸ªä»ç¬¬1ä¸ªï¼Œä¸€ä¸ªä»æœ€åä¸€ä¸ªå¼€å§‹ï¼Œ
        //ä¸¤ä¸¤äº¤æ¢
        int left = 0;
        int right = length - 1;
        while (left < right) {
            swap(s, left++, right--);
        }
    }

    private void swap(char[] array, int i, int j) {
        //ç¬¬1ç§äº¤æ¢æ–¹å¼
        char temp = array[i];
        array[i] = array[j];
        array[j] = temp;

        //ç¬¬2ç§äº¤æ¢æ–¹å¼
//        array[i] = (char) (array[i] + array[j]);
//        array[j] = (char) (array[i] - array[j]);
//        array[i] = (char) (array[i] - array[j]);

        //ç¬¬3ç§äº¤æ¢æ–¹å¼
//        array[i] = (char) (array[i] - array[j]);
//        array[j] = (char) (array[i] + array[j]);
//        array[i] = (char) (array[j] - array[i]);

        //ç¬¬4ç§äº¤æ¢æ–¹å¼
//        array[i] ^= array[j];
//        array[j] ^= array[i];
//        array[i] ^= array[j];
    }


```





```c++
#include<iostream>
#include<vector>
using namespace std;
class Solution {
public:
    void reverseString(vector<char>& s) {
        if (s.empty() || s.size() == 0)
        {
            return;
        }
        reverseStringhelper(s, 0, s.size() - 1);
    }
    void reverseStringhelper(vector<char>& s, int left, int right)
    {
        if (left >= right)
        {
            return;
        }
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        reverseStringhelper(s, ++left, --right);
    }
};
```

### åŠ›æ‰£ç¿»è½¬æ•°å­—

core:**åˆ¤æ–­æ•´æ•°æº¢å‡º**

```java
//ä½•å…¶å¹¸è¿èƒ½å¤Ÿå­¦ä¹ åˆ°å¦‚æ­¤ç¾å¦™çš„ç®—æ³•!!!!
class Solution {
    public int reverse(int x) {
        int res = 0;
        while(x!=0) {
            //æ¯æ¬¡å–æœ«å°¾æ•°å­—
            int tmp = x%10;
            //åˆ¤æ–­æ˜¯å¦ å¤§äº æœ€å¤§32ä½æ•´æ•°
            if (res>214748364 || (res==214748364 && tmp>7)) {
                return 0;
            }
            //åˆ¤æ–­æ˜¯å¦ å°äº æœ€å°32ä½æ•´æ•°
            if (res<-214748364 || (res==-214748364 && tmp<-8)) {
                return 0;
            }
            res = res*10 + tmp;
            x /= 10;
        }
        return res;
    }
}
```

### åŠ›æ‰£å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªä¸é‡å¤çš„å­—ç¬¦

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s` ï¼Œæ‰¾åˆ° *å®ƒçš„ç¬¬ä¸€ä¸ªä¸é‡å¤çš„å­—ç¬¦ï¼Œå¹¶è¿”å›å®ƒçš„ç´¢å¼•* ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿”å› `-1` 

```c++
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<int, int> frequency;
        for (char ch: s) {
            ++frequency[ch];
        }
        for (int i = 0; i < s.size(); ++i) {
            if (frequency[s[i]] == 1) {
                return i;
            }
        }
        return -1;
    }
};

```

### è“æ¡¥å­—ç¬¦ä¸²è½¬åŒ–æˆæ•´æ•°

![image-20240302195337802](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240302195337802.png)

1.**å­—ç¬¦ä¸²å»é™¤å‰å¯¼ç©ºæ ¼**

cinè¾“å…¥è‡ªåŠ¨å»é™¤ç©ºæ ¼ï¼ï¼ï¼

**è½¬åŒ–æˆæ•°å­—æ—¶åˆ¤æ–­æº¢å‡º**

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231205163818189.png" alt="image-20231205163818189" style="zoom: 80%;" />



**å®Œæ•´ä»£ç **

```c++
#include<iostream>
#include<string>
using namespace std;

int main() {
    string s;
    cin >> s;

    // åˆ¤æ–­æ˜¯å¦ä¸ºç©ºå­—ç¬¦ä¸²
    if (s.empty()) {
        cout << 0;
        return 0;
    }

    int i = 0;
    bool flag = true; // é»˜è®¤ä¸ºæ­£æ•°
    int res = 0;

    // å¤„ç†è´Ÿå·
    if (s[0] == '-') {
        flag = false;
        i++;
    }

    // å»é™¤å‰å¯¼é›¶
    while (i < s.size() && s[i] == '0') {
        i++;
    }

    // å¤„ç†æ•°å­—éƒ¨åˆ†
    while (i < s.size()) {
        int tmp = s[i] - '0';

        // åˆ¤æ–­æ˜¯å¦ä¼šæº¢å‡º
        if ((res > INT_MAX / 10) || (res == INT_MAX / 10 && tmp > INT_MAX % 10)) {
            cout << (flag ? INT_MAX : INT_MIN);
            return 0;
        }

        // æ›´æ–°ç»“æœ
        res = res * 10 + tmp;
        i++;
    }

    cout << (flag ? res : -res);
    return 0;
}

```

**è‡ªåŠ¨æœºåšæ³•**

```python
INT_MAX = 2 ** 31 - 1
INT_MIN = -2 ** 31

class Automaton:
    def __init__(self):
        self.state = 'start'
        self.sign = 1
        self.ans = 0
        self.table = {
            'start': ['start', 'signed', 'in_number', 'end'],
            'signed': ['end', 'end', 'in_number', 'end'],
            'in_number': ['end', 'end', 'in_number', 'end'],
            'end': ['end', 'end', 'end', 'end'],
        }
        
    def get_col(self, c):
        if c.isspace():
            return 0
        if c == '+' or c == '-':
            return 1
        if c.isdigit():
            return 2
        return 3

    def get(self, c):
        self.state = self.table[self.state][self.get_col(c)]
        if self.state == 'in_number':
            self.ans = self.ans * 10 + int(c)
            self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN)
        elif self.state == 'signed':
            self.sign = 1 if c == '+' else -1

class Solution:
    def myAtoi(self, str: str) -> int:
        automaton = Automaton()
        for c in str:
            automaton.get(c)
        return automaton.sign * automaton.ans


```

### è“æ¡¥ä¸²çš„å¤„ç†

![image-20240208145227753](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240208145227753.png)

**1.è¾“å…¥ï¼Œcinå’Œscanfä¸€æ ·ï¼Œä¼šæˆªæ–­ç©ºæ ¼**

**2.è¾“å‡º,è®°å¾—coutè¾“å‡ºå˜é‡æ—¶ä¼šè¾“å‡ºå­—ç¬¦ï¼Œä½†æ˜¯å¦‚æœåªæ˜¯ä¸€ä¸ªè®¡ç®—ç»“æœï¼Œå¦‚cout<<s-32æ­¤æ—¶ä¼šè¾“å‡ºæ•°å­—,æ‰€ä»¥åœ¨æœ¬é¢˜è§£ä¸­è¿›è¡Œäº†ç±»å‹è½¬æ¢**

```c++
#include<iostream>
#include<string>
using namespace std;
void change(char& ch) {
	ch = ch - 32;//æŠŠå°å†™å­—æ¯å¤§å†™
}
int main() {
	string ss;
	getline(cin, ss);//getlineä¹Ÿæ²¡æœ‰æˆªæ–­çš„ç‰¹æ€§ï¼Œå³æ¥æ”¶ç©ºæ ¼
	int len = ss.length();
	if (isalpha(ss[0])) {
		change(ss[0]);
	}
	for (int i = 0, j = 1; i < len; i++, j++) {
		if (ss[i] == ' '&&j<len) {
			if (ss[j] == ' ') continue;
			else {
				//å¦‚æœss[i]æ˜¯ç©ºæ ¼è€Œss[j]ä¸æ˜¯ç©ºæ ¼ï¼Œè¯´æ˜æ˜¯å•è¯å¼€å¤´
				cout << ss[i];
				change(ss[j]);
			}
		}
		else if ((isdigit(ss[i]) && isalpha(ss[j])) || (isalpha(ss[i]) && isdigit(ss[j]))) {
			cout << ss[i] << '_';
		}

		else {
			cout << ss[i];
		}
		
	}
	return 0;
}
```

### è“æ¡¥å¯†æ–‡æœç´¢

![image-20240208180432011](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240208180432011.png)



```c++
#include<iostream>
#include<string>
#include<algorithm>
#include<map>
using namespace std;
map<string, int>mp;
string str, s;
int n;
int main() {
	cin >> str >> n;
	while (n--) {
		cin >> s;
		sort(s.begin(), s.end());
		mp[s]++;
	}
	int ans=0;
	cout << endl;
	for (int i = 0; i <= str.size() - 8; i++) {
		string t = str.substr(i, 8);
		sort(t.begin(), t.end());
		ans += mp[t];
	}

	return 0;
}
```



### å“ˆå¸Œè¡¨å®ä¾‹

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// å®šä¹‰å“ˆå¸Œè¡¨çš„èŠ‚ç‚¹ç»“æ„
typedef struct Node {
    char key;
    int count;
    struct Node* next;
} Node;

// å®šä¹‰å“ˆå¸Œè¡¨ç»“æ„
typedef struct {
    Node** array;
    int size;
} HashMap;

// åˆå§‹åŒ–å“ˆå¸Œè¡¨
HashMap* initHashMap(int size) {
    //é—®é¢˜ä¸€
    //å¤´èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå“ˆå¸Œè¡¨æŒ‡é’ˆï¼Œåˆå§‹åŒ–ä¸ç”¨å¼€è¾Ÿå¤šä½™ç©ºé—´ï¼ï¼ï¼
    HashMap* hashMap = (HashMap*)malloc(sizeof(HashMap));
    if (hashMap == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }

    hashMap->size = size;
    
    //é—®é¢˜äºŒï¼Œä¸€èˆ¬éƒ½ç”¨ä¸€ä¸ªäºŒç»´æŒ‡é’ˆæ¥å­˜å‚¨å“ˆå¸Œæ¡¶ï¼Œç»è¿‡æˆ‘æµªè´¹çš„æ—¶é—´æ¥çœ‹ï¼Œè¿™æ ·æ„å»ºæ¯”è¾ƒç®€å•ï¼ï¼ï¼
    //æ³¨æ„äºŒç»´æ•°ç»„çš„æ„å»ºå“¦ï¼Œè¿™é‡Œä½¿ç”¨äº†callocå‡½æ•°ä¸€æ¬¡åˆ°ä½äº†ï¼Œå¦åˆ™è¿˜è¦å¤šä¸€ä¸ªforå¾ªç¯æ¥å®ç°äºŒç»´æ•°ç»„çš„åŠ¨æ€åˆ†é…å†…å­˜
    hashMap->array = (Node**)calloc(size, sizeof(Node*));
    if (hashMap->array == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }

    return hashMap;
}

// å“ˆå¸Œå‡½æ•°ï¼Œç®€å•åœ°è¿”å›å­—ç¬¦çš„ASCIIç å¯¹å“ˆå¸Œè¡¨å¤§å°å–ä½™
int hashFunction(char key, int size) {
    return (int)key % size;
}

// åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾èŠ‚ç‚¹
Node* findNode(HashMap* hashMap, char key) {
    //é¦–å…ˆæ‰¾åˆ°å“ˆå¸Œæ¡¶ä¸­å¯¹åº”çš„çš„ä½ç½®
    int index = hashFunction(key, hashMap->size);
    Node* current = hashMap->array[index];

    //åœ¨è¯¥ä½ç½®ä¸­æ‰¾æ˜¯å¦æœ‰ç¬¦åˆæ¡ä»¶çš„
    while (current != NULL) {
        if (current->key == key) {
            return current;
        }
        current = current->next;
    }

    return NULL;
}

// æ’å…¥èŠ‚ç‚¹æˆ–æ›´æ–°è®¡æ•°
void insertOrUpdate(HashMap* hashMap, char key) {
    //è€è§„çŸ©ï¼Œæ‰¾åˆ°å“ˆå¸Œæ¡¶ä¸­å¯¹åº”çš„ä½ç½®
    int index = hashFunction(key, hashMap->size);
    Node* current = hashMap->array[index];
    //æŸ¥æ‰¾ï¼Œçœ‹æ˜¯å¦æ‰¾åˆ°ï¼Œå¦‚æœåŸç»“æ„ä¸­å·²ç»æœ‰äº†ï¼Œå°±è®¡æ•°åŠ ä¸€
    Node* node = findNode(hashMap, key);

    if (node != NULL) {
        // èŠ‚ç‚¹å·²å­˜åœ¨ï¼Œæ›´æ–°è®¡æ•°
        node->count++;
    } 
    //å¦‚æœæ²¡æ‰¾åˆ°ï¼Œéœ€è¦å¤´æ’æ³•åŠ å…¥å“ˆå¸Œæ¡¶å¯¹åº”çš„ä½ç½®ä¸­å»å“¦
    else {
        // èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œæ’å…¥æ–°èŠ‚ç‚¹
        Node* newNode = (Node*)malloc(sizeof(Node));
        if (newNode == NULL) {
            perror("Memory allocation failed");
            exit(EXIT_FAILURE);
        }

        newNode->key = key;
        newNode->count = 1;
        
        //å¤´æ’æ³•
        newNode->next = current;
        hashMap->array[index] = newNode;
    }
}

// ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°
void countCharacters(HashMap* hashMap, const char* str) {
    while (*str != '\0') {
        insertOrUpdate(hashMap, *str);
        str++;
    }
}

// æ‰“å°å“ˆå¸Œè¡¨å†…å®¹
void printHashMap(HashMap* hashMap) {
    printf("Character Counts:\n");
    for (int i = 0; i < hashMap->size; i++) {
        Node* current = hashMap->array[i];
        while (current != NULL) {
            printf("'%c': %d\n", current->key, current->count);
            current = current->next;
        }
    }
}

// é‡Šæ”¾å“ˆå¸Œè¡¨çš„å†…å­˜
void freeHashMap(HashMap* hashMap) {
    for (int i = 0; i < hashMap->size; i++) {
        Node* current = hashMap->array[i];
        while (current != NULL) {
            Node* next = current->next;
            free(current);
            current = next;
        }
    }
    free(hashMap->array);
    free(hashMap);
}

int main() {
    const char* inputString = "programming";
    int hashMapSize = 10;

    HashMap* hashMap = initHashMap(hashMapSize);

    countCharacters(hashMap, inputString);

    printHashMap(hashMap);

    freeHashMap(hashMap);

    return 0;
}

```



### åŠ›æ‰£67äºŒè¿›åˆ¶æ±‚å’Œ

```c++
class Solution {
public:
    string addBinary(string a, string b) {
        int la=a.size();
        int lb=b.size();
        while(la<lb){
            a='0'+a;
            ++la;    
        }
        while(lb<la){
            b='0'+b;
            ++lb;         
        }
        
        int j=b.size()-1;
        for(j;j>0;j--){
            a[j]=a[j]-'0'+b[j];//æŠŠå­—ç¬¦ä¸²è½¬åŒ–æˆæ•°å­—ç›¸åŠ å†è½¬åŒ–å›æ¥
            if(a[j]>='2'){
                a[j]=(a[j]-'0')%2+'0';
                a[j-1]=a[j-1]+1;//æ³¨æ„è¿™é‡Œï¼å­—ç¬¦2å’Œå­—ç¬¦1çš„ASCIIç åªç›¸å·®1

            }            
        }
        
        //æ¶‰åŠåˆ°è¿›ä½é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦å•ç‹¬æŠŠç¬¬é›¶ä½æ‹¿å‡ºæ¥ç®—
        a[0]=a[0]-'0'+b[0];
        if(a[0]>='2'){
                a[0]=(a[0]-'0')%2+'0';
                a='1'+a;

            }
            return a;
    }
};
```





### å»é™¤ä¸¤ç«¯ç©ºæ ¼

```c++
int main() {
    string s = "     hello    ";
    int i = 0;
    for (i; s[i] == ' '; i++);
    int j = 0;
    for (j = s.size(); s[j] == ' '; --j);
    int n = j - i + 1;
    s = s.substr(i, n);
    cout << s;
}

```

### å»é™¤é€‚å½“ç©ºæ ¼ï¼Œä½¿å­—ç¬¦ä¸²è¡¨ç¤ºä¸€ä¸ªæ­£ç¡®çš„å¥å­

```c++
#include <iostream>
#include <sstream>
using namespace std;
void trim(string &s) {
    int len = s.size();
    int i = 0, j = 0;
    for (i; s[i] == ' '; i++);
    for (j = len - 1; s[j] == ' '; j--);
    s = s.substr(i, j - i + 1);
}
int main() {
    std::string s = "    ä½ å¥½       ä¸–ç•Œ   å·´æ‹‰å·´æ‹‰     ";
    trim(s);
    int i = 0;
    while (i < s.size()) {
        if (s[i] == ' ') {
            int j = i;
            while (s[j] == ' ') j++;
            s.replace(i, j-i, " ");
            i+=1;
            continue;
        }
        i++;      
    }
    cout << s;   
    return 0;
}



```



### åŠ›æ‰£500é”®ç›˜è¡Œ

å˜åŒ–çš„å“ˆå¸Œè¡¨ï¼Œé¢˜è§£è®¾ç½®äº†æ¯ä¸ªå­—æ¯æ‰€åœ¨çš„è¡Œå·ï¼Œä½¿å¾—æŸ¥è¯¢å˜å¾—å¿«æ·

éå†å•¦

```c++
class Solution {
public:
    vector<string> findWords(vector<string>& words) {
        vector<string> ans;
        string rowIdx = "12210111011122000010020202";
        for (auto & word : words) {
            bool isValid = true;
            char idx = rowIdx[tolower(word[0]) - 'a'];
            for (int i = 1; i < word.size(); ++i) {
                if(rowIdx[tolower(word[i]) - 'a'] != idx) {
                    isValid = false;
                    break;
                }
            }
            if (isValid) {
                ans.emplace_back(word);
            }
        }
        return ans;
    }
};

```

### å»é™¤å­—ç¬¦ä¸²æŒ‡å®šå­—ç¬¦

æ¯”å¦‚æˆ‘æƒ³å»é™¤å­—ç¬¦ä¸²é‡Œé¢çš„ç©ºæ ¼

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

void trim(string& s) {
    int len = s.size();
    int i = 0, j = 0;
    for (i; s[i] == ' '; i++);
    for (j = len - 1; s[j] == ' '; j--);
    s = s.substr(i, j - i + 1);
}
int main() {
    std::string s = "    ä½ å¥½       ä¸–ç•Œ   å·´æ‹‰å·´æ‹‰     ";
    trim(s);
    int i = 0;
    int k = 0;
    int n = s.size();
    while (i < n) {
        if (s[i] == ' ') k++;
        else s[i - k] = s[i];
        i++;
    }
    s.resize(n - k);
    cout << s;
    return 0;
}
```



# é¡ºåºè¡¨

å“‘èŠ‚ç‚¹dummyï¼Œå¦‚æœé¢˜ç›®ä¸ç»™å“¨å…µèŠ‚ç‚¹çš„è¯ï¼Œå¯ä»¥è‡ªå·±å¼€è¾Ÿä¸€ä¸ªï¼Œè®¡ç®—æ¯”è¾ƒæ–¹ä¾¿

### åŠ›æ‰£237åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹

```c
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val=node->next->val;
        node->next=node->next->next;
      
        
    }
};
```



### åŠ›æ‰£åˆå¹¶ä¸¤ä¸ªé“¾è¡¨



```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
//æˆ‘æ˜¯å°çŒ«æ€ªï¼Œé‡åˆ°å¥½çš„é¢˜è§£åªä¼šå¤§å–Šï¼šå–µï¼ï¼ï¼ï¼ï¼ï¼
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* pstr1 = list1;
    struct ListNode* pstr2 = list2;
    struct ListNode* head = NULL; // ç”¨äºä¿å­˜åˆå¹¶åçš„é“¾è¡¨çš„å¤´æŒ‡é’ˆ
    struct ListNode* tail = NULL; // ç”¨äºä¿å­˜åˆå¹¶åçš„é“¾è¡¨çš„å°¾æŒ‡é’ˆ

    while (pstr1 && pstr2) {
        // æ¯”è¾ƒä¸¤ä¸ªé“¾è¡¨çš„å½“å‰èŠ‚ç‚¹å€¼ï¼Œå°†è¾ƒå°å€¼çš„èŠ‚ç‚¹æ’å…¥åˆå¹¶åçš„é“¾è¡¨
        if (pstr1->val <= pstr2->val) {
            if (tail == NULL) {
                head = tail = pstr1;
            } else {
                tail->next = pstr1;
                tail = pstr1;
            }
            pstr1 = pstr1->next;
        } else {
            if (tail == NULL) {
                head = tail = pstr2;
            } else {
                tail->next = pstr2;
                tail = pstr2;
            }
            pstr2 = pstr2->next;
        }
    }

    // å¤„ç†å‰©ä½™çš„èŠ‚ç‚¹
    if (pstr1 != NULL) {
        if (tail == NULL) {
            head = pstr1;
        } else {
            tail->next = pstr1;
        }
    } else if (pstr2 != NULL) {
        if (tail == NULL) {
            head = pstr2;
        } else {
            tail->next = pstr2;
        }
    }

    return head;
}

```



### å¿«æ…¢æŒ‡é’ˆ

1.å¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆåˆ°è¾¾é“¾è¡¨å°¾éƒ¨æ—¶ï¼Œå› ä¸ºæ…¢æŒ‡é’ˆèµ°çš„æ­¥æ•°ä¸€å®šæ˜¯å¿«æŒ‡é’ˆçš„ä¸€åŠï¼Œæ‰€ä»¥æ­¤æ—¶æ…¢æŒ‡é’ˆåœ¨é“¾è¡¨ä¸­éƒ¨

2.å¿«æŒ‡é’ˆå…ˆèµ°k-1æ­¥ï¼Œç„¶åæ…¢æŒ‡é’ˆå’Œå¿«æŒ‡é’ˆå†æ¯æ¬¡éƒ½èµ°ä¸€æ­¥ï¼Œå½“å¿«æŒ‡é’ˆåˆ°é“¾è¡¨å°¾éƒ¨æ—¶ï¼Œæ…¢æŒ‡é’ˆæ­¤æ—¶å°±åœ¨é“¾è¡¨çš„å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹

3.å¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå¦‚æœå¿«æ…¢æŒ‡é’ˆèƒ½ç›¸é‡ï¼Œè¯´æ˜é“¾è¡¨æœ‰ç¯ï¼Œæ­¤æ—¶è®©å¿«æŒ‡é’ˆé‡æ–°å›åˆ°å¤´æŒ‡é’ˆçš„ä½ç½®ç„¶åè®©å¿«æ…¢æŒ‡é’ˆæ¯æ¬¡éƒ½èµ°ä¸€æ­¥ï¼Œä¸‹æ¬¡ç›¸é‡çš„èŠ‚ç‚¹å°±æ˜¯å…¥ç¯èŠ‚ç‚¹

![image-20240302230930445](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240302230930445.png)

ç¬¬ä¸€æ¬¡ç›¸é‡ä¹‹åï¼Œå¦‚æœfastå›åˆ°å¤´èŠ‚ç‚¹ï¼Œåˆ™å®ƒèµ°äº†læ­¥æ—¶ï¼Œæ…¢æŒ‡é’ˆèµ°äº†ï¼ˆn-1ï¼‰+c-xæ­¥ï¼Œæ­£å¥½åœ¨å…¥ç¯èŠ‚ç‚¹



4.**fastèµ°3æ­¥ï¼Œ4æ­¥ï¼Œ5æ­¥æˆ–è€…èµ°næ­¥å‘¢ï¼Œè¯·è¯æ˜**

ç»“è®ºï¼šfastèµ°næ­¥nå¦‚æœå¤§äº2ï¼Œä¸ä¸€å®šä¼šç›¸é‡ã€‚

å¦‚æœfastä¸€æ¬¡èµ°ä¸‰æ­¥ã€‚ï¼Œslowè¿›ç¯ä»¥åï¼Œä»–ä»¬çš„è·ç¦»æ˜¯nã€‚

å‡è®¾næ˜¯å¶æ•°ï¼Œåˆ™å®ƒä»¬çš„è·ç¦»å˜åŒ–ï¼šn   n-2   n-4   n-6...2 0,å¦‚æœnæ˜¯å¥‡æ•°ï¼Œå®ƒä»¬çš„è·ç¦»å˜åŒ–ï¼šn   n-2   n-4   n-6...1 -1;æ‰€ä»¥å¦‚æœnæ˜¯å¶æ•°èƒ½è¿½ä¸Šï¼Œnæ˜¯å¥‡æ•°è¿½ä¸ä¸Š

å¦‚æœfastä¸€æ¬¡èµ°4æ­¥ï¼Œåˆ™å®ƒä»¬çš„è·ç¦»å˜åŒ–ä¸ºn   n-3   n-6...åŒä»¥ä¸Šåˆ†æ

### åŠ›æ‰£92ç¿»è½¬é“¾è¡¨2

ç©¿é’ˆå¼•çº¿ï¼Œå…ˆç¿»è½¬ç›®æ ‡é“¾è¡¨ï¼Œåœ¨æŠŠé“¾è¡¨è¿èµ·æ¥

```c++
class Solution {
private:
    void reverseLinkedList(ListNode *head) {
        // ä¹Ÿå¯ä»¥ä½¿ç”¨é€’å½’åè½¬ä¸€ä¸ªé“¾è¡¨
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while (cur != nullptr) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
    }

public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        // å› ä¸ºå¤´èŠ‚ç‚¹æœ‰å¯èƒ½å‘ç”Ÿå˜åŒ–ï¼Œä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹å¯ä»¥é¿å…å¤æ‚çš„åˆ†ç±»è®¨è®º
        ListNode *dummyNode = new ListNode(-1);
        dummyNode->next = head;

        ListNode *pre = dummyNode;
        // ç¬¬ 1 æ­¥ï¼šä»è™šæ‹Ÿå¤´èŠ‚ç‚¹èµ° left - 1 æ­¥ï¼Œæ¥åˆ° left èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
        // å»ºè®®å†™åœ¨ for å¾ªç¯é‡Œï¼Œè¯­ä¹‰æ¸…æ™°
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }

        // ç¬¬ 2 æ­¥ï¼šä» pre å†èµ° right - left + 1 æ­¥ï¼Œæ¥åˆ° right èŠ‚ç‚¹
        ListNode *rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode->next;
        }

        // ç¬¬ 3 æ­¥ï¼šåˆ‡æ–­å‡ºä¸€ä¸ªå­é“¾è¡¨ï¼ˆæˆªå–é“¾è¡¨ï¼‰
        ListNode *leftNode = pre->next;
        ListNode *curr = rightNode->next;

        // æ³¨æ„ï¼šåˆ‡æ–­é“¾æ¥
        pre->next = nullptr;
        rightNode->next = nullptr;

        // ç¬¬ 4 æ­¥ï¼šåŒç¬¬ 206 é¢˜ï¼Œåè½¬é“¾è¡¨çš„å­åŒºé—´
        reverseLinkedList(leftNode);

        // ç¬¬ 5 æ­¥ï¼šæ¥å›åˆ°åŸæ¥çš„é“¾è¡¨ä¸­
        pre->next = rightNode;
        leftNode->next = curr;
        return dummyNode->next;
    }
};


```

### åŠ›æ‰£86åˆ†éš”é“¾è¡¨

```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smlDummy = new ListNode(0), *bigDummy = new ListNode(0);
        ListNode *sml = smlDummy, *big = bigDummy;
        while (head != nullptr) {
            if (head->val < x) {
                sml->next = head;
                sml = sml->next;
            } else {
                big->next = head;
                big = big->next;
            }
            head = head->next;
        }
        sml->next = bigDummy->next;
        big->next = nullptr;
        return smlDummy->next;
    }
};

```

### åŠ›æ‰£143é‡æ’é“¾è¡¨

```c++
class Solution {
public:
    void reorderList(ListNode* head) {
        if (head == nullptr) {
            return;
        }
        ListNode* mid = middleNode(head);
        ListNode* l1 = head;
        ListNode* l2 = mid->next;
        mid->next = nullptr;
        l2 = reverseList(l2);
        mergeList(l1, l2);
    }

    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next != nullptr && fast->next->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) {
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    void mergeList(ListNode* l1, ListNode* l2) {
        ListNode* l1_tmp;
        ListNode* l2_tmp;
        while (l1 != nullptr && l2 != nullptr) {
            l1_tmp = l1->next;
            l2_tmp = l2->next;

            l1->next = l2;
            l1 = l1_tmp;

            l2->next = l1;
            l2 = l2_tmp;
        }
    }
};

```

### åŠ›æ‰£82åˆ é™¤é‡å¤å…ƒç´ 

### åŠ›æ‰£155æœ€å°æ ˆ

### åŠ›æ‰£1249ç§»é™¤æ— æ•ˆçš„æ‹¬å·

æ€è·¯ï¼šå¦‚æœæ˜¯å·¦æ‹¬å·ï¼Œé‚£ä¹ˆå°±å…¥æ ˆï¼Œå¦‚æœæ˜¯å³æ‹¬å·ï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼Œæ ˆä¸ºç©ºï¼Œè¯´æ˜ä¹‹å‰çš„æ‹¬å·å®Œå…¨åŒ¹é…ï¼Œåˆ é™¤å³å¯ï¼Œå¦‚æœæ ˆä¸ä¸ºç©ºï¼Œè¯´æ˜æ ˆé¡¶çš„å·¦æ‹¬å·å’Œè¯¥å³æ‹¬å·åŒ¹é…ï¼Œå‡ºæ ˆå·¦æ‹¬å·

```c++
class Solution {
public:
    string minRemoveToMakeValid(string s) {
        stack<int> braket;
        int sLen = s.size();
        for(int i =0; i<sLen ; ++i){
            if(s[i] == '(' || s[i] == ')'){
                if(s[i] == '(') braket.push(i);
                else if(braket.empty()) {
                    s.erase(i,1);
                    --sLen;//è¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰æ„æ€çš„å†™æ³•
                    //ä¸€èˆ¬æ¥è¯´å› ä¸ºåˆ é™¤å­—ç¬¦ä¸²å…ƒç´ ä¹‹åï¼Œå­—ç¬¦ä¸²å¤§å°ä¼šæ”¹å˜ï¼Œæ‰€ä»¥forå¾ªç¯çš„æ¡ä»¶åº”è¯¥æ˜¯
                    //i<s.size()
                    //ä½†æ˜¯è¿™ä¸ªæ—¶é—´å¤æ‚åº¦æ¯”è¾ƒé«˜
                    //æ‰€ä»¥ä½¿ç”¨è¿™ä¸ªå˜é‡
                    --i;
                }
                else braket.pop();
            }
        }
        while(!braket.empty()){
            int i = braket.top();
            s.erase(i,1);
            braket.pop();
        }
        return s;
    }
};
```

### åŠ›æ‰£227åŸºæœ¬è¿ç®—å™¨

ä¸å¤šè¯´ï¼Œå®¡é¢˜ï¼Œé¢˜ç›®å·²ç»åŠ ç²—æ ‡é»‘äº†æ¡ä»¶ï¼Œæ²¡æœ‰è´Ÿæ•°ï¼Œæ²¡æœ‰æ‹¬å·ï¼Œç®€åŒ–æ¿çš„æ±‚åç¼€è¡¨è¾¾å¼å†æ±‚å€¼

æ³¨æ„æ ¹æ®åç¼€è¡¨è¾¾å¼æ±‚å€¼çš„æ—¶å€™ï¼Œ

int a=pop();

int b=pop();

ç»“æœéƒ½æ˜¯b-aã€‚è¿˜æœ‰é™¤é›¶é”™è¯¯çš„è§„é¿

### åŠ›æ‰£1441

æ ˆçš„ç‰¹ç‚¹ï¼Œå…ˆè¿›çš„å…ƒç´ ä¸€å®šå…ˆå‡ºï¼Œæ‰€ä»¥å¯¹äºä¸¥æ ¼é€’å¢åºåˆ—ï¼Œæƒ³è¦æ„å»º135è¿™æ ·çš„æ•°ç»„ï¼Œå¿…é¡»è¦è¿›æ ˆ2ï¼Œå†å‡ºæ ˆ2ï¼Œè¿›æ ˆ4ï¼Œå†å‡ºæ ˆ4è¿™æ ·

### è¿”å›å…ƒç´ ç¬¬Kå¤§å…ƒç´ 

```c++
#include<bits/stdc++.h>
int main(){
    priority_queue<int>a;
    vector<int>b;
    for(int num:b){
        a.push(num);
        if(a.size()>k) a.pop();
    }
    return a.top();
}
```



# æ•°å­¦/è®¾è®¡

### æœ€å°å…¬å€æ•°

æ•°å­¦ä¸Šï¼šæ±‚A  Bçš„æœ€å°å…¬å€æ•°=A*B/GCD(æœ€å¤§å…¬çº¦æ•°)

### æœ€å¤§å…¬çº¦æ•°

è¾—è½¬ç›¸é™¤ç®—æ³•

è¾—è½¬ç›¸é™¤æ³•ä¸€èˆ¬æŒ‡æ¬§å‡ é‡Œå¾—ç®—æ³•ã€‚æ˜¯æŒ‡ç”¨äºè®¡ç®—ä¸¤ä¸ªéè´Ÿæ•´æ•°aï¼Œbçš„æœ€å¤§å…¬çº¦æ•°ã€‚é‚£ä¹ˆè¾—è½¬ç›¸é™¤æ³•çš„åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ

1ã€ åŸç†ï¼šè®¾ä¸¤æ•°ä¸ºaã€b(ab)ï¼Œç”¨gcd(aï¼Œb)è¡¨ç¤ºaï¼Œbçš„æœ€å¤§å…¬çº¦æ•°ï¼Œr=a(mod b)ä¸ºaé™¤ä»¥bçš„ä½™æ•°ï¼Œkä¸ºaé™¤ä»¥bçš„å•†ï¼Œå³aÃ·b=kã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚rã€‚è¾—è½¬ç›¸é™¤æ³•å³æ˜¯è¦è¯æ˜gcd(aï¼Œb)=gcd(bï¼Œr)ã€‚

2ã€ ç¬¬ä¸€æ­¥ï¼šä»¤c=gcd(aï¼Œb)ï¼Œåˆ™è®¾a=mcï¼Œb=ncã€‚

3ã€ ç¬¬äºŒæ­¥ï¼šæ ¹æ®å‰æå¯çŸ¥r=a-kb=mc-knc=(m-kn)cã€‚

4ã€ ç¬¬ä¸‰æ­¥ï¼šæ ¹æ®ç¬¬äºŒæ­¥ç»“æœå¯çŸ¥cä¹Ÿæ˜¯rçš„å› æ•°ã€‚

5ã€ ç¬¬å››æ­¥ï¼šå¯ä»¥æ–­å®šm-knä¸näº’è´¨(å‡è®¾m-kn=xdï¼Œn=yd(d1)ï¼Œåˆ™m=kn+xd=kyd+xd=(ky+x)dï¼Œåˆ™a=mc=(ky+x)cdï¼Œb=nc=ycdï¼Œåˆ™aä¸bçš„ä¸€ä¸ªå…¬çº¦æ•°cdcï¼Œæ•…céaä¸bçš„æœ€å¤§å…¬çº¦æ•°ï¼Œä¸å‰é¢ç»“è®ºçŸ›ç›¾)ï¼Œå› æ­¤cä¹Ÿæ˜¯bä¸rçš„æœ€å¤§å…¬çº¦æ•°ã€‚

6ã€ ä»è€Œå¯çŸ¥gcd(bï¼Œr)=cï¼Œç»§è€Œgcd(aï¼Œb)=gcd(bï¼Œr)ã€‚

7ã€ è¯æ¯•ã€‚ä»¥ä¸Šæ­¥éª¤çš„æ“ä½œæ˜¯å»ºç«‹åœ¨åˆšå¼€å§‹æ—¶râ‰ 0çš„åŸºç¡€ä¹‹ä¸Šçš„ã€‚å³mä¸näº¦äº’è´¨ã€‚

```c++
//è¾—è½¬ç›¸é™¤æ³•
int main() {
	int a;
	int b;    
	printf("è¯·è¾“å…¥ä¸¤ä¸ªæ­£æ•´æ•°ï¼š");
	scanf("%d %d", &a, &b);
	int k = 0;
	while (k = a % b) {
		a = b;
		b = k;
	}
	printf("æœ€å¤§å…¬çº¦æ•°ä¸º:%d\n", b);
	return 0;
}
```



### è´¨æ•°ç­›

è´¨æ•°ç­›æ˜¯ä¸€ç§ç”¨äº**æ‰¾å‡ºä¸€å®šèŒƒå›´å†…æ‰€æœ‰è´¨æ•°çš„ç®—æ³•**ã€‚å…¶ä¸­æœ€è‘—åçš„æ˜¯åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼æ–¯ç­›æ³•ï¼ˆSieve of Eratosthenesï¼‰ã€‚è¿™ä¸ªç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯ä»å°åˆ°å¤§ä¾æ¬¡æ ‡è®°å¹¶åˆ é™¤æ¯ä¸ªæ•°çš„å€æ•°ï¼Œæœ€ç»ˆå‰©ä¸‹çš„æœªè¢«æ ‡è®°çš„æ•°å°±æ˜¯è´¨æ•°ã€‚

äºŒåˆ·ï¼Œè®°å¾—åœ¨åˆ†é…ç©ºé—´æ—¶å¤šåˆ†é…ä¸€ä¸ª

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	//è´¨æ•°ç­›
	vector<int>arr(101,1);
	int n;
	cin>>n;
	arr[2]=true;
	for(int i=2;i*i<=n;i++){
		if(arr[i]==1){
			for(int j=i*i;j<=n;j+=i){
				arr[j]=0;
			}
		}
	}
	
	for(int i=2;i<=n;i++){
		if(arr[i]) cout<<i<<' ';
	}
    return 0;
}

```



### æŠŠæ•°å­—è½¬åŒ–æˆå­—ç¬¦ä¸²

```c++
#include <iostream>
#include <string>

std::string intToString(int number) {
    // å¤„ç†ç‰¹æ®Šæƒ…å†µï¼Œå¦‚æœæ•°å­—æ˜¯0ï¼Œç›´æ¥è¿”å›å­—ç¬¦ä¸²"0"
    if (number == 0) {
        return "0";
    }

    std::string result;  // ç”¨äºå­˜å‚¨æœ€ç»ˆçš„å­—ç¬¦ä¸²ç»“æœ

    // å¤„ç†è´Ÿæ•°æƒ…å†µ
    if (number < 0) {
        result.push_back('-');
        number = -number;  // å°†è´Ÿæ•°è½¬æ¢ä¸ºæ­£æ•°è¿›è¡Œå¤„ç†
    }

    // é€ä½æå–æ•°å­—å¹¶è½¬æ¢ä¸ºå­—ç¬¦ï¼Œç„¶åæ‹¼æ¥åˆ°ç»“æœå­—ç¬¦ä¸²ä¸­
    while (number > 0) {
        char digit = '0' + (number % 10);  // æå–æœ€åä¸€ä½æ•°å­—å¹¶è½¬æ¢ä¸ºå­—ç¬¦
        result.insert(result.begin(), digit);  // åœ¨å­—ç¬¦ä¸²çš„å¼€å¤´æ’å…¥å­—ç¬¦
        number /= 10;  // å»æ‰å·²ç»å¤„ç†çš„æœ€åä¸€ä½æ•°å­—
    }

    return result;
}

int main() {
    int number = -12345;
    std::string str_number = intToString(number);

    std::cout << "Number as string: " << str_number << std::endl;

    return 0;
}

```

### åŠ›æ‰£ç½—é©¬æ•°å­—è½¬æ¢

é¢˜å¹²è¢«ä½ åƒæ‰äº†ï¼Œå•Šå•Šå•Šå•Šå•Šï¼Œé•¿ç‚¹å¿ƒå§å•Šå•Šå•Šå•Šå•Š

```c++
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int>a;
        a['I'] = 1;
        a['V'] = 5;
        a['X'] = 10;
        a['L'] = 50;
        a['C'] = 100;
        a['D'] = 500;
        a['M'] = 1000;
        int i = 0;
        int num = 0;
        int len = s.length() - 1;
        for (i = 0; i < len; i++) {
            char temp1 = s[i];
            char temp2 = s[i + 1];   
            int num1 = a[temp1];
            int num2 = a[temp2];
            if (num1 >= num2) {
                num += num1;
            }
            else {
                num -= num1;
            }
        }
        num +=a[s[i]];
        return num;


    }
};
```

### æ´—ç‰Œç®—æ³•

[å¡ç‰Œå¤§å¸ˆï¼šç©è½¬â€œæ´—ç‰Œç®—æ³•â€ï¼Œå¹¸è¿å¥³ç¥åœ¨å¾®ç¬‘ (*^_^*) - æ˜é‡‘ (juejin.cn)](https://juejin.cn/post/6984925268754317320)

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <ctime> // ç”¨äºè·å–å½“å‰æ—¶é—´æˆ³

class Solution {
private:
    std::vector<int> original_nums;
    std::vector<int> current_nums;

public:
    Solution(const std::vector<int>& nums) {
        original_nums = nums;
        current_nums = nums;
        // ä½¿ç”¨å½“å‰æ—¶é—´æˆ³ä½œä¸ºç§å­ï¼Œä»¥å¢åŠ éšæœºæ€§
        srand(static_cast<unsigned>(time(nullptr)));
    }

    std::vector<int> reset() {
        current_nums = original_nums;
        return original_nums;
    }

    std::vector<int> shuffle() {
        int len = current_nums.size();

        while (len > 1) {
            int randIndex = rand() % len;
            --len;

            // äº¤æ¢å…ƒç´ 
            std::swap(current_nums[len], current_nums[randIndex]);
        }

        return current_nums;
    }
};

int main() {
    // ç¤ºä¾‹ç”¨æ³•
    std::vector<int> nums = {1, 2, 3, 4, 5};
    Solution obj(nums);

    std::cout << "Initial Array: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::vector<int> shuffled = obj.shuffle();
    std::cout << "Shuffled Array: ";
    for (int num : shuffled) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::vector<int> resetted = obj.reset();
    std::cout << "Resetted Array: ";
    for (int num : resetted) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

`static_cast<unsigned>` æ˜¯ C++ ä¸­çš„é™æ€ç±»å‹è½¬æ¢ï¼ˆstatic castï¼‰ã€‚åœ¨è¿™ä¸ªä¸Šä¸‹æ–‡ä¸­ï¼Œ`unsigned` æ˜¯ä¸€ç§æ•´æ•°ç±»å‹ï¼Œè€Œ `static_cast<unsigned>` ç”¨äºå°†æŸä¸ªå€¼è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°ç±»å‹ã€‚

å…·ä½“æ¥è¯´ï¼Œ`static_cast<unsigned>` å°†å…¶åçš„è¡¨è¾¾å¼è½¬æ¢ä¸º `unsigned` ç±»å‹ã€‚è¿™æ ·çš„è½¬æ¢å¯èƒ½ç”¨äºé¿å…è­¦å‘Šæˆ–é”™è¯¯ï¼Œæˆ–è€…æ˜¯ä¸ºäº†æ»¡è¶³ç‰¹å®šçš„ç±»å‹è¦æ±‚ã€‚

åœ¨å‰è¿°ä»£ç ä¸­ï¼Œ`static_cast<unsigned>(time(nullptr))` å°† `time(nullptr)` çš„è¿”å›å€¼è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°ç±»å‹ `unsigned`ã€‚è¿™æ˜¯å› ä¸º `srand` å‡½æ•°æ¥å—çš„å‚æ•°ç±»å‹æ˜¯ `unsigned int`ï¼Œä¸ºäº†åŒ¹é…è¿™ä¸ªç±»å‹ï¼Œè¿›è¡Œäº†ç›¸åº”çš„ç±»å‹è½¬æ¢ã€‚

### åŠ›æ‰£3178

é‡åˆ°è¿™ç§æ•°å­¦çš„å°±è¦æƒ³èµ·é«˜ä¸­çš„æ€æƒ³





# åŠ¨æ€è§„åˆ’

[äº‘å‰ªè´´æ¿ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/paste/xac615na)



[ä»é›¶å¼€å§‹å­¦åŠ¨æ€è§„åˆ’-CSDNåšå®¢](https://blog.csdn.net/qq_32400847/article/details/51148917)

### åŠ›æ‰£çˆ¬æ¥¼æ¢¯

æ ¹æ®æ¨ç†å¾—å‡ºï¼šçˆ¬ä¸Šç¬¬nçº§å°é˜¶çš„æ­¥æ•°=çˆ¬ä¸Šn-1çº§å°é˜¶çš„æ­¥æ•°+çˆ¬ä¸Šn-2çº§å°é˜¶çš„æ­¥æ•°

**é€’å½’ï¼ˆdfsï¼‰**



```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        return climbStairs(n-1)+climbStairs(n-2);

    }
};
```

ç”»å‡ºé€’å½’çš„æ ‘å½¢ç»“æ„ï¼š

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207121907933.png" alt="image-20240207121907933" style="zoom:50%;" />

æˆ‘ä»¬å‘ç°æ¯æ¬¡æœ‰äº›å°é˜¶æ•°è¢«è®¡ç®—äº†å¤šæ¬¡ï¼Œå¯¼è‡´æ—¶é—´å¤æ‚åº¦å˜å¤§ï¼Œæ‰€ä»¥ä½¿ç”¨è®°å¿†åŒ–é€’å½’çš„æ–¹å¼å‡å°æ—¶é—´å¤æ‚åº¦

**è®°å¿†åŒ–é€’å½’**

```c++
class Solution {
public:
    int climbStairs(int n) {
        int *mem=new int[n+1];//åˆ›å»ºè®°å¿†æ•°ç»„
        //è®°å¿†æ•°ç»„ä¸­å­˜å‚¨çš„æ˜¯ç¬¬içº§å°é˜¶éœ€è¦çš„æ­¥æ•°ï¼Œå½“éœ€è¦ä½¿ç”¨çš„æ—¶å€™æ˜¯ç›´æ¥ä½¿ç”¨å³å¯
        //ç©ºé—´æ¢æ—¶é—´
        return func(n,mem);

    }
    int func(int n,int*mem){
        if(mem[n]>0){
            return mem[n];
        }
        if(n==1){
            mem[1]=1;
        }
        else if(n==2){
            mem[2]=2;
        }
        else{
            mem[n]=func(n-1,mem)+func(n-2,mem);
        }
        return mem[n];
    }
};
```

**åŠ¨æ€è§„åˆ’(é€’æ¨)**

```c++
class Solution {
public:
    int climbStairs(int n) {
              if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int*mem=new int[n+1];
        mem[1]=1;
        mem[2]=2;
        for(int i=3;i<=n;i++){
            mem[i]=mem[i-1]+mem[i-2];
        }
        return mem[n];

    }
};
```

**æ»šåŠ¨æ•°ç»„**

ä¼˜åŒ–äº†åŠ¨æ€è§„åˆ’ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦æœ€åä¸€ä¸ªnçº§å°é˜¶çš„è§£ï¼Œä¸éœ€è¦å…¶ä»–çš„ï¼Œæ‰€ä»¥è¿™äº›è¢«ç»†åŒ–çš„å­é—®é¢˜è¢«è¦†ç›–ä¹Ÿå¯ä»¥

```c++
class Solution {
public:
    int climbStairs(int n) {
              if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int first=1;
        int second=2;
        int third;
        for(int i=3;i<=n;i++){
            third=first+second;
            first=second;
            second=third;

        }
        return third;

    }
};
```

**é€šé¡¹å…¬å¼çŸ©é˜µå½¢å¼**

æ–æ³¢é‚£å¥‘æ•°åˆ—çš„çŸ©é˜µè¡¨è¾¾ï¼š

![image-20240207173623609](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207173623609.png)

![image-20240207173936045](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207173936045.png)



```c++
class Solution {
public:
    //è¯¥å‡½æ•°æ¨¡æ‹ŸçŸ©é˜µç›¸ä¹˜
    vector<vector<long long>> multiply(vector<vector<long long>> &a, vector<vector<long long>> &b) {
        vector<vector<long long>> c(2, vector<long long>(2));
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
            }
        }
        return c;
    }
    

    vector<vector<long long>> matrixPow(vector<vector<long long>> a, int n) {
        vector<vector<long long>> ret = {{1, 0}, {0, 1}};//è¿™é‡Œåˆ©ç”¨å•ä½çŸ©é˜µå’Œä»»ä½•çŸ©é˜µç›¸ä¹˜éƒ½ç­‰äº1æ¥åˆå§‹åŒ–
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, a);
            }
            n >>= 1;
            a = multiply(a, a);
        }
        return ret;
    }

    int climbStairs(int n) {
        vector<vector<long long>> ret = {{1, 1}, {1, 0}};
        vector<vector<long long>> res = matrixPow(ret, n);
        return res[0][0];
    }
};

```

**Binet's  Formula**

å°±æ˜¯ç”¨æ•°å­¦çš„æ–¹æ³•è§£çŸ©é˜µMçš„næ¬¡æ–¹ï¼Œä½ ä»¬æ•°å­¦å¥½çš„åˆ°åº•è¦æ€ä¹ˆæ ·

![image-20240207175746964](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207175746964.png)

![image-20240207175813215](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207175813215.png)



### èƒŒåŒ…é—®é¢˜

https://www.acwing.com/file_system/file/content/whole/index/content/6798055/

#### 01èƒŒåŒ…é—®é¢˜

æ¯ä»¶ç‰©å“åªèƒ½é€‰æ‹©ä¸€æ¬¡



```c++
#include<iostream> 
#include<vector>
using namespace std;
const int N=1010;
int dp[N];
int volum[N];
int values[N];
int f[N][N];
int main(){
	int n,v;//ç‰©å“æ•°å’ŒèƒŒåŒ…èƒ½å­˜æ”¾çš„æœ€å¤§é‡é‡
	cin>>n>>v;
	for(int i=1;i<=n;i++){
		cin>>volum[i]>>values[i];
	}
	
	//f(x,w),wä»£è¡¨çš„æ˜¯èƒ½é€‰çš„ç‰©å“æ•°ç›®ï¼Œwä»£è¡¨çš„æ˜¯èƒŒåŒ…çš„å®¹é‡
	//æœ€ç»ˆè¾“å‡ºf(n,v); 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=v;j++){
			if(j<volum[i]) f[i][j]=f[i-1][j];
			else{
				f[i][j]=max(f[i-1][j],f[i-1][j-volum[i]]+values[i]);
			}
			
		} 
	}
	
	cout<<f[n][v];
	return 0;	
	 
} 

```



#### 01èƒŒåŒ…ä¸€ç»´æ•°ç»„

dp[j]ä»£è¡¨çš„æ˜¯å½“ç‰©å“æ•°ç›®ä¸ºiçš„æ—¶å€™ï¼ŒèƒŒåŒ…å®¹é‡ä¸ºjæ—¶èƒ½å¾—åˆ°çš„æœ€å¤§ä»·å€¼

èƒŒåŒ…é—®é¢˜ä¸­çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯åœ¨ä¸åŒçš„èƒŒåŒ…å®¹é‡ä¸‹æ›´æ–°æœ€å¤§ä»·å€¼ã€‚å½“æˆ‘ä»¬éå†æ¯ä¸ªç‰©å“æ—¶ï¼Œå¦‚æœæˆ‘ä»¬é€‰æ‹©æ­£åºéå†èƒŒåŒ…å®¹é‡`j`ï¼Œåˆ™åœ¨æ›´æ–°`dp[j]`æ—¶ï¼Œå¯èƒ½ä¼šç”¨åˆ°å½“å‰å¾ªç¯ä¸­å·²ç»æ›´æ–°è¿‡çš„`dp[j - v[i]]`å€¼ï¼Œè¿™ä¼šå¯¼è‡´é”™è¯¯çš„ç»“æœï¼Œå› ä¸ºè¿™äº›å€¼å·²ç»æ˜¯å½“å‰è½®æ¬¡çš„æ›´æ–°ç»“æœï¼Œè€Œä¸æ˜¯ä¸Šä¸€è½®æ¬¡çš„å€¼ã€‚

```c++
#include<iostream>
using namespace std;
int dp[1010];
int v[1010];//ä»£è¡¨ç‰©å“çš„ä½“ç§¯æ•°ç»„
int w[1010];//ä»£è¡¨ç‰©å“çš„ä»·å€¼æ•°ç»„ 
int main(){
	int n,m;//n,måˆ†åˆ«ä»£è¡¨ç‰©å“æ•°ç›®å’ŒèƒŒåŒ…å®¹é‡
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>v[i]>>w[i];
	} 
	
	for(int i=1;i<=n;i++){
		for(int j=m;j>=v[i];j--){
			dp[j]=max(dp[j],dp[j-v[i]]+w[i]);		
		}	
    }	
	cout<<dp[5];	
	return 0;	
} 
```



#### äºŒç»´01èƒŒåŒ…

ç†è§£äº†ä¸€ç»´èƒŒåŒ…çš„ä¸€ç»´æ•°ç»„ä¹‹åæ‰ç†è§£äºŒç»´èƒŒåŒ…çš„è§£æ³•ï¼Œä¹Ÿæ˜¯æ»šåŠ¨æ•°ç»„ï¼Œä¸è¿‡å¤šäº†ä¸€ä¸ªä½“ç§¯

```c++
#include <bits/stdc++.h>

using namespace std;

int n, V, M;
const int N = 1e3 + 5;
int v[N], m[N], w[N], f[N][N];

signed main () {
    cin >> n >> V >> M;
    for (int i = 1; i <= n; i ++) {
        cin >> v[i] >> m[i] >> w[i];//ä½“ç§¯ï¼Œé‡é‡ï¼Œä»·å€¼
    }
    
    
    //f[V][M]è¡¨ç¤ºèƒŒåŒ…ä½“ç§¯ä¸ºV,è´¨é‡ä¸ºçš„æ—¶å€™ï¼Œæ‰€èƒ½å­˜æ”¾çš„æœ€å¤§ä»·å€¼
    //ä¸æ–­æ›´ç»†f[V][M],å½“içš„å€¼å˜ä¸ºNçš„æ—¶å€™ï¼Œæ˜¯è¦æ±‚çš„ç­”æ¡ˆ    
    for (int i = 1; i <= n; i ++)
        for (int j = V; j >= v[i]; j --)
            for (int k = M; k >= m[i]; k --)
                f[j][k] = max (f[j - v[i]][k - m[i]] + w[i], f[j][k]);//åŠ¨æ€è½¬ç§»æ–¹ç¨‹ï¼Œ01 èƒŒåŒ…çš„æ€è·¯
    cout << f[V][M];
}


```



#### å¤šé‡èƒŒåŒ…

ç‰©å“çš„ä¸ªæ•°æ˜¯ä¸å®šçš„ï¼Œæ¯”å¦‚ç‰©å“Aæœ‰2ä»¶ç‰©å“Bæœ‰3ä»¶

```c++
#include <bits/stdc++.h>
using namespace std;
int dp[1010];
int weight[1010];
int value[1010];
int s[1010];
int main () {
	int w,v,s;
	int n,m,cnt=1;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>w>>v>>s;
		int pos=1;
		while(pos<=s){
			value[cnt]=v*pos;
			weight[cnt]=w*pos;
			s-=pos;
			pos*=2;
			cnt++;		
		}
		
		if(s){
			weight[cnt]=s*w;
			value[cnt]=v*s;	
			cnt++;	
		}
	}
	
	for(int i=1;i<cnt;i++){
		for(int j=m;j>=weight[i];j--){
			dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);
		}
	}
	
	cout<<dp[m];

	
}
```



#### å®Œå…¨èƒŒåŒ…

å®Œå…¨èƒŒåŒ…çš„å«ä¹‰æ˜¯ï¼Œç‰©å“æ˜¯æ— é™çš„ï¼Œæˆ‘ä»¬ä¸å¿…è€ƒè™‘

```c++
#include<iostream>

using namespace std;

int dp[1010][1010];
int weight[1010];
int value[1010];
int main() {
	int n, m;//nç§ç‰©å“ï¼ŒèƒŒåŒ…å®¹é‡ä¸ºm
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> weight[i] >> value[i];
	}


	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			dp[i][j] = dp[i - 1][j];
			if (j >= weight[i]){
				dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);
				}	
		}
	}

	cout << dp[n][m];
}

```



#### å®Œå…¨èƒŒåŒ…ä¸€ç»´æ•°ç»„

ä¸ºä»€ä¹ˆä¸€ç»´æ•°ç»„ä»v[i]å¼€å§‹è®¡ç®—å‘¢ï¼Ÿå› ä¸ºä¸€ç»´æ•°ç»„æ˜¯æ»šåŠ¨æ•°ç»„ï¼Œæ˜¯ä¸€å±‚ä¸€å±‚å åŠ çš„ï¼Œå…šj<w[i]çš„æ—¶å€™ï¼Œæ ¹æœ¬ä¸ç”¨è€ƒè™‘é€‰è¿™ä¸ªç‰©å“

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int f[N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)
    {
        cin>>v[i]>>w[i];
    }

    for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
    cout<<f[m]<<endl;
}
```



#### æ··åˆèƒŒåŒ…é—®é¢˜

```c++
int n, m, f[1010];

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
    {
        int v, w, s;
        cin >> v >> w >> s;
        if (!s)     // å®Œå…¨èƒŒåŒ…é—®é¢˜
        {
            for (int j = v; j <= m; j ++ )
                f[j] = max(f[j], f[j - v] + w);
        }
        else
        {
            if (s == -1) s = 1;     // 01 èƒŒåŒ…é—®é¢˜

            // å®Œå…¨èƒŒåŒ…é—®é¢˜è½¬åŒ–ä¸º 01 èƒŒåŒ…é—®é¢˜ï¼ŒäºŒè¿›åˆ¶æ‹†åˆ†ä¼˜åŒ–
            for (int k = 1; k <= s; k *= 2)
            {
                for (int j = m; j >= k * v; j -- )
                    f[j] = max(f[j], f[j - k * v] + k * w);
                s -= k;
            }
            if (s)
            {
                for (int j = m; j >= s * v; j -- )
                    f[j] = max(f[j], f[j - s * v] + s * w);
            }
        }
    }

    cout << f[m] << endl;
    return 0;
}

```



#### åˆ†ç»„èƒŒåŒ…é—®é¢˜

```c++
const int N = 110;
int n, m, v[N][N], w[N][N], f[N], s[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> s[i];
        for (int j = 1; j <= s[i]; j ++ )
            cin >> v[i][j] >> w[i][j];
    }
    

    for (int i = 1; i <= n; i ++ ï¼‰
        for (int j = m; j >= 0; j -- )//ä¸€ç»´
            for (int k = 1; k <= s[i]; k ++ )   // ç»„å†…ç¼–å·
                if (j >= v[i][k])
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);

    cout << f[m] << endl;
    return 0;
}


```



#### 01èƒŒåŒ…æœ€ä½³æ–¹æ¡ˆæ•°



```c++
const int N = 1100, mod = 1e9 + 7;
int n, m, f[N], cnt[N];

int main()
{
    cin >> n >> m;
    for (int i = 0; i <= m; i ++ ) cnt[i] = 1;

    for (int i = 1; i <= n; i ++ )
    {
        int v, w;
        cin >> v >> w;

        for (int j = m; j >= v; j -- )
        {
            int value = f[j - v] + w;
            if (value > f[j])
            {
                f[j] = value;
                cnt[j] = cnt[j - v];
            } else if (value == f[j]) 
                cnt[j] = (cnt[j] + cnt[j - v]) % mod;
        }
    }

    cout << cnt[m] << endl;
    return 0;
}


```



#### 01èƒŒåŒ…æœ€ä½³æ–¹æ¡ˆæ•°å­—å…¸åºæœ€å°

```c++
const int N = 1010;
int n, m, v[N], w[N], f[N][N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = n; i >= 1; i -- )
        for (int j = 1; j <= m; j ++ )
        {
            f[i][j] = f[i + 1][j];
            if (j >= v[i]) f[i][j] = max(f[i + 1][j], f[i + 1][j - v[i]] + w[i]);
        }



    int j = m;
    for (int i = 1; i <= n; i ++ )   // å¾€å‰æ¨
        if (j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i])
        {
            cout << i << ' ';
            j -= v[i];  // é€‰äº†ç¬¬ i ä¸ªç‰©å“ï¼Œæ€»ä½“ç§¯è¦å‡å°‘
        }

    return 0;
}


```



### èƒŒåŒ…é—®é¢˜æ±‚æ–¹æ¡ˆæ•°ã€å…·ä½“æ–¹æ¡ˆ

[èƒŒåŒ…é—®é¢˜æ±‚æ–¹æ¡ˆæ•°ã€å…·ä½“æ–¹æ¡ˆ-CSDNåšå®¢](https://blog.csdn.net/qq_43851311/article/details/128981355?ops_request_misc=&request_id=&biz_id=102&utm_term=èƒŒåŒ…é—®é¢˜æœ€ä½³æ–¹æ¡ˆæ•°&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128981355.142^v100^pc_search_result_base1&spm=1018.2226.3001.4187)

#### è´§å¸ç³»ç»Ÿ

ç»™ä½ ä¸€ä¸ªnç§é¢å€¼çš„è´§å¸ç³»ç»Ÿï¼Œï¼Œæ±‚ç»„æˆé¢å€¼ä¸ºmçš„è´§å¸æœ‰å¤šå°‘ç§

```c++
//æ¨åˆ°è¿‡ç¨‹
//dp[i][j]==dp[1][j]+dp[i[j-v[i]]]
//æˆ‘ä»¬å¯ä»¥çŸ¥é“dp[i-1][j]è¡¨ç¤ºä¸é€‚ç”¨å½“å‰é¢å€¼çš„è´§å¸æ‰€æœ‰çš„æ–¹æ¡ˆæ•°ï¼Œå†åŠ ä¸Šä½¿ç”¨äº†è¯¥è´§å¸çš„æ–¹æ¡ˆæ•°å°±æ˜¯æ‰€æ±‚çš„
//ä½¿ç”¨äº†è¯¥è´§å¸çš„æ–¹æ¡ˆæ•°ç­‰äºdp[i][j-v[i]],å³æˆ‘ä»¬é»˜è®¤ä½¿ç”¨äº†ä¸€æ¬¡v[i]è´§å¸ï¼Œç°åœ¨æ€»é¢å€¼å˜æˆäº†j-v[i]
#include<iostream>
using namespace std;
int money[1010];
long long dp[1010][1010];
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>money[i];
		dp[i][0]=1;
	}
	


	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){	
			if(j<money[i]) dp[i][j]=dp[i-1][j];
			else dp[i][j]=dp[i-1][j]+dp[i][j-money[i]];
		}
	}
	cout<<dp[n][m];

    return 0;
}

```



#### ACWing278

```c++
#include<iostream>
using namespace std;
long long dp[10010];
int num[110];
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>num[i];
    }
    
    dp[0]=1;//æ˜¾ç„¶ä»€ä¹ˆéƒ½ä¸é€‰ä¹Ÿæ˜¯ä¸€ç§æ–¹æ¡ˆæ•°
    for(int i=1;i<=n;i++){
        for(int j=m;j>=num[i];j--){
            dp[j]=dp[j]+dp[j-num[i]];
        }
    }
    
    cout<<dp[m];
   
    return 0;
}
```



#### ACWing1023

```c++
#include<iostream>
using namespace std;
int money[]={0,1,2,5,10};
int dp[1010];
int main()
{
	int n;
	cin>>n;
	dp[0]=1;
	for(int i=1;i<=4;i++){
		for(int j=money[i];j<=n;j++){
			dp[j]=dp[j]+dp[j-money[i]];
		}
	}
	cout<<dp[n];
    return 0;
}


```



### ç¡¬å¸é—®é¢˜

ç¡¬å¸é—®é¢˜å¯ä»¥è´ªå¿ƒçš„æƒ…å†µé€šå¸¸åŒ…æ‹¬ä»¥ä¸‹å‡ ç§ï¼š

1. æ¯ä¸€ç§é¢å€¼çš„ç¡¬å¸éƒ½å¯ä»¥æ— é™ä½¿ç”¨ï¼šå¦‚æœæ¯ç§é¢å€¼çš„ç¡¬å¸æ•°é‡æ˜¯æ— é™çš„ï¼Œå¹¶ä¸”é¢å€¼ä¹‹é—´æ»¡è¶³æŸç§å…³ç³»ï¼Œæ¯”å¦‚æ¯ç§é¢å€¼éƒ½æ˜¯å‰ä¸€ç§é¢å€¼çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨è´ªå¿ƒç®—æ³•ã€‚
2. é¢å€¼ä¹‹é—´æ»¡è¶³æŸç§æ€§è´¨ï¼šå¦‚æœç¡¬å¸çš„é¢å€¼ä¹‹é—´å­˜åœ¨æŸç§ç‰¹æ®Šçš„å…³ç³»ï¼Œæ¯”å¦‚æ˜¯ç­‰æ¯”æ•°åˆ—ã€æ–æ³¢é‚£å¥‘æ•°åˆ—ç­‰ï¼Œé‚£ä¹ˆä¹Ÿå¯ä»¥ä½¿ç”¨è´ªå¿ƒç®—æ³•ã€‚
3. æœ€ä¼˜å­ç»“æ„æ€§è´¨ï¼šç¡¬å¸é—®é¢˜çš„æœ€ä¼˜è§£å¯ä»¥ç”±å­é—®é¢˜çš„æœ€ä¼˜è§£ç»„åˆè€Œæˆï¼Œè€Œä¸”å­é—®é¢˜ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œä¸å­˜åœ¨ä¾èµ–å…³ç³»ã€‚

å½“æˆ‘ä»¬è¦å‡‘å‡ºw=15ï¼Œé¦–å…ˆé¢ä¸´ä¸‰ç§æƒ…å†µçš„é€‰æ‹©

å½“æˆ‘ä»¬é€‰æ‹©äº†ä»·å€¼ä¸º1çš„ç¡¬å¸æ—¶ï¼Œé—®é¢˜è½¬åŒ–æˆäº†1+å‡‘å‡ºä»·å€¼ä¸º14çš„é—®é¢˜

å½“æˆ‘ä»¬é€‰æ‹©äº†ä»·å€¼ä¸º5çš„ç¡¬å¸çš„æ—¶å€™ï¼Œé—®é¢˜è½¬åŒ–æˆäº†1+å‡‘å‡ºä»·å€¼ä¸º10çš„é—®é¢˜

å½“æˆ‘ä»¬é€‰æ‹©äº†ä»·å€¼ä¸º11çš„ç¡¬å¸çš„æ—¶å€™ï¼Œé—®é¢˜è½¬åŒ–æˆäº†å‡‘å‡ºä»·å€¼ä¸º4çš„é—®é¢˜



![image-20240402214153424](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402214153424.png)



```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main() {
    int dp[100], i;
    dp[0] = 0;//f(0)çš„æƒ…å†µï¼Œä»·å€¼ä¸º0é‚£æˆ‘ä»¬è¿˜å‡‘ä¸ªé›†è´¸å•Šï¼Œç¡¬å¸æ•°ç›´æ¥ä¸º0å³å¯
    int cost;
    for (int i = 1; i <= 15; i++) {
        cost = 9999;
        if (i - 1 >= 0) cost = min(cost, dp[i - 1] + 1);//è¡¨ç¤ºæˆ‘ä»¬ä½¿ç”¨äº†æ­¤ç¡¬å¸ä¸€æ¬¡ï¼Œæ‰€ä»¥åŠ ä¸€
        if (i - 5 >= 0) cost = min(cost, dp[i - 5] +1);
        if (i - 11 >= 0)cost = min(cost, dp[i - 11] + 1);
        dp[i] = cost;
        printf("dp[%d]=%d\n", i, dp[i]);
    }


    return 0;
}

```

![image-20240402215125353](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402215125353.png)



### åŠ›æ‰£198æ‰“å®¶åŠ«èˆ

é¢å¯¹ä¸€é“é¢˜çš„æ—¶å€™ï¼Œæˆ‘ä»¬é¦–å…ˆæƒ³åˆ°çš„åº”è¯¥éƒ½æ˜¯dfs

åˆ†æè¿™é¢˜çš„æ€è·¯ï¼Œå¯¹äºæŸä¸€åº—é“ºæ¥è¯´ï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§æƒ…å†µï¼Œé€‰æˆ–è€…æ˜¯ä¸é€‰ã€‚å¦‚æœæˆ‘ä»¬é€‰æ‹©è¯¥åº—é“ºï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¸èƒ½é€‰æ‹©å®ƒçš„é‚»å±…ï¼Œæ ¹æ®è´ªå¿ƒæ€æƒ³ï¼Œæˆ‘ä»¬åªèƒ½é€‰æ‹©å®ƒçš„é‚»å±…çš„é‚»å±…ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ€å¤§å€¼ä¸ºdfs(x+2)+stores[x]

å¦‚æœæˆ‘ä»¬æ²¡æœ‰é€‰æ‹©è¿™å®¶åº—é“ºï¼Œé‚£ä¹ˆæˆ‘ä»¬åªèƒ½é€‰æ‹©å®ƒçš„é‚»å±…ï¼Œæ‰€ä»¥dfs(x+1)

æ¯”è¾ƒä¸¤è€…çš„æœ€å¤§å€¼å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 10010;//åº—é“ºæœ€å¤šæœ‰è¿™ä¹ˆå¤šå®¶
int n;
int stores[N];
int dfs(int x) {
    if (x > n) return 0;
    else return max(dfs(x +1), dfs(x + 2) + stores[x]);
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &stores[i]);
    }
    printf("%d\n", dfs(1));
    return 0;
}

```



ä½†æ˜¯dfsçš„æ—¶é—´å¤æ‚åº¦å¤ªé«˜äº†å‘€ï¼Œæˆ‘ä»¬è¦æƒ³åŠæ³•åšä¼˜åŒ–

æˆ‘ä»¬ç”»å‡ºdfsçš„é€’å½’æ ‘ï¼Œå‘ç°æœ‰å¾ˆå¤šé‡å¤çš„æœç´¢ï¼ˆä½ çŸ¥é“çš„ï¼‰



//tipsï¼Œè¦æ˜¯æƒ³å®ç°è®°å¿†åŒ–æœç´¢ï¼Œé‚£ä¹ˆdfsçš„å‚æ•°è¦å°½å¯èƒ½çš„å°ï¼Œä¸åº”è¯¥æŠŠæ²¡æœ‰å½±å“åˆ°è¾¹ç•Œçš„å‚æ•°æ”¾è¿›æ¥

//å°½å¯èƒ½çš„æŠŠèƒ½å‰ªæçš„å‚æ•°å†™ä¸Šæ¥

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 10010;//åº—é“ºæœ€å¤šæœ‰è¿™ä¹ˆå¤šå®¶
int memory[N];
int n,sum;
int stores[N];
int dfs(int x) {
    if (memory[x]) return memory[x];
    int sum = 0;
    if (x > n) sum = 0;//å¦‚æœxçš„å€¼å¤§äºnçš„å€¼ï¼Œæ²¡æœ‰æˆ‘ä»¬å¯ä»¥æ‰“åŠ«çš„åº—é“º
    else {
        sum = max(dfs(x + 1), dfs(x + 2) + stores[x]);
        memory[x] = sum;
    }
    return sum;

}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &stores[i]);
    }
    printf("%d\n", dfs(1));
    return 0;
}

```



ç„¶åï¼Œæˆ‘ä»¬ç»§ç»­åˆ†ææœç´¢æ ‘

![image-20240402223230821](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402223230821.png)

æœ‰äº›å¤©æ‰å°±åœ¨æƒ³ï¼Œé‚£ä¸ºä»€ä¹ˆä¸å¯ä»¥ä»åº•å±‚å‡ºå‘ï¼Œçœå»å½’çš„è¿‡ç¨‹å‘¢ï¼Ÿè¿™å°±æ˜¯é€’æ¨

åŠ¨æ€è§„åˆ’çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¹Ÿå°±æ˜¯dfså¾—åˆ°çš„å¼å­ï¼Œä½†æ˜¯æˆ‘ä¸ªäººçš„ç†è§£å°±æ˜¯å®ƒç»“åˆäº†è®°å¿†åŒ–æœç´¢ï¼Œå˜æˆäº†ï¼š

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 10010;//åº—é“ºæœ€å¤šæœ‰è¿™ä¹ˆå¤šå®¶
int ans[N];
int n;
int stores[N];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &stores[i]);
    }
    for (int i = n; i>=1; i--) {
        ans[i] = max(ans[i+1], ans[i +2] + stores[i]);
    }

    cout << ans[1];
    return 0;
}
//è¿™é‡Œçš„iè¡¨ç¤ºçš„æ˜¯ä»iå¼€å§‹æŠ¢åŠ«çš„æœ€å¤§å€¼
//å‡è®¾dp[i]è¡¨ç¤ºä»ç¬¬iå®¶åº—æŠ¢åŠ«çš„ç­”æ¡ˆ
//å¦‚æœæˆ‘ä»¬ä»ç¬¬nå®¶åº—å¼€å§‹æŠ¢åŠ«ï¼Œé‚£ä¹‹åå°±æ²¡æœ‰å¯ä»¥æŠ¢çš„åº—äº†ï¼Œæ‰€ä»¥dp[i]=stores[i]
//ç„¶åæˆ‘ä»¬ä»ç¬¬n-1å®¶åº—å¼€å§‹æŠ¢åŠ«ï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§æƒ…å†µï¼Œç¬¬ä¸€ä¸ªæ˜¯æŠ¢n-1å®¶ï¼Œç¬¬äºŒä¸ªæ˜¯æŠ¢ç¬¬nå®¶
//ç„¶åæˆ‘ä»¬ä»ç¬¬n-2å®¶å¼€å§‹æŠ¢åŠ«ï¼Œæˆ‘ä»¬ä¹Ÿæœ‰ä¸¤ç§æƒ…å†µï¼Œé€‰1ã€3æˆ–è€…æ˜¯é€‰2
```



### ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯

### é›¶é’±å…‘æ¢

å®Œå…¨èƒŒåŒ…é—®é¢˜

### åŠ›æ‰£53æœ€å¤§å­æ•°ç»„å’Œ

çœ‹é¢˜è§£ï¼Œå†™çš„å¾ˆç²¾å½©

### æ•´æ•°æ‹†åˆ†

ä¸¤ç§è§£æ³•

### åŠ›æ‰£æ¯”ç‰¹ä½è®¡æ•°

æ–¹æ³•ä¸€å°±æ˜¯éå†æ•°ç»„ï¼Œæ¯ä¸€æ¬¡éƒ½è®¡ç®—x&(x-1)å˜æˆé›¶æ‰€éœ€è¦çš„æ¬¡æ•°ï¼Œä½†æ˜¯è¿™æœ‰å¾ˆå¤šé‡å¤è®¡ç®—

æ‰€ä»¥åŠ¨æ€è§„åˆ’

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        int highBit = 0;
        for (int i = 1; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
};


```



### æœ€é•¿ä¸Šå‡å­åºåˆ—

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {

        int n=nums.size();
        if(n==0) return 0;
        vector<int>dp(n,0);
        for(int i=0;i<n;i++){
            dp[i]=1;
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i]=max(dp[i],dp[j]+1);
                }
            }
            
        }
        return *max_element(dp.begin(),dp.end());

    }
};
```



### åŠ›æ‰£1668æœ€å¤§é‡å¤å­å­—ç¬¦ä¸²

KMPç®—æ³•

### åŠ›æ‰£399åŒå‘¨èµ›ç¬¬å››é¢˜

# å¿«é€Ÿå¹‚ç®—æ³•

https://www.bilibili.com/video/BV16Z4y1M7y1/?spm_id_from=333.337.search-card.all.click

å¿«é€Ÿå¹‚ç®—æ³•ç”¨äºè®¡ç®—å¹‚é¢„ç®—ï¼Œï¼ˆå½“nå¾ˆå¤§çš„æ—¶å€™ï¼Œæœ´ç´ ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºo(n),è¿™ä¸ªç®—æ³•å¯ä»¥è¿›è¡Œæé€Ÿ),åŸç†å°±æ˜¯æŠŠnè½¬åŒ–æˆ2çš„å¹‚è¿ç®—ï¼Œå†ç®€åŒ–,æ—¶é—´å¤æ‚åº¦ä¸ºo(logn)

### æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬né¡¹ 

**é€’å½’**

```c++
#include <iostream>
using namespace std;

long long fastPowerRecursive(long long base, long long exponent) {
    if (exponent == 0)
        return 1;
    else if (exponent % 2 == 0)
        return fastPowerRecursive(base * base, exponent / 2);
    else
        return base * fastPowerRecursive(base * base, (exponent - 1) / 2);
}

int main() {
    long long base, exponent;
    cout << "è¯·è¾“å…¥åº•æ•°å’ŒæŒ‡æ•°: ";
    cin >> base >> exponent;

    cout << "å¿«é€Ÿå¹‚çš„ç»“æœæ˜¯: " << fastPowerRecursive(base, exponent) << endl;

    return 0;
}

```

**éé€’å½’**

```c++
#include <iostream>
using namespace std;

long long fastPowerIterative(long long base, long long exponent) {
    long long result = 1;
    while (exponent > 0) {
        if (exponent % 2 == 1)
            result *= base;
        base *= base;
        exponent /= 2;
    }
    return result;
}

int main() {
    long long base, exponent;
    cout << "è¯·è¾“å…¥åº•æ•°å’ŒæŒ‡æ•°: ";
    cin >> base >> exponent;

    cout << "å¿«é€Ÿå¹‚çš„ç»“æœæ˜¯: " << fastPowerIterative(base, exponent) << endl;

    return 0;
}

```





# é€’æ¨æ±‚è§£

![image-20240313043844402](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313043844402.png)



næ¡çº¿æ®µï¼Œæœ€åä¸€æ¡çº¿æ®µä¸€å®šä¸å‰n-1è·Ÿçº¿çŸ­ç›¸äº¤ï¼Œå¹¶ä¸”è¯¥çº¿æ®µè¢«å‰n-1ä¸ªçº¿æ®µåˆ†æˆnæ®µï¼Œè¿™ä¸ªæ°å¥½æ˜¯ç¬¬næ¡çº¿æ®µåŠ ä¸Šä¹‹åå¤šå‡ºçš„éƒ¨åˆ†

æ‰€ä»¥çŠ¶æ€è½¬ç§»æ–¹ç¨‹f(n)=f(n-1)+n

f(1)=2   f(2)=4

```c++
#include<iostream>
using namespace std;
int func(int x) {
    if (x == 1) {
        return 2;
    }

    if (x == 2) {
        return 4;
    }
    return func(x - 1) + x;
}
int main()
{
    int n;
    cin >> n;
    cout << func(n);

    return 0;
}
```





![image-20240313044505011](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313044505011.png)



åªæœ‰ä¸€æ ¹æŠ˜çº¿çš„æƒ…å†µ

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313044533512.png" alt="image-20240313044533512" style="zoom:50%;" />

æœ‰ä¸¤æ ¹æŠ˜çº¿çš„æƒ…å†µ

![image-20240313045453327](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045453327.png)

å¯çŸ¥ä¸€æ ¹æŠ˜çº¿ä¼šä¸å¦ä¸€ä¸ªæŠ˜ç°æœ‰4ä¸ªäº¤ç‚¹

æ‰€ä»¥çŠ¶æ€è½¬ç§»æ–¹ç¨‹  f(n)=4*(n-1)+1,å…¶ä¸­(n-1)æ˜¯äº¤ç‚¹æ•°ï¼Œäº¤ç‚¹æ•°åŠ ä¸€å°±æ˜¯çº¿æ®µæ•°



![image-20240313045653763](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045653763.png)

è¿™ä¸€é¢˜çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯æ–æ³¢é‚£å¥‘æ•°åˆ—

å‡è®¾f(n-1)å·²ç»çŸ¥é“ï¼Œé‚£ä¹ˆæœ‰ä¸¤ç§æƒ…å†µ

ç¬¬ä¸€ç§æ˜¯æœ€åä¸€ä¸ªæ ¼å­æ”¾æ•°æ¡ï¼Œé‚£ä¹ˆåªæœ‰è¿™ä¸€ç§æ”¾æ³•ï¼Œæ€»å…±æœ‰f(n-1)ç§

ç¬¬äºŒç§æ˜¯æœ€åä¸¤ä¸ªæ ¼å­æ”¾æ¨ªæ¡ï¼Œå› ä¸ºä¸Šé¢ä¸¤ä¸ªå„è‡ªæ”¾äº†æ¨ªæ¡ï¼Œé‚£ä¹ˆä¸‹é¢é‚£ä¸¤ä¸ªæ ¼å­ä¹Ÿåªèƒ½æ”¾æ¨ªæ¡ï¼Œä¹Ÿåªæœ‰ä¸€ç§æ–¹æ³•ï¼Œæ€»å…±æœ‰f(n-2)ç§

æ‰€ä»¥f(n)=f(n-1)+f(n-2)



![image-20240313045940604](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045940604.png)





![image-20240313050000122](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050000122.png)



<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050438505.png" alt="image-20240313050438505" style="zoom:50%;" />

çŠ¶æ€è½¬ç§»æ–¹ç¨‹f(n)=f(n-1)+f(n-2)+f(n-4)



![image-20240313050730568](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050730568.png)



# å¡ç‰¹å…°æ•°åˆ—

[å¡ç‰¹å…°æ•°(Catalan Number)-CSDNåšå®¢](https://blog.csdn.net/Melody_Gogo/article/details/121800213?ops_request_misc=%7B%22request%5Fid%22%3A%22171030664816800213029071%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=171030664816800213029071&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121800213-null-null.142^v99^pc_search_result_base1&utm_term=å¡ç‰¹å…°æ•°çš„æ€§è´¨&spm=1018.2226.3001.4187)

![image-20240313050816661](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050816661.png)

1  2   5  14  42

# ç»„åˆæ•°ï¼ˆå¢å¡æ–¯ï¼‰

[ç»„åˆæ•°ï¼ˆå¢å¡æ–¯å®šç†ï¼‰-CSDNåšå®¢](https://blog.csdn.net/qq_43956340/article/details/104483451?ops_request_misc=%7B%22request%5Fid%22%3A%22171030723016800182139199%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=171030723016800182139199&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-104483451-null-null.142^v99^pc_search_result_base1&utm_term=ç»„åˆæ•°å…¬å¼&spm=1018.2226.3001.4187)



# æ–æ³¢é‚£å¥‘æ•°åˆ—

[æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å¸¸ç”¨æ€§è´¨_æ–æ³¢é‚£å¥‘æ•°åˆ—å¸¸è€ƒçš„5ä¸ªæ€§è´¨-CSDNåšå®¢

[](https://blog.csdn.net/ltrbless/article/details/88565442?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-4-88565442-blog-82112564.235^v43^pc_blog_bottom_relevance_base3&spm=1001.2101.3001.4242.3&utm_relevant_index=7)



æ–æ³¢é‚£å¥‘æ•°åˆ—,éšç€nçš„å¢å¤§ï¼Œå‰ä¸€é¡¹æ¯”ä¸Šåä¸€é¡¹çš„ç»“æœè¶Šæ¥è¶Šæ¥è¿‘0.618



# æšä¸¾/æš´åŠ›

æšä¸¾æ³•åˆè¢«æˆä¸ºæš´åŠ›æ³•

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207140355190.png" alt="image-20240207140355190" style="zoom:50%;" />

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207140544310.png" alt="image-20240207140544310" style="zoom:50%;" />

```c++
#include <iostream>
using namespace std;
int main() {
	for (int i = 0; i <= 1; i++) {
		for (int j = 0; j <= 1; j++) {
			for (int k = 0; k <= 1; k++) {
				for (int m = 0; m <= 1; m++) {
					for (int n = 0; n <= 1; n++) {
						cout << i << j << k << m << n << endl;
					}
				}
			}
		}
	}
	
}

```



![image-20240207140722333](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207140722333.png)

```c++
//è´¨æ•°ç­›çš„æ—¶é—´å¤æ‚åº¦æ˜¯on(n*logn)
#include <iostream>
using namespace std;
int a[10001] = { 0 };
int main() {
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++) {
		if (a[i] == 0) {
			for (int j = i * 2; j <= n; j += i) {
				a[j] = 1;
			}
		}
	}
}
```



**æ•°çš„è´¨å› æ•°åˆ†è§£**

```c++
#include <iostream>
using namespace std;
int a[101] = { 0 };
int main() {
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++) {
		if (a[i] == 0) {
			for (int j = i * 2; j <= n; j += i) {
				a[j] = 1;
			}
		}
	}
	//ä¸€ä¸ªæ•°çš„è´¨å› æ•°åªèƒ½åœ¨æ¯”è¿™ä¸ªæ•°å°çš„è´¨æ•°ä¸­å»æ‰¾
	int i = 2;
	while (n >= 1&&i<=n) {
		if (a[i] == 0 && n % i == 0) {
			cout << i << " ";
			n = n / i;
		}
		else {
			i++;
		}
	}
}
```



æœ‰ä¸€ä¸ªè¾¹é•¿ä¸ºnã€mçš„æ£‹ç›˜ï¼Œæ±‚æ£‹ç›˜å†…æœ‰å¤šå°‘ä¸ªæ­£æ–¹å½¢å’Œé•¿æ–¹å½¢

æšä¸¾æ³•è§£é¢˜ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯on(nçš„å¹³æ–¹+mçš„å¹³æ–¹)

```c++
#include <iostream>
using namespace std;
int main() {
	long long n, m, a1 = 0, a2 = 0;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (i == j) a1 += (n - i + 1) * (m - j + 1);
			else {
				a2 += (n - i + 1) * (m - j + 1);
			}
		}
	}
	cout << a1 << " " << a2 << endl;
}

```

# æ—¶é—´é—®é¢˜

### 24å°æ—¶åˆ¶è½¬æ¢ä¸º12å°æ—¶åˆ¶

```c++
#include <iostream>
#include <string>

using namespace std;

string convertTo12HourFormat(int hour) {
    if (hour <= 12) {
        return to_string(hour) + " AM";
    } else {
        return to_string(hour - 12) + " PM";
    }
}

int main() {
    int hour;
    cout << "Enter hour in 24-hour format: ";
    cin >> hour;

    cout << "Time in 12-hour format: " << convertTo12HourFormat(hour) << endl;

    return 0;
}

```

### æ—¶é—´åŠ å‡æ³•

**æ—¶é—´åŠ å‡æ³•å¯ä»¥é€šè¿‡å°†æ—¶é—´è½¬æ¢ä¸ºåˆ†é’Ÿæ•°è¿›è¡Œè®¡ç®—ï¼Œç„¶åå†å°†ç»“æœè½¬æ¢å›æ—¶é—´æ ¼å¼ã€‚**

ç»™ä¸€ä¸ªæ—¶é—´ï¼Œæ±‚è¯¥æ—¶é—´æå‰45åˆ†é’Ÿçš„æ—¶é—´

```c++
#include <iostream>
#include <sstream>

using namespace std;

int main() {
    int h, m;
    char colon;
    cin >> h >> colon >> m;

    // è®¡ç®—å½“å‰æ—¶é—´æ€»å…±çš„åˆ†é’Ÿæ•°
    int totalMinutes = h * 60 + m;

    // è®¡ç®—45åˆ†é’Ÿä¹‹å‰çš„æ—¶åˆ»
    totalMinutes -= 45;
    if (totalMinutes < 0) {
        totalMinutes += 24 * 60;  // è°ƒæ•´åˆ°å‰ä¸€å¤©
    }

    // è®¡ç®—æ–°çš„å°æ—¶å’Œåˆ†é’Ÿ
    int newHour = totalMinutes / 60;
    int newMinute = totalMinutes % 60;

    // è¾“å‡ºç»“æœ
    cout << newHour << ":" << newMinute / 10 << newMinute % 10 << endl;

    return 0;
}

```



### æ—¶åŒºè½¬æ¢



```c++
#include <iostream>

using namespace std;

// å°†ç»™å®šæ—¶é—´è½¬æ¢ä¸ºUTCæ—¶é—´
void convertToUTC(int& hour, int& minute, int& offset) {
    // è®¡ç®—UTCæ—¶é—´
    int totalMinutes = hour * 60 + minute - offset;
    if (totalMinutes < 0) {
        totalMinutes += 24 * 60;  // è°ƒæ•´åˆ°å‰ä¸€å¤©
    }
    hour = totalMinutes / 60;
    minute = totalMinutes % 60;
}

// å°†UTCæ—¶é—´è½¬æ¢ä¸ºç›®æ ‡æ—¶åŒºçš„æ—¶é—´
void convertToTimeZone(int& hour, int& minute, int& offset) {
    // è®¡ç®—ç›®æ ‡æ—¶åŒºçš„æ—¶é—´
    int totalMinutes = hour * 60 + minute + offset;
    hour = totalMinutes / 60;
    minute = totalMinutes % 60;
}

int main() {
    int hour, minute, offset, targetOffset;
    cout << "Enter hour and minute: ";
    cin >> hour >> minute;
    cout << "Enter offset of current time zone: ";
    cin >> offset;
    cout << "Enter offset of target time zone: ";
    cin >> targetOffset;

    // å°†ç»™å®šæ—¶é—´è½¬æ¢ä¸ºUTCæ—¶é—´
    convertToUTC(hour, minute, offset);

    // å°†UTCæ—¶é—´è½¬æ¢ä¸ºç›®æ ‡æ—¶åŒºçš„æ—¶é—´
    convertToTimeZone(hour, minute, targetOffset);

    cout << "Time in target time zone: " << hour << ":" << minute << endl;

    return 0;
}

```



### æ—¶é—´å·®

```c++
#include <iostream>

using namespace std;

// å°†æ—¶é—´è½¬æ¢ä¸ºåˆ†é’Ÿæ•°
int timeToMinutes(int hour, int minute) {
    return hour * 60 + minute;
}

// è®¡ç®—æ—¶é—´å·®
void calculateTimeDifference(int hour1, int minute1, int hour2, int minute2, int& diffHour, int& diffMinute) {
    // å°†æ—¶é—´è½¬æ¢ä¸ºåˆ†é’Ÿæ•°
    int time1 = timeToMinutes(hour1, minute1);
    int time2 = timeToMinutes(hour2, minute2);

    // è®¡ç®—å·®å€¼
    int diffMinutes = time2 - time1;
    if (diffMinutes < 0) {
        diffMinutes += 24 * 60;  // è°ƒæ•´åˆ°å‰ä¸€å¤©
    }

    // å°†å·®å€¼è½¬æ¢ä¸ºå°æ—¶å’Œåˆ†é’Ÿ
    diffHour = diffMinutes / 60;
    diffMinute = diffMinutes % 60;
}

int main() {
    int hour1, minute1, hour2, minute2;
    cout << "Enter first time (hour and minute): ";
    cin >> hour1 >> minute1;
    cout << "Enter second time (hour and minute): ";
    cin >> hour2 >> minute2;

    int diffHour, diffMinute;
    calculateTimeDifference(hour1, minute1, hour2, minute2, diffHour, diffMinute);

    cout << "Time difference: " << diffHour << " hours " << diffMinute << " minutes" << endl;

    return 0;
}

```



# æ•°ç»„

### åŠ›æ‰£1ä¸¤æ•°ä¹‹å’Œ

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target  çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ åœ¨ç­”æ¡ˆé‡Œä¸èƒ½é‡å¤å‡ºç°ã€‚

ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚

```c++
//è§£é¢˜æ€è·¯ï¼šæ’å…¥åˆ°å“ˆå¸Œè¡¨ä¸­å»
struct hashTable {
    int key;
    int val;
    UT_hash_handle hh;
};

//å…¨å±€å˜é‡ï¼Œæ–¹ä¾¿å†twosumå‡½æ•°ä¸­æ“ä½œ
struct hashTable* hashtable;

//ç»“æ„ä½“å‡½æ•°
struct hashTable* find(int ikey) {
    struct hashTable* tmp;
    HASH_FIND_INT(hashtable, &ikey, tmp);
    return tmp;
}

void insert(int ikey, int ival) {
    struct hashTable* it = find(ikey);
    if (it == NULL) {
        struct hashTable* tmp = malloc(sizeof(struct hashTable));
        tmp->key = ikey, tmp->val = ival;
        HASH_ADD_INT(hashtable, key, tmp);
    }
}

int* twoSum(int* nums, int numsSize, int target, int* returnSize)
{
    hashtable = NULL;
    for (int i = 0; i < numsSize; i++) 
    {
        //å…ˆå¯»æ‰¾å“ˆå¸Œè¡¨ä¸­æ˜¯å¦æœ‰target-nums[i]
        //å¦‚æœå­˜åœ¨ï¼Œåˆ™å¯ä»¥ç›´æ¥è¿”å›ï¼Œå¦‚æœä¸å­˜åœ¨çš„è¯ï¼Œå°±æŠŠè¿™ä¸ªæ•°æ’å…¥åˆ°å“ˆå¸Œè¡¨ä¸­å»
        struct hashTable* it = find(target - nums[i]);
        if (it != NULL) 
        {
            int* ret = malloc(sizeof(int) * 2);
            ret[0] = it->val, ret[1] = i;
            *returnSize = 2;
            return ret;
        }
        insert(nums[i], i);
    }
    *returnSize = 0;
    return NULL;
}
```



### åŠ›æ‰£31ä¸‹ä¸€ä¸ªæ’åˆ—

å¦‚ä½•å¾—åˆ°è¿™æ ·çš„æ’åˆ—é¡ºåºï¼Ÿè¿™æ˜¯æœ¬æ–‡çš„é‡ç‚¹ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·æ¥åˆ†æï¼š

æˆ‘ä»¬å¸Œæœ›ä¸‹ä¸€ä¸ªæ•° æ¯”å½“å‰æ•°å¤§ï¼Œè¿™æ ·æ‰æ»¡è¶³ â€œä¸‹ä¸€ä¸ªæ’åˆ—â€ çš„å®šä¹‰ã€‚å› æ­¤åªéœ€è¦ å°†åé¢çš„ã€Œå¤§æ•°ã€ä¸å‰é¢çš„ã€Œå°æ•°ã€äº¤æ¢ï¼Œå°±èƒ½å¾—åˆ°ä¸€ä¸ªæ›´å¤§çš„æ•°ã€‚æ¯”å¦‚ 123456ï¼Œå°† 5 å’Œ 6 äº¤æ¢å°±èƒ½å¾—åˆ°ä¸€ä¸ªæ›´å¤§çš„æ•° 123465ã€‚
æˆ‘ä»¬è¿˜å¸Œæœ›ä¸‹ä¸€ä¸ªæ•° å¢åŠ çš„å¹…åº¦å°½å¯èƒ½çš„å°ï¼Œè¿™æ ·æ‰æ»¡è¶³â€œä¸‹ä¸€ä¸ªæ’åˆ—ä¸å½“å‰æ’åˆ—ç´§é‚»â€œçš„è¦æ±‚ã€‚ä¸ºäº†æ»¡è¶³è¿™ä¸ªè¦æ±‚ï¼Œæˆ‘ä»¬éœ€è¦ï¼š
åœ¨ å°½å¯èƒ½é å³çš„ä½ä½ è¿›è¡Œäº¤æ¢ï¼Œéœ€è¦ ä»åå‘å‰ æŸ¥æ‰¾
å°†ä¸€ä¸ª å°½å¯èƒ½å°çš„ã€Œå¤§æ•°ã€ ä¸å‰é¢çš„ã€Œå°æ•°ã€äº¤æ¢ã€‚æ¯”å¦‚ 123465ï¼Œä¸‹ä¸€ä¸ªæ’åˆ—åº”è¯¥æŠŠ 5 å’Œ 4 äº¤æ¢è€Œä¸æ˜¯æŠŠ 6 å’Œ 4 äº¤æ¢
å°†ã€Œå¤§æ•°ã€æ¢åˆ°å‰é¢åï¼Œéœ€è¦å°†ã€Œå¤§æ•°ã€åé¢çš„æ‰€æœ‰æ•° é‡ç½®ä¸ºå‡åºï¼Œå‡åºæ’åˆ—å°±æ˜¯æœ€å°çš„æ’åˆ—ã€‚ä»¥ 123465 ä¸ºä¾‹ï¼šé¦–å…ˆæŒ‰ç…§ä¸Šä¸€æ­¥ï¼Œäº¤æ¢ 5 å’Œ 4ï¼Œå¾—åˆ° 123564ï¼›ç„¶åéœ€è¦å°† 5 ä¹‹åçš„æ•°é‡ç½®ä¸ºå‡åºï¼Œå¾—åˆ° 123546ã€‚æ˜¾ç„¶ 123546 æ¯” 123564 æ›´å°ï¼Œ123546 å°±æ˜¯ 123465 çš„ä¸‹ä¸€ä¸ªæ’åˆ—
ä»¥ä¸Šå°±æ˜¯æ±‚ â€œä¸‹ä¸€ä¸ªæ’åˆ—â€ çš„åˆ†æè¿‡ç¨‹ã€‚



```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        if (n <= 1) {
            return;
        }
        int i = n - 2, j = n - 1, k = n - 1;
        // find: A[i] < A[j]
        while (i >= 0 && nums[i] >= nums[j]) {
            --i; --j;
        }
        if (i >= 0) { // ä¸æ˜¯æœ€åä¸€ä¸ªæ’åˆ—
            // find: A[i] < A[k]
            while (nums[i] >= nums[k]) {
                --k;
            }
            swap(nums[i], nums[k]);
        }
        // reverse A[j:end]
        i = j;
        j = n - 1;
        while (i < j) {
            swap(nums[i], nums[j]);
            ++i;
            --j;
        }
    }
};
```



# è´ªå¿ƒ

### [ä»é›¶å¼€å§‹å­¦è´ªå¿ƒç®—æ³•-CSDNåšå®¢](https://blog.csdn.net/qq_32400847/article/details/51336300?ops_request_misc=%7B%22request%5Fid%22%3A%22170970936516800226558001%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=170970936516800226558001&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-51336300-null-null.142^v99^pc_search_result_base1&utm_term=è´ªå¿ƒç®—æ³•&spm=1018.2226.3001.4187)



è´ªå¿ƒç®—æ³•æ˜¯ç‰¹æ®Šçš„åŠ¨æ€è§„åˆ’ï¼Ÿï¼Ÿï¼Ÿ

è´ªå¿ƒç®—æ³•æ±‚ç¡¬å¸ï¼Œåªè¦ç¡¬å¸ä¹‹é—´æ˜¯æ•´é™¤å…³ç³»



### ç»™å®šæ­£æ•´æ•°Nï¼Œæ±‚Nä¸ªNç›¸ä¹˜çš„ä¸ªä½æ•°

```c++
#include<iostream>
#include<vector>
using namespace std;

int func(int x) {
   vector<int> a(10);
   a[0] = 0;
   a[1] = 1;
   a[2] = 4;
   a[3] = 7;
   a[4] = 6;
   a[5] = 5;
   a[6] = 6;
   a[7] = 3;
   a[8] = 6;
   a[9] = 9;
   return a[x];
}

int main() {
    // å–è¾“å…¥çš„æ•°
    int n;
    cin >> n;
    
    // è®¡ç®—ä¸ªä½æ•°
    int ge = n % 10;
    
    // è°ƒç”¨å‡½æ•°å¹¶è¾“å‡ºç»“æœ
    cout << func(ge); 
    
    return 0;
}

```

### ç‰¹æ®Šçš„æ–æ³¢é‚£å¥‘

**æœ‰ä¸€ç§fibonacciæ•°åˆ—ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š**

**f(0)=7,f(1)=11,f(n)=f(n-1)+f(n-2),ç»™å®šä¸€ä¸ªn(n<1000000),è¯·åˆ¤æ–­f(n)èƒ½å¦è¢«3æ•´é™¤**

(a+b)%3=(a%3+b%3)%3

f(0) = 7 % 3 = 1 

f(1) = 11 % 3 = 2 

f(2) = f(1) + f(0) = 2 + 1 = 3 % 3 = 0

f(3) = f(2) + f(1) = 0 + 2 = 2 

f(4) = f(3) + f(2) = 2 + 0 = 2 

f(5) = f(4) + f(3) = 2 + 2 = 4 % 3 = 1 

f(6) = f(5) + f(4) = 1 + 2 = 3 % 3 = 0 

f(7) = f(6) + f(5) = 0 + 1 = 1

å‘¨æœŸä¸º8.

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
using namespace std;
bool func(int m) {
    if (m == 2 || m == 6) {
        return true;
   }
    return false;
    
}

int main() {
    //æ€è·¯ï¼šä¸ªä½æ•°åªå’Œä¸ªä½æ•°ç›¸å…³
    int n;
    cin >> n;
    int m = n % 8;
   
    cout << func(m); 
    return 0;
}

```



### æ±‚A^Bçš„æœ€åä¸‰ä½è¡¨ç¤ºçš„æ•´æ•°

```c++
#include <iostream>
using namespace std;

long long fastPowerIterative(long long base, long long exponent) {
    long long result = 1;
    while (exponent > 0) {
        if (exponent % 2 == 1)
            result *= base;
        base *= base;
        exponent /= 2;
    }
    return result;
}

int main() {
    long long base, exponent;
    cout << "è¯·è¾“å…¥åº•æ•°å’ŒæŒ‡æ•°: ";
    cin >> base >> exponent;
    long long res = fastPowerIterative(base, exponent);
    cout << res % 1000;
    return 0;
}

```

### åŠ›æ‰£1217ç©ç­¹ç 

æœäº†ç‹—å±é¢˜ç›®è¿™ä¹ˆç®€å•æˆ‘ä¸ä¼š

### åŠ›æ‰£402ç§»æ‰kä½æ•°å­—

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240306184035499.png" alt="image-20240306184035499" style="zoom: 67%;" />



è€ƒè™‘ä»å·¦å¾€å³å¢é‡çš„æ„é€ æœ€åçš„ç­”æ¡ˆã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªæ ˆç»´æŠ¤å½“å‰çš„ç­”æ¡ˆåºåˆ—ï¼Œæ ˆä¸­çš„å…ƒç´ ä»£è¡¨æˆªæ­¢åˆ°å½“å‰ä½ç½®ï¼Œåˆ é™¤ä¸è¶…è¿‡ k æ¬¡ä¸ªæ•°å­—åï¼Œæ‰€èƒ½å¾—åˆ°çš„æœ€å°æ•´æ•°ã€‚æ ¹æ®ä¹‹å‰çš„è®¨è®ºï¼šåœ¨ä½¿ç”¨ kä¸ªåˆ é™¤æ¬¡æ•°ä¹‹å‰ï¼Œæ ˆä¸­çš„åºåˆ—ä»æ ˆåº•åˆ°æ ˆé¡¶å•è°ƒä¸é™ã€‚

å› æ­¤ï¼Œå¯¹äºæ¯ä¸ªæ•°å­—ï¼Œå¦‚æœè¯¥æ•°å­—å°äºæ ˆé¡¶å…ƒç´ ï¼Œæˆ‘ä»¬å°±ä¸æ–­åœ°å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œç›´åˆ°

1. æ ˆä¸ºç©º

2. æˆ–è€…æ–°çš„æ ˆé¡¶å…ƒç´ ä¸å¤§äºå½“å‰æ•°å­—
3. æˆ–è€…æˆ‘ä»¬å·²ç»åˆ é™¤äº† kkk ä½æ•°å­—

ä¸Šè¿°æ­¥éª¤ç»“æŸåæˆ‘ä»¬è¿˜éœ€è¦é’ˆå¯¹ä¸€äº›æƒ…å†µåšé¢å¤–çš„å¤„ç†ï¼š

å¦‚æœæˆ‘ä»¬åˆ é™¤äº† m ä¸ªæ•°å­—ä¸” m<km<km<kï¼Œè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦ä»åºåˆ—å°¾éƒ¨åˆ é™¤é¢å¤–çš„ kâˆ’mk-mkâˆ’m ä¸ªæ•°å­—ã€‚

1. å¦‚æœæœ€ç»ˆçš„æ•°å­—åºåˆ—å­˜åœ¨å‰å¯¼é›¶ï¼Œæˆ‘ä»¬è¦åˆ å»å‰å¯¼é›¶ã€‚
2. å¦‚æœæœ€ç»ˆæ•°å­—åºåˆ—ä¸ºç©ºï¼Œæˆ‘ä»¬åº”è¯¥è¿”å› 0ã€‚
3. æœ€ç»ˆï¼Œä»æ ˆåº•åˆ°æ ˆé¡¶çš„ç­”æ¡ˆåºåˆ—å³ä¸ºæœ€å°æ•°ã€‚

è€ƒè™‘åˆ°æ ˆçš„ç‰¹ç‚¹æ˜¯åè¿›å…ˆå‡ºï¼Œå¦‚æœé€šè¿‡æ ˆå®ç°ï¼Œåˆ™éœ€è¦å°†æ ˆå†…å…ƒç´ ä¾æ¬¡å¼¹å‡ºç„¶åè¿›è¡Œç¿»è½¬æ‰èƒ½å¾—åˆ°æœ€å°æ•°ã€‚ä¸ºäº†é¿å…ç¿»è½¬æ“ä½œï¼Œå¯ä»¥ä½¿ç”¨åŒç«¯é˜Ÿåˆ—ä»£æ›¿æ ˆçš„å®ç°ã€‚

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        vector<char> stk;
        for (auto& digit: num) {
            while (stk.size() > 0 && stk.back() > digit && k) {
                stk.pop_back();
                k -= 1;
            }
            stk.push_back(digit);
        }

        for (; k > 0; --k) {
            stk.pop_back();
        }

        string ans = "";
        bool isLeadingZero = true;
        for (auto& digit: stk) {
            if (isLeadingZero && digit == '0') {
                continue;
            }
            isLeadingZero = false;
            ans += digit;
        }
        return ans == "" ? "0" : ans;
    }
};


```

### åŠ›æ‰£605ç§èŠ±é—®é¢˜

1.å¯¹äºä¸¤æœµå·²ç»ç§èŠ±ä¸”ä¸­é—´æ²¡æœ‰ç§èŠ±çš„åˆ‡ç‰‡:å®ƒä»¬ä¹‹é—´å¯ä»¥ç§èŠ±çš„èŒƒå›´æ˜¯[i+2,j-2],æ­¤æ—¶å¯ä»¥ç§èŠ±çš„æ ¼å­æ•°æ˜¯j-i-3ã€‚å‡è®¾æœ‰kä¸ªç©ºæ ¼ç§èŠ±ï¼Œå¯ä»¥ç§èŠ±çš„ä¸ªæ•°æ˜¯ï¼ˆk+1ï¼‰/2,æ‰€ä»¥åœ¨i,jä¹‹é—´å¯ä»¥ç§çš„èŠ±æ˜¯ï¼ˆj-i-2ï¼‰/2ã€‚

2.åœ¨ç¬¬ä¸€ä¸ªç§èŠ±ä¹‹å‰çš„åˆ‡ç‰‡ï¼šç¬¬ä¸€æœµä¸‹æ ‡i,åˆ™å¯ä»¥ç§i/2æœµèŠ±

3.åœ¨æœ€åä¸€æœµèŠ±åˆ°æœ«å°¾ï¼ŒåŒä¸Šï¼Œä»¤æœ€åä¸€æœµèŠ±çš„ä½ç½®æ˜¯r,èŠ±å›æ€»é•¿m,åˆ™å¯ä»¥ç§ï¼ˆm-r-1ï¼‰/2æœµèŠ±

åŸºäºä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬å¯ä»¥éå†èŠ±å›æ•°ç»„ï¼Œå¯¹äºç¬¬ä¸€ç§æƒ…å†µï¼Œæˆ‘ä»¬è®¾ç½®å¼€å¤´æ˜¯-1

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int count=0;//è®¡æ•°
        int prev=-1;//è¡¨ç¤ºå¼€å¤´
        int m=flowerbed.size();
        for(int i=0;i<m;i++){
            if(flowerbed[i]==1){
                if(prev<0){
                    count+=i/2;     
                }
                else{
                    count+=(i-prev-2)/2;
                }
                prev=i;
            }
        }
        if(prev<0){
            //ä¸€æœµèŠ±ä¹Ÿæ²¡ç§
            count+=(m+1)/2;
        }
        else{
            count+=(m-prev-1)/2;
        }

        return count>=n;
    }
       

};


```

### åŠ›æ‰£608éªŒè¯å›æ–‡ä¸²

æˆ‘ä»¬å‘ç°ï¼šæœ€å¤–å±‚çš„ä¸¤ä¸ªå­—æ¯å¦‚æœä¸åŒï¼Œä¸€å®šä¸æ˜¯å›æ–‡ä¸²ï¼ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å¯ä»¥ç»§ç»­éå†å†…å±‚çš„å­—ä¸²ï¼Œè¿™å°±æ˜¯è´ªå¿ƒçš„æ€æƒ³ã€‚

å½“æˆ‘ä»¬å‘ç°æœ‰ä¸¤ä¸ªå­—æ¯ä¸åŒçš„æ—¶å€™ï¼Œ**å¿…é¡»åˆ é™¤ä¸€ä¸ªå­—æ¯**ï¼Œåˆ é™¤ä¹‹åï¼Œå…¶ä»–åºåˆ—æ˜¯å›æ–‡ä¸²ï¼Œå› ä¸ºæœ€å¤–å±‚å·²ç»æ˜¯å›æ–‡ä¸ç”¨è€ƒè™‘ï¼Œæ‰€ä»¥åªè¦åˆ¤æ–­å³è¾¹å’Œå·¦è¾¹æ˜¯å¦æœ‰ä¸€ä¸ªæ˜¯å›æ–‡ä¸²å°±å¥½ã€‚

```
class Solution {
public:
    bool ishuiwen(const string&s,int low,int high){
        for(int i=low,j=high;i<j;++i,--j){
            if(s[i]!=s[j]){
                return false;
            }
        }
        return true;
    }
    bool validPalindrome(string s) {
        //å¯¹äºä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯éƒ½æ˜¯å›æ–‡ä¸²ï¼Œå¯ä»¥å…ˆåˆ¤æ–­ä¸¤ç«¯æ˜¯å¦æ˜¯å­—ç¬¦ä¸²ï¼Œå¦‚æœæœ€å¤–éƒ¨éƒ½ä¸æ˜¯ï¼Œåˆ™ä¸€å®šä¸æ˜¯
        int low=0,high=s.size()-1;
        while(low<high){
            char c1=s[low],c2=s[high];
            if(c1==c2){
                low++;
                high--;
            }
            else{
                return ishuiwen(s,low+1,high)||ishuiwen(s,low,high-1);
            }
        }      
        return true;
    }
};
```

# æ·±åº¦ä¼˜å…ˆ

### [äº‘å‰ªè´´æ¿ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com)](https://www.luogu.com/paste/vjf2z3hi)



### 15å±Šè“æ¡¥æ¯æ•°å­—æ¥é¾™

```c++
#include <iostream>
#include <string>
using namespace std;
const int N = 20;
int map[N][N];//åœ°å›¾
bool vis[N][N];//çŠ¶æ€æ•°ç»„
string res;//å­˜æ”¾ç­”æ¡ˆ,è¾“å‡ºç¬¬ä¸€æ¬¡æœç´¢åˆ°çš„å­—ç¬¦ä¸²
//æœç´¢ä¸åˆ°ï¼Œè¾“å‡º-1ä¹Ÿæœ‰åˆ†
int dx[8] = {-1,-1,0,1,1,1,0,-1};//æ–¹å‘æ•°ç»„,ä¸‹æ ‡å’Œç»™å®šæ–¹å‘ä¸€è‡´
int dy[8] = {0,1,1,1,0,-1,-1,-1};

int n, k;
void dfs(int x, int y, int pre, string s, int dep) {
    if (x == n && y == n && dep == n * n) {
        //å¦‚æœæœç´¢åˆ°ç»ˆç‚¹å¹¶ä¸”æœç´¢æ·±åº¦ç­‰äºn*nï¼Œè¯´æ˜å·²ç»æœç´¢åˆ°ç»“å°¾ï¼Œæœç´¢ç»“æŸ
        if (res.empty()) res = s;//æ­¤æ—¶ä¸ºç©ºè¯´æ˜ä¸€å®šæ˜¯å­—å…¸åºæœ€å°çš„ï¼Œè¿”å›
        return;
    }

    for (int i = 0; i < 8; i++) {
        int a = x + dx[i], b = y + dy[i];
        if (a<1 || b<1 || a>n || b>n) continue;
        if (vis[a][b]) continue;

        //é˜²æ­¢äº¤å‰æœç´¢
        //æ€æƒ³æ˜¯ä¼šå‡ºç°äº¤å‰æœç´¢çš„æ˜¯1ã€3ã€5ã€7è¿™å››æ¡
        //å¦‚æœç›¸é‚»ç‚¹è¢«æ ‡è®°è¿‡ï¼Œè¯´æ˜è¢«äº¤å‰æœç´¢äº†
        if (i == 1 && vis[x - 1][y] && vis[x][y + 1]) continue;
        else if (i == 3 && vis[x + 1][y] && vis[x][y+1]) continue;
        else if (i == 5 && vis[x+1][y] && vis[x][y-1]) continue;
        else if (i == 7 && vis[x-1][y] && vis[x][y - 1]) continue;

        //ä¿è¯æœç´¢æ–¹å‘æ˜¯0ï¼Œ1ï¼Œ2ï¼Œk-1...
        if ((map[a][b] < k && map[a][b] == pre + 1) || (pre+1==k &&map[a][b]==0)) {
            //å¼€å§‹æœç´¢
            vis[a][b] = true;
            dfs(a, b, map[a][b], s + to_string(i), dep + 1);

            //æœ€ä¼˜æ€§å‰ªæ
            if (!res.empty()) return;//å¦‚æœç»“æœå­—ç¬¦ä¸²éç©ºï¼Œé€å±‚è¿”å›
            
            vis[a][b] = false;//æœ¬é¢˜å¿…é¡»å¼•å…¥å›æº¯

        }
    }
}

int main() {
    //é¦–å…ˆä½ è¦æŠŠé¢˜ç›®éƒ½æ¸…æ¥š
    //é¢˜ç›®éƒ½ä¸æ¸…æ¥šæ€ä¹ˆæ¨¡æ‹Ÿå‘¢ï¼Ÿ
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> map[i][j];
        }
    }

    string emp;
    vis[1][1] = 1;
    
    //å‚æ•°åˆ†åˆ«æ˜¯ä¸‹æ ‡x,y,æœç´¢åºåˆ—ï¼Œæ‹¼æ¥å­—ç¬¦ä¸²å’Œæœç´¢æ·±åº¦
    dfs(1, 1, 0, emp, 1);
    if (res.empty()) cout << -1 << endl;
    else cout << res << endl;

    
    return 0;
}

```



### åŠ›æ‰£99æ¢å¤äºŒå‰æœç´¢æ ‘

ç©ºé—´å¤æ‚åº¦ä¸º0nçš„åšæ³•

```c++
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& nums) {
        if (root == nullptr) {
            return;
        }
        inorder(root->left, nums);
        nums.push_back(root->val);
        inorder(root->right, nums);
    }

    pair<int,int> findTwoSwapped(vector<int>& nums) {
        int n = nums.size();
        int index1 = -1, index2 = -1;
        for (int i = 0; i < n - 1; ++i) {
            if (nums[i + 1] < nums[i]) {
                index2 = i + 1;
                if (index1 == -1) {
                    index1 = i;
                } else {
                    break;
                }
            }
        }
        int x = nums[index1], y = nums[index2];
        return {x, y};
    }
    
    void recover(TreeNode* r, int count, int x, int y) {
        if (r != nullptr) {
            if (r->val == x || r->val == y) {
                r->val = r->val == x ? y : x;
                if (--count == 0) {
                    return;
                }
            }
            recover(r->left, count, x, y);
            recover(r->right, count, x, y);
        }
    }

    void recoverTree(TreeNode* root) {
        vector<int> nums;
        inorder(root, nums);
        pair<int,int> swapped= findTwoSwapped(nums);
        recover(root, 2, swapped.first, swapped.second);
    }
};


```

### åŠ›æ‰£110åˆ¤æ–­å¹³è¡¡äºŒå‰æ ‘

```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return depth(root)!=-1;
    }
    int depth(TreeNode*root){
        if(root==nullptr) return 0;
        int left =depth(root->left);
        if(left==-1) return -1;
        int right=depth(root->right);
        if(right==-1) return -1;
        return abs(left-right)<2?max(left,right)+1:-1;    
    }
};
```



### åŠ›æ‰£113è·¯å¾„æ€»å’Œ

```c++
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;

    void dfs(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return;
        }
        path.emplace_back(root->val);
        targetSum -= root->val;
        if (root->left == nullptr && root->right == nullptr && targetSum == 0) {
            ret.emplace_back(path);
        }
        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        path.pop_back();//å›æº¯
    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }
};


```



### åŠ›æ‰£114äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        // ç®—æ³•ä¹‹ç¥ä¿ä½‘ï¼
        // å·¦å­æ ‘ä¸ºç©ºï¼Œç›´æ¥è€ƒè™‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        while (root != nullptr) {
            if (root->left == nullptr) {
                root = root->right;
            } else {
                TreeNode* pre = root->left;
                while (pre->right != nullptr) {
                    pre = pre->right;
                }
                pre->right = root->right;
                root->right = root->left;
                root->left = nullptr;
                root = root->right;
            }
        }
    }
};
```

### ACWingé€’å½’å®ç°ç»„åˆå‹æšä¸¾

åˆ†æä»£ç ï¼Œè§‰å¾—éš¾ç‚¹åœ¨äºæ€æ ·è¡¨ç¤ºæ¯æ¬¡æšä¸¾çš„æ•°éƒ½æ¯”å½“å‰å€¼è¦å¤§

æ¯”å¦‚ç¬¬ä¸€ä¸ªæ•°æ˜¯3ï¼Œé‚£ä¹ˆæˆ‘çš„ä¸‹ä¸€ä¸ªæ•°å¿…é¡»åœ¨4ï¼Œ5ä¸­é€‰

ä»£ç ä¸­å®šä¹‰äº†forå¾ªç¯ï¼Œå®šä¹‰äº†å˜é‡start,è§£å†³äº†è¯¥é—®é¢˜

```c++
#include<iostream>
using namespace std;
int n,r;
const int N=21;
int arr[N];
void dfs(int x,int start){
    if(x>r){
        for(int i=1;i<=r;i++){
            cout<<arr[i]<<' ';
        }
        cout<<endl;
        return;
    }
    
    for(int i=start;i<=n;i++){
        arr[x]=i;
        dfs(x+1,i+1);//æ¯æ¬¡é€’å½’ä¸€å®šæ˜¯ä¸‹ä¸€ä½ï¼Œä¿è¯æ•°æ®ä¸é‡å¤
        arr[x]=0;
    }
}
int main(){
    cin>>n>>r;
    dfs(1,1);
    return 0;
    
}
```



### ACWingé€’å½’å®ç°æ’åˆ—å‹æšä¸¾

é€’å½’æ ‘ä¾æ®ï¼šä¸€æ¬¡æšä¸¾æ¯ä¸ªä½ç½®åº”è¯¥æ”¾å“ªä¸ªæ•°

å…¨æ’åˆ—è¦æ±‚æ•°å­—ä¸å…è®¸é‡å¤ï¼Œä½†æ˜¯æœ‰äº›é¢˜ç›®ï¼š

æ¯”å¦‚æœ‰æ˜¯ä¸ªä½ç½®ï¼Œè¦æ±‚æˆ‘ä»¬åªå¡«3ä¸ªæ•°çš„è¯ï¼Œé‚£å°±å¯ä»¥æœ‰é‡å¤æ•°å­—  

```c++
#include<iostream>
using namespace std;
const int N=20;
int n;
int st[N];
int arr[N];
void dfs(int x){
    if(x>n){
        for(int i=1;i<=n;i++){
            cout<<arr[i]<<" ";
        }
        cout<<endl;
    }
    for(int i=1;i<=n;i++){
        if(!st[i]){//å¦‚æœè¿™ä¸ªæ•°è¿˜æ²¡æœ‰è¢«é€‰è¿‡
            st[i]=1;
            arr[x]=i;
            dfs(x+1);
            st[i]=0;
            arr[x]=0;
        }
    }
}
int main(){
    cin>>n;
    dfs(1);
    return 0;
}
```



### ACWingé€’å½’å®ç°æŒ‡æ•°å‹æšä¸¾

æœ¬é¢˜è®¾ç½®äº†ä¸‰ç§çŠ¶æ€ï¼Œåˆ†åˆ«æ˜¯1é€‰å–ï¼Œ2ä¸é€‰ï¼Œ0å¾…å®šï¼Œåˆ†æé—®é¢˜æ—¶å¯çŸ¥æ¯ä¸ªæ•°å­—åªæœ‰è¿™ä¸‰ç§æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬å¯¹æ¯ä¸ªæ•°å­—æšä¸¾è¿™ä¸‰ä¸ªå€¼ï¼Œä½†æ˜¯æšä¸¾ä¸‹ä¸€ä¸ªå€¼ä¹‹å‰éœ€è¦æ¢å¤ç°åœº

```c++
#include<iostream>
using namespace std;
int n;
const int N = 20;
int arr[N];

void dfs(int x) {
    if (x > n) {
        for (int i = 1; i <= n; i++) {
            if (arr[i] == 1) {
                cout << i << ' ';
            }
        }
        cout << endl;
        return;
    }
    
    //è®°å¾—å›æº¯
    arr[x] = 1;
    dfs(x + 1);
    arr[x] = 0;
    /*
åœ¨è¿™ä¸ªç‰¹å®šçš„ä»£ç ä¸­ï¼Œarr[x] = 0; è¿™ä¸€è¡Œå¯ä»¥çœç•¥ã€‚å› ä¸ºåœ¨æ¯æ¬¡è°ƒç”¨ dfs å‡½æ•°æ—¶ï¼Œarr æ•°ç»„éƒ½ä¼šè¢«é‡ç½®ä¸ºå…¨é›¶ï¼Œæ‰€ä»¥åœ¨é€’å½’å›æº¯çš„è¿‡ç¨‹ä¸­ï¼Œarr[x] çš„å€¼ä¸ä¼šä¿ç•™åˆ°ä¸‹ä¸€æ¬¡è°ƒç”¨ dfs å‡½æ•°ã€‚ä½†æ˜¯åœ¨æ›´å¤æ‚çš„æƒ…å†µä¸‹ï¼Œå¦‚æœåœ¨é€’å½’å›æº¯çš„è¿‡ç¨‹ä¸­éœ€è¦ä¿æŒ arr æ•°ç»„çš„æŸäº›ç‰¹å®šçŠ¶æ€ï¼Œé‚£ä¹ˆè¿™ä¸€è¡Œä¸èƒ½çœç•¥ã€‚*/

    arr[x] = 2;
    dfs(x + 1);
    arr[x] = 0;

}
int main() {
    cin >> n;
    dfs(1);
    return 0;

}
```



### æ´›è°·p1036é€‰æ•°

```c++
#include<iostream>
using namespace std;
const int N=30;
int n,k;
int arr[N];
int choose[N];
int res=0;

bool is_prime(int sum){
    for(int i=2;i<sum/i;i++){
        if(sum%i==0) return false;
    }
    return true;
}
void dfs(int x,int start){
    
    if(x>k){
        int sum=0;
        for(int i=1;i<=k;i++){
            sum+=choose[i];
        }
        if(is_prime(sum)) res++;
        return;
        
    }
    for(int i=start;i<=n;i++){//ç”¨ä¸‹æ ‡è¡¨ç¤ºstartï¼Œä½†æ˜¯å®é™…ä¸Šæ˜¯arr[i]
        choose[x]=arr[i];//ç»„åˆå‹æšä¸¾çš„ç®€å•åº”ç”¨è¾£å•¦
        dfs(x+1,i+1);
        choose[x]=0;
    }
}
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
    }
    //ç»„åˆæ•°
    dfs(1,1);
    cout<<res;
    return 0;
    
}
```



### æ´›è°·p1088ç«æ˜Ÿäºº

//å…¨æ’åˆ—æ¨¡æ¿

//è®¾ç½®çŠ¶æ€æ•°ç»„å’Œç­”æ¡ˆæ•°ç»„

//åŒæ—¶æ³¨æ„åˆ°ï¼Œå› ä¸ºåˆšå¼€å§‹éå†çš„æ—¶å€™ä¸ä¸€å®šæ˜¯ä»æœ€å°å¼€å§‹ï¼Œè¾“å…¥äº†marsæ•°ç»„ï¼Œæˆ‘ä»¬è®©iä»mars[x]å¼€å§‹éå†

//æ‰¾åˆ°ä¹‹åå¯ä»¥åœæ­¢ç¨‹åº

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
int N, M;
int mars[10010];
int st[10010];
int arr[10010];
int res = 0;
int return0 = 0;
void dfs(int x) {
    if (return0 == 1) {
        return;
    }
    if (x > N) {
        res++;
        if (res == M + 1) {
            return0 = 1;
            for (int i = 1; i <= N; i++) {
                printf("%d ", arr[i]);
            }
        }
    }
    for (int i = 1; i <= N; i++) {
        if (res == 0) {
            i = mars[x];
        }
            if (!st[i]) {
                st[i] = 1;
                arr[x] = i;
                dfs(x + 1);
                st[i] = 0;
                arr[x] = 0;
            }
        }
    }

int main() {
    cin >> N;
    cin >> M;
    for (int i = 1; i <= N; i++) {
        scanf("%d",&mars[i]);
    }
    dfs(1);
}
```





è™½ç„¶ä½†æ˜¯ï¼ŒSTLä½ æ˜¯æˆ‘çš„ç¥ï¼Œæ¯”èµ›å°±ç”¨ä½ ï¼ï¼ï¼

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	int N,M;
	string s="";
	cin>>N;
	cin>>M;
	char ch;
	for(int i=0;i<N;i++){
		cin>>ch;
		s+=ch;
	}
	while(M--){
		next_permutation(s.begin(),s.end());
	}
	cout<<s;
    return 0;
}

```



### æ´›è°·p2089çƒ¤é¸¡

æˆ‘ä»¬å‘ç°æ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªæ•°åªæœ‰ä¸‰ç§çŠ¶æ€ï¼Œå’ŒæŒ‡æ•°å‹æšä¸¾ç±»ä¼¼

```c++
#include<iostream>
#include<vector>
using namespace std;
const int N = 11;
int n;
vector<int>choose(11);
int res = 0;
int sum = 0;
vector<vector<int>>ans;


void dfs(int x)
{
    if (x > 10) {
        if (sum == n) {
            ans.push_back(choose);
            res += 1;
        }              
        return;
    }
    for (int i = 1; i <= 3; i++) {
        choose[x] = i;
        sum += i;
        if (sum <= n) {
            dfs(x + 1);
        }
        sum -= i;
    }
}

int main() {
    cin >> n;
    dfs(1);
    cout << res << endl;
    for (auto p : ans) {
        for (int i = 1; i <= 10; i++) {
            cout << p[i] << " ";
        }
        cout << endl;
    }
    
    return 0;
}

```



### p1149ç«æŸ´æ£’ç­‰å¼

æˆ‘çœŸç¬‘äº†ï¼Œè‡ªè®¤ä¸ºå¼€1000æ•°æ®å¤ªå¤§äº†ï¼Œç„¶åæ”¹å°äº†ï¼Œç­”æ¡ˆå°±ä¸å¯¹ï¼Œä¸è¦å¤ªé«˜å‚²äº†å•Šå•Šå•Šå•Šå•Š

```c++
#include<iostream>
using namespace std;
int n;

int ans;
int match[1000] = { 6,2,5,5,4,5,6,3,7,6 };
int arr[4];
void dfs(int x,int sum) {
	if (sum > n) return;//å‰ªæ 
	if (x > 3) {
		if (sum == n && arr[1] + arr[2] == arr[3])  ans++;
		return;
		
	}

	for (int i = 0; i < 1000; i++) {
		arr[x] = i;	
		dfs(x + 1,sum+match[i]);
	}


}
int main() {
	cin >> n;
	n -= 4;
	for (int i = 10; i <1000; i++) {
		match[i] = match[i % 10] + match[i / 10];
	}
	dfs(1,0);
	cout << ans;

	return 0;

}
```



### æ´›è°·p2036

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
int n;
bool tl = false;
int difference = INT32_MAX;

int arr[11];
int brr[11];
int choosea[11];
int chooseb[11];

void dfs(int x) {
    if (x > n) {
        int sour = 1, ku = 0;
        for (int i = 1; i <= n; i++) {       
            if (choosea[i] == 1 && chooseb[i] == 1) {
                tl = true;
                sour *= arr[i];
                ku += brr[i];
            }
        }
        if (tl==true) {
            int d = abs(sour - ku);
            difference = min(d, difference);
            tl = false;
        }

        return;

    }

    choosea[x] = 1;
    chooseb[x] = 1;
    dfs(x + 1);
    choosea[x] = 0;
    chooseb[x] = 0;

    choosea[x] = 2;
    chooseb[x] = 2;
    dfs(x + 1);
    choosea[x] = 0;
    chooseb[x] = 0;

}


int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &arr[i], &brr[i]);
    }
    dfs(1);
    cout << difference;
    return 0;
}
```



### æ´›è°·p1135

dfsè¶…æ—¶ï¼Œæˆ‘è¯·é—®å‘¢ï¼Œéè¦å¡ä¸€ä¸ªæ•°æ®å‘œå‘œå‘œ

```c++
#include<iostream>
using namespace std;
int N,A,B;
int arr[210];
int res=1e9;
bool st[210];//è®¾ç½®çŠ¶æ€
//å‰ªæï¼Œå½“æ¯å±‚æ¥¼åªå»è¿‡ä¸€æ¬¡ï¼Œæ˜¯æœ€å¥½çš„çŠ¶æ€
//xä»£è¡¨å½“å‰å±‚æ•°ï¼Œcntè¡¨ç¤ºæŒ‰æŒ‰é’®çš„æ¬¡æ•°
void dfs(int x,int cnt){
    if(cnt>=res){
        //å‰ªæ
        return ;
    }
    
    if(x<0||x>N) return ;
    if(x==B){
        res=min(res,cnt);
        return;
    }
    
    //bfsçš„ç²¾é«“å°±æ˜¯æš´åŠ›æœç´¢
    //æ‰€ä»¥å½“x+arr[x]<nçš„æ—¶å€™éƒ½å¯ä»¥è¿›è¡Œæœç´¢ä½ 
    if(arr[x]+x<=N&&!st[x+arr[x]]){
        st[x+arr[x]]=true;
        dfs(x+arr[x],cnt+1);
        st[x+arr[x]]=false;
    }
    
    if(x-arr[x]>0){
         st[x-arr[x]]=true;
        dfs(x-arr[x],cnt+1);
        st[x-arr[x]]=false;
    }
    
}
int main(){
    cin>>N>>A>>B;
    
    for(int i=1;i<=N;i++){
        scanf("%d",&arr[i]);
    }
    
    dfs(A,0);
    if(res==1e9) 
    {cout<<"-1";
    return 0;
    }
    cout<<res;

    return 0;
}

```



### åŠ›æ‰£257äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

```c++
//ä½¿ç”¨äº†æ·±åº¦ä¼˜å…ˆæœç´¢
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string>paths;
        func(root,"",paths);
        return paths;
    }
    void func(TreeNode*root,string path,vector<string>&paths){//è¿™é‡Œrootæ²¡æœ‰ç”¨å¼•ç”¨æ˜¯å› ä¸ºrootä¸éœ€è¦ä¿®æ”¹
        if(root!=nullptr){
            path+=to_string(root->val);
            if(root->left==nullptr&&root->right==nullptr){
                paths.push_back(path);
            }
            else{
                path+="->";
                func(root->left,path,paths);//è¿™é‡Œpathæ²¡æœ‰ç”¨å¼•ç”¨æ˜¯å› ä¸ºpathæ¯æ¬¡éƒ½æ˜¯+=ï¼Œæ„é€ äº†ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²æ’å…¥åˆ°pathsä¸­
                func(root->right,path,paths);
            }
        }
    }
};
```



### p1135å¥‡æ€ªçš„ç”µæ¢¯

æ·±åº¦ä¼˜å…ˆæœç´¢çš„æŒ‡æ•°å‹æšä¸¾æ¨¡å‹ï¼Œåªæœ‰ä¸Šä¸‹å’Œæœªç¡®å®šä¸‰ç§çŠ¶æ€

åˆ«äººå†™çš„dfs

```c++
#include<bits/stdc++.h>
using namespace std;
int n,a,b,k[201],dis[201];
void dfs(int node,int step){
	dis[node]=step;//ä¸€å®šå¯ä»¥æ›´æ–°
	int v=node-k[node];
	if(1<=v&&step+1<dis[v]/*å¯ä»¥æ›´æ–°åœ¨æœç´¢*/)//ä¸‹
		dfs(v,step+1);
	v=node+k[node];
	if(v<=n&&step+1<dis[v])//ä¸Š
		dfs(v,step+1);
	return;
}
int main(){
	memset(dis,0x3f,sizeof(dis));
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)
		cin>>k[i];
	dfs(a,0);
	cout<<(dis[b]==0x3f3f3f3f?-1:dis[b]);
	return 0;
}==
```



```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 210;
int a[N];    //æ¯å±‚æ¥¼è‡³å¤šèµ°ä¸€æ¬¡ä¸ºæ¬¡æ•°æœ€å°‘
int start, end1, n;
bool find1 = false;
int st[N];
int res=1e9;
void dfs(int i, int sum)
{
    if (sum < 1 ||sum > n||i>=res) return;
    else if (sum == end1)
    {
        find1 = true;
        res=min(res,i);
        return;
    }
    else{ 
        if(st[sum]>i||st[sum]==0) 
        {
            st[sum]=i;
            dfs(i + 1, sum + a[sum]);   //ç”µæ¢¯ä¸Šè¡Œ 
            dfs(i + 1, sum - a[sum]);//ç”µæ¢¯ä¸‹è¡Œ
        }
        else return;
    }
}
int main()
{
    scanf("%d %d %d", &n, &start, &end1);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    dfs(0, start);
    if (!find1) printf("-1");
    else printf("%d",res);
    return 0;
}
```



## è¿·å®«æ¨¡å‹

### æ´›è°·p1683è¿·å®«æ¨¡å‹

1. **çŠ¶æ€è¡¨ç¤º**ï¼šé¦–å…ˆéœ€è¦å®šä¹‰è¿·å®«çš„çŠ¶æ€è¡¨ç¤ºã€‚å¸¸è§çš„æ–¹æ³•æ˜¯ä½¿ç”¨äºŒç»´æ•°ç»„ï¼Œå…¶ä¸­0è¡¨ç¤ºå¯é€šè¡Œçš„è·¯å¾„ï¼Œ1è¡¨ç¤ºå¢™å£æˆ–ä¸å¯é€šè¡Œçš„åŒºåŸŸã€‚åŒæ—¶éœ€è¦ä¸€ä¸ªèµ·ç‚¹å’Œç»ˆç‚¹è¡¨ç¤ºå…¥å£å’Œå‡ºå£çš„ä½ç½®ã€‚
2. **é€’å½’æœç´¢**ï¼šä»èµ·ç‚¹å¼€å§‹ï¼ŒæŒ‰ç…§ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘è¿›è¡Œé€’å½’æœç´¢ã€‚æ¯æ¬¡ç§»åŠ¨åˆ°ä¸€ä¸ªæ–°ä½ç½®æ—¶ï¼Œéƒ½ä¼šæ£€æŸ¥æ˜¯å¦åˆ°è¾¾äº†ç»ˆç‚¹ã€‚å¦‚æœæ²¡æœ‰åˆ°è¾¾ç»ˆç‚¹ï¼Œåˆ™ç»§ç»­ä»å½“å‰ä½ç½®è¿›è¡Œæœç´¢ã€‚
3. **å›æº¯æ¡ä»¶**ï¼šåœ¨æœç´¢è¿‡ç¨‹ä¸­ï¼Œå¦‚æœé‡åˆ°æ­»è·¯æˆ–è€…å·²ç»è®¿é—®è¿‡çš„ä½ç½®ï¼Œå°±éœ€è¦è¿›è¡Œå›æº¯ã€‚è¿™æ—¶ä¼šè¿”å›åˆ°å‰ä¸€ä¸ªä½ç½®ï¼Œå°è¯•å…¶ä»–æ–¹å‘çš„è·¯å¾„ã€‚
4. **è®°å½•è·¯å¾„**ï¼šä¸ºäº†é¿å…é‡å¤èµ°åŒä¸€æ¡è·¯å¾„ï¼Œéœ€è¦è®°å½•å·²ç»è®¿é—®è¿‡çš„ä½ç½®ã€‚ä¸€ç§å¸¸è§çš„åšæ³•æ˜¯ç”¨2æ¥æ ‡è®°å·²ç»èµ°è¿‡çš„å¯é€šè¡Œè·¯å¾„ã€‚
5. **æ±‚è§£æ–¹æ³•**ï¼šé™¤äº†å›æº¯æ³•ï¼Œè¿˜å¯ä»¥ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰æˆ–å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ç­‰å…¶ä»–å›¾æœç´¢ç®—æ³•æ¥è§£å†³è¿·å®«é—®é¢˜ã€‚æ¯ç§æ–¹æ³•éƒ½æœ‰å…¶ä¼˜ç¼ºç‚¹ï¼Œä¾‹å¦‚DFSåŠ å›æº¯å¯èƒ½ä¸ä¼šç›´æ¥æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼Œè€ŒBFSå¯ä»¥æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼Œä½†éœ€è¦è®°å½•æ›´å¤šçš„èŠ‚ç‚¹ä¿¡æ¯ã€‚

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
const int N = 30;
int W, H;
char map[N][N];
int st[N][N];//è®°å½•çŠ¶æ€
int res;
int mx[4] = { -1,0,1,0 };
int my[4] = { 0,1,0,-1 };
void dfs(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int lx = x + mx[i];
        int ly = y + my[i];
        if (lx < 0 || lx > H || ly < 0 || ly >=W) continue;
        if (st[lx][ly]) continue;
        if (map[lx][ly] != '.')continue;
        st[lx][ly] = 1;
        res++;
        dfs(lx,ly);        
    }
}

int main() {
    int x, y;
    scanf("%d %d", &W, &H);
    for (int i = 0; i < H; i++) {
        scanf("%s", map[i]);
    }
    for (int i = 0; i < H; i++) {
        for (int j = 0; j < W; j++) {
            if (map[i][j] == '@') {
               
                st[i][j] = 1;
                dfs(i, j);
                break;
            }
        }
    }

    printf("%d", ++res);
    return 0;
}
```

### æ´›è°·p1596æ´ªæ°´å¡«å……æ¨¡å‹

å…«è¿é€šæŒ‡çš„æ˜¯å¯ä»¥èµ°æ–œçº¿ï¼Œå¥½æš´åŠ›çš„åšæ³•...æ‰€ä»¥dfsåªèƒ½ç”¨äºä¸€äº›æ•°æ®è¾ƒå°‘çš„åœ°æ–¹å§

```c++
#include<iostream>
#include<string>
using namespace std;
const int n = 100;
int N, M;
int mx[] = { 1,1,1,0,0,-1,-1,-1 };
int my[] = { -1,0,1,1,-1,1,0,-1 };
bool st[n][n];
string s[n];
int res;
void dfs(int x, int y) {

    for (int i = 0; i < 8; i++) {
        int lx = x + mx[i];
        int ly = y + my[i];
        if (lx < 0 || lx >= N || ly < 0 || ly >= M) continue;
        if (s[lx][ly] != 'W') continue;
        if (st[lx][ly]) continue;
        st[lx][ly] = true;
        dfs(lx, ly);//ä¸éœ€è¦å›æº¯ï¼Œæ´ªæ°´æ¨¡å‹ï¼Œè¦†æ°´éš¾æ”¶
    }

}
int main() {
    cin >> N >> M;
    for (int i = 0; i < N; i++) {
        cin >> s[i];
    }

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (s[i][j] == 'W' && !st[i][j]) {
                //æ‰¾åˆ°äº†ç¬¬ä¸€ä¸ªw
                s[i][j]=true;
                dfs(i, j);
                res++;
            }
        }
    }
    cout << res;
    return 0;
}

```



### ACW1114æ£‹ç›˜é—®é¢˜

å¯¹äºæœ¬é¢˜ï¼Œæˆ‘ä»¬è‡ªç„¶æƒ³åˆ°çš„æ˜¯é‡åˆ°ä¸€ä¸ªå¯ä»¥æ”¾æ£‹å­çš„ä½ç½®ï¼Œæ”¾æ£‹å­ï¼Œç„¶ååˆ°å…¶ä»–è¡Œå¹¶ä¸”å…¶ä»–åˆ—çš„åœ°æ–¹å»æ‰¾ç¬¬äºŒä¸ªå¯ä»¥æ”¾æ£‹å­çš„ä½ç½®ã€‚



```c++
#include<iostream>
#include<string>
using namespace std;
const int N = 10;
int n,k,cnt;
bool st[N];
int res;
string arr[N];//è®°å½•ç­”æ¡ˆçš„æ•°ç»„
void dfs(int x,int cnt) {
    if(cnt==k){
        res++;
        return;
    }
    
    if(x>n) return;
    for (int i = 0; i <n; i++) {
        if(!st[i]&&arr[x][i]=='#'){//è¿™é‡Œçš„iè¡¨ç¤ºåˆ—ï¼ï¼
            st[i]=true;
            dfs(x+1,cnt+1);
            st[i]=false;
        }
    }
    
    dfs(x+1,cnt);
}
int main() {
    while( cin >> n>>k,n>0&&k>0){
        for(int i=1;i<=n;i++){
            cin>>arr[i];
        }
        res=0;//æ³¨æ„è¿™é‡Œï¼Œå› ä¸ºæ˜¯å¤šç»„æ ·ä¾‹è¾“å‡ºï¼Œæ‰€ä»¥resè¦æ›´æ–°
        dfs(1,0);
        cout<<res<<endl;
    }

    return 0;
}

```



### æ´›è°·p1019

1. è®¾ç½®ä¸€ä¸ªè®°å½•å•è¯ä½¿ç”¨æ¬¡æ•°çš„æ•°ç»„ï¼Œä»¥ä¾¿åˆ¤æ–­å•è¯çš„ä½¿ç”¨æ¬¡æ•°æ˜¯å¦å¤§äº2
2. è®¾ç½®ä¸€ä¸ªæ•°ç»„æ¥è®°å½•å•è¯ä¹‹é—´çš„å¯æ‹¼æ¥çš„æœ€çŸ­é•¿åº¦ï¼Œå½“æ—¶æ˜¯æœ€çŸ­æ‹¼æ¥é•¿åº¦ï¼Œæ¯æ¬¡å–é‡åˆæœ€çŸ­çš„ï¼Œå¯ä»¥ä½¿å•è¯æœ€é•¿
3. å½“å¼€å§‹æ‰¾åˆ°é¾™çš„æ—¶å€™ï¼Œå¼€å§‹æš´åŠ›æœç´¢

```c++
#include<iostream>
#include<string>
using namespace std;
const int N = 20;
int n;
string arr[N];
int used[N];//æ¯ä¸ªæ•°ç»„ä½¿ç”¨çš„æ¬¡æ•°
int cnt[N][N];//å•è¯iä¸å•è¯jçš„å¯æ‹¼æ¥çš„é•¿åº¦
int ans;
void dfs(string s, int x) {
    ans = max(int(s.size()), ans);
    used[x]++;//å½“å‰å•è¯ä½¿ç”¨æ¬¡æ•°åŠ ä¸€
    for (int i = 0; i < n; i++) {
        if (cnt[x][i] && used[i] < 2) {//åˆ¤æ–­æ¡ä»¶ï¼Œå¦‚æœä¸¤ä¸ªå•è¯ä¹‹é—´å¯ä»¥æ‹¼æ¥å¹¶ä¸”è¿™ä¸ªå•è¯æ²¡æœ‰ä½¿ç”¨ä¸¤æ¬¡ä»¥ä¸Š
            dfs(s + arr[i].substr(cnt[x][i]), i);
        }
    }

    used[x]--;//å›æº¯ï¼Œå› ä¸ºè¦æ‰¾å‡ºæœ€é•¿è·ç¦»
}
int main() {
    char start;

    cin >> n;
    string dargon;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    cin >> start;//é¾™å¤´

    //é¢„å¤„ç†
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            string a = arr[i], b = arr[j];
            for (int k = 1; k < min(a.size(), b.size()); k++) {//æ³¨æ„è¿™é‡Œï¼Œkå¿…é¡»ä»1å¼€å§‹å–
                //æ‰¾åˆ°ä¸€ä¸ªå•è¯çš„åç¼€å’Œå¦ä¸€ä¸ªå•è¯çš„å‰ç¼€ç›¸åŒ
                if (a.substr(a.size() - k, k) == b.substr(0, k)) {
                    //ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„ä¸€å®šæ˜¯æœ€çŸ­çš„ï¼Œå› ä¸ºé»˜è®¤æœ€çŸ­é•¿åº¦æ˜¯1å¹¶ä¸”é€’å¢
                    cnt[i][j] = k;
                    break;
                }
            }

        }
    }

    for (int i = 0; i < n; i++) {
        if (arr[i][0] == start) {
            dfs(arr[i], i);//åˆ†åˆ«æ˜¯é¾™å’Œå½“å‰è®¿é—®åˆ°äº†å“ªä¸ªå•è¯
        }
    }
    cout << ans;
    return 0;
}
```



### æ´›è°·p1025

```c++
#include<iostream>
#include<string>
using namespace std;
int n, k;
int res;
int numsum;
int arr[210];
//ç»„åˆå‹ï¼Œä½†æ˜¯ä¸‹ä¸€æ¬¡å¼€å§‹æšä¸¾å¯ä»¥æ˜¯1
void dfs(int x, int start, int numsum) {
    if (x > k) {
        if (numsum == n) {
            res++;     
        }
          return;
    }


    for (int i = start;numsum+i*(k-x+1)<=n; i++) {//å› ä¸ºä¹‹ååˆ’åˆ†çš„ä¸€å®šå¤§äºç­‰äºiï¼Œå¦‚æœå‰©ä¸‹çš„ä½æ•°
        //å…¨æ˜¯içš„è¯è¿˜å¤§äºnï¼Œä¸€å®šä¸ç¬¦åˆæƒ…å†µ
        //æšä¸¾kä¸ªæ•°å­—
        arr[x] = i;
        dfs(x + 1, i, numsum+i);
        arr[x] = 0;
    }
}
int main() {
    cin >> n >> k;
    dfs(1, 1, 0);//ä»1,1å¼€å§‹æšä¸¾
    cout << res;
    return 0;
}

```

### æ´›è°·P1162

æ·±åº¦ä¼˜å…ˆå’Œå¹¿åº¦ä¼˜å…ˆç»“åˆå“¦

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
#include<string>
using namespace std;
typedef  pair<int, int> PII;
queue<PII> q;
const int n = 35;
int N;
int mx[] = { 0,1,0,-1 };
int my[] = { 1,0,-1,0 };
bool st[n][n];//çŠ¶æ€æ•°ç»„
int map[n][n];//åœ°å›¾
bool bfs(int x, int y) {
    q.push({ x,y });
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t.first == 1 || t.second == 1 || t.first == N || t.second == N) {
            //åˆ°è¾¾è¾¹ç•Œ
            return true;//å¯è¾¾
        }
        for (int i = 0; i < 4; i++) {
            int a = x + mx[i], b = y + my[i];
            if (map[a][b] == 1) continue;
            if (st[a][b]) continue;
            //ä¸å­˜åœ¨è¶Šç•Œé—®é¢˜
            st[a][b] = true;
            q.push({ a,b });
        }
    }
    return false;
}

void dfs(int x, int y) {
        for (int i = 0; i < 4; i++) {
            int a = x + mx[i], b = y + my[i];
            if (map[a][b]==2||map[a][b]==1) continue;
            if (a < 2 || b < 2 || a >= N || b >= N) continue;
            //if (st[a][b]) continue;
            //ä¸å­˜åœ¨è¶Šç•Œé—®é¢˜
            //st[a][b] = true;
            map[a][b] = 2;
            dfs(a, b);
        }
}
int main() {
    cin >> N;
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            scanf("%d", &map[i][j]);
        }
        
    }

    bool flag = false;
    for (int i = 1; i <= N; i++) {
        if (flag == true) break;
        for (int j = 1; j <= N; j++) {
            if (map[i][j] == 0 && i != 1 && i != N && j != 1 && j != N) {
                bool res=bfs(i, j);
               
                if (!res)
                {
                    map[i][j] = 2;
                    dfs(i, j);
                    flag = true;
                    break;
                }
                
            }
        }
    }

    cout << endl;
    
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            cout << map[i][j] << ' ';
        }
        cout << endl;
         
    }
    return 0;
}



```



# å¹¿åº¦ä¼˜å…ˆ

### [äº‘å‰ªè´´æ¿ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/paste/sa0zary9)

### è¿·å®«é—®é¢˜

1. **å®šä¹‰è¿·å®«çš„å¤§å°å’ŒçŠ¶æ€ï¼š** å®šä¹‰è¿·å®«çš„å¤§å°å¹¶ç¡®å®šè¿·å®«ä¸­æ¯ä¸ªä½ç½®çš„çŠ¶æ€ï¼Œå¦‚å¢™å£ã€å¯é€šè¡Œè·¯å¾„ç­‰ã€‚
2. **å®šä¹‰åæ ‡ç»“æ„ä½“å’Œæ–¹å‘æ•°ç»„ï¼š** å®šä¹‰ä¸€ä¸ªç»“æ„ä½“æ¥è¡¨ç¤ºè¿·å®«ä¸­æ¯ä¸ªä½ç½®çš„åæ ‡ï¼ŒåŒæ—¶å®šä¹‰ä¸€ä¸ªæ–¹å‘æ•°ç»„ï¼Œç”¨æ¥æŒ‡ç¤ºæ¯ä¸ªä½ç½®å¯ä»¥ç§»åŠ¨çš„æ–¹å‘ï¼Œå¦‚ä¸Šã€å³ã€ä¸‹ã€å·¦ã€‚
3. **ç¼–å†™åˆæ³•æ€§æ£€æŸ¥å‡½æ•°ï¼š** ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€æŸ¥ç»™å®šçš„åæ ‡æ˜¯å¦åˆæ³•ï¼Œå³æ˜¯å¦åœ¨è¿·å®«çš„èŒƒå›´å†…ä¸”å¯¹åº”çš„çŠ¶æ€ä¸ºå¯é€šè¡Œè·¯å¾„ã€‚å…¶ä¸­æœ‰ï¼šè¶Šç•Œæ£€æŸ¥ï¼Œåœ°å›¾æ£€æŸ¥æ˜¯å¦å·²ç»è®¿é—®è¿‡ï¼Œåœ°å›¾æ£€æŸ¥æ˜¯å¦æ˜¯éšœç¢ç‰©ï¼Œæ˜¯å¦æ˜¯ç»ˆç‚¹æ£€æŸ¥ï¼Œå¦‚æœæ˜¯ç»ˆç‚¹å°±è¦è¿”å›ã€‚

1. **ä½¿ç”¨é˜Ÿåˆ—è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼š**
   - åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ—ï¼Œç”¨äºä¿å­˜å¾…æ¢ç´¢çš„ä½ç½®ã€‚
   - å°†è¿·å®«çš„èµ·å§‹ä½ç½®åŠ å…¥é˜Ÿåˆ—ä¸­ã€‚
   - è¿›å…¥å¾ªç¯ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºæˆ–è€…æ‰¾åˆ°äº†ç»ˆç‚¹ã€‚
   - åœ¨æ¯æ¬¡å¾ªç¯ä¸­æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
     - ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªä½ç½®ï¼Œå³é˜Ÿå¤´çš„å…ƒç´ ï¼Œä½œä¸ºå½“å‰æ¢ç´¢çš„ä½ç½®ã€‚
     - åˆ¤æ–­å½“å‰ä½ç½®æ˜¯å¦ä¸ºç»ˆç‚¹ä½ç½®ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æœç´¢ç»“æŸï¼Œç®—æ³•æˆåŠŸæ‰¾åˆ°äº†é€šå‘ç»ˆç‚¹çš„è·¯å¾„ï¼Œç»“æŸå¾ªç¯ã€‚
     - å°†å½“å‰ä½ç½®æ ‡è®°ä¸ºå·²è®¿é—®è¿‡çš„çŠ¶æ€ï¼Œä»¥é¿å…é‡å¤è®¿é—®ã€‚
     - æ¢ç´¢å½“å‰ä½ç½®å‘¨å›´çš„æ‰€æœ‰ç›¸é‚»ä½ç½®ï¼Œå¹¶å°†æœªè®¿é—®è¿‡çš„ç›¸é‚»ä½ç½®åŠ å…¥é˜Ÿåˆ—ä¸­ã€‚
   - é‡å¤æ‰§è¡Œä»¥ä¸Šæ­¥éª¤ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºï¼ˆè¡¨ç¤ºæ²¡æœ‰é€šå‘ç»ˆç‚¹çš„è·¯å¾„ï¼‰æˆ–è€…æ‰¾åˆ°äº†ç»ˆç‚¹ã€‚
2. **è®°å½•è·¯å¾„ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰ï¼š** å¦‚æœéœ€è¦è®°å½•è·¯å¾„ä¿¡æ¯ï¼Œå¯ä»¥åœ¨æ‰¾åˆ°ç»ˆç‚¹åè¿›è¡Œå›æº¯ï¼Œä»ç»ˆç‚¹å¼€å§‹ï¼Œæ ¹æ®å·²ç»è®°å½•çš„çˆ¶èŠ‚ç‚¹ä¿¡æ¯é€†å‘å›æº¯åˆ°èµ·ç‚¹ï¼Œå³å¯å¾—åˆ°å…·ä½“çš„è·¯å¾„ä¿¡æ¯ã€‚
3. **è¿”å›æœç´¢ç»“æœï¼š** å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™è¯´æ˜æ²¡æœ‰æ‰¾åˆ°é€šå‘ç»ˆç‚¹çš„è·¯å¾„ï¼Œæœç´¢å¤±è´¥ï¼›å¦‚æœæ‰¾åˆ°äº†ç»ˆç‚¹ï¼Œåˆ™æœç´¢æˆåŠŸï¼Œç®—æ³•ç»“æŸã€‚



```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
typedef pair<int, int> PII;

const int N = 110;
char map[N][N];
bool st[N][N];
PII parent[N][N]; // è®°å½•æ¯ä¸ªç‚¹çš„çˆ¶èŠ‚ç‚¹åæ ‡
int row, colum, endx, endy;
int dx[] = { 1,0,-1,0 };
int dy[] = { 0,-1,0,1 };

void bfs(int x, int y) {
    queue<PII> q;
    q.push({ x,y });
    st[x][y] = true;
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t.first == endx && t.second == endy) return; // æ‰¾åˆ°ç»ˆç‚¹ç›´æ¥è¿”å›
        for (int i = 0; i < 4; i++) {
            int a = t.first + dx[i], b = t.second + dy[i];
            if (a < 1 || a > row || b < 1 || b > colum) continue;
            if (st[a][b] || map[a][b] == '1') continue;
            st[a][b] = true;
            parent[a][b] = t;//è¯¥æ‹“å±•ç‚¹çš„çˆ¶èŠ‚ç‚¹æ˜¯t
            q.push({ a,b });
        }
    }
}

int main() {
    cout << "è¯·è¾“å…¥è¿·å®«çš„è¡Œå’Œåˆ—" << endl;
    cin >> row >> colum;
    cout << "è¯·è¾“å…¥è¿·å®«çš„ç»ˆç‚¹åæ ‡" << endl;
    cin >> endx >> endy;
    cout << "è¯·è¾“å…¥è¿·å®«ï¼Œå…¶ä¸­1è¡¨ç¤ºéšœç¢ç‰©ï¼Œ0è¡¨ç¤ºå¯è¡Œ" << endl;
    for (int i = 1; i <= row; i++) {
        scanf("%s", map[i] + 1);
    }
    bfs(1, 1);

    if (!st[endx][endy]) {//æ²¡æœ‰è§£çš„è¯ï¼Œå°±æ²¡æœ‰èµ°è¿‡ç»ˆç‚¹ï¼Œåˆ™ç»ˆç‚¹çŠ¶æ€ä¸ºfalse
        cout << "æ²¡æœ‰è§£ï¼" << endl;
        return 0;
    }

    vector<PII> path;
    PII cur = { endx, endy };
    while (cur.first != 0 && cur.second != 0) { // ä»ç»ˆç‚¹å›æº¯åˆ°èµ·ç‚¹
        path.push_back(cur);
        cur = parent[cur.first][cur.second];
    }
    reverse(path.begin(), path.end()); // åè½¬è·¯å¾„ï¼Œå¾—åˆ°ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„

    cout << "æœ€çŸ­è·¯å¾„ä¸ºï¼š" << endl;
    for (auto p : path) {
        cout << '(' << p.first << ',' << p.second << ')' << "->";
    }
    cout << '(' << endx << ',' << endy << ')' << endl; // æ‰“å°ç»ˆç‚¹

    return 0;
}

```



### æ´›è°·p2658æ±½è½¦æ‹‰åŠ›èµ›

äºŒåˆ†æŸ¥æ‰¾+bfs

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstring>
using namespace std;
int high[510][510];
int flag[510][510];
bool st[510][510];
typedef pair<int, int>PII;
int x, y;
int row, colum;
int flag_cnt = 0;
PII q[510 * 510];//bfsçš„é˜Ÿåˆ—
int dx[] = { -1,0,1,0 };
int dy[] = { 0,1,0,-1 };
bool check(int mid) {
    q[0] = { x,y };//å…¥é˜Ÿ
    int cnt = 1;
    int hh = 0, tt = 0;
    st[x][y]=true;
    while (hh <= tt) {
        auto t = q[hh++];
        for (int i = 0; i < 4; i++) {
            int a = t.first + dx[i], b = t.second + dy[i];
            if (a<1 || a>row || b<1 || b>colum) continue;
            if (st[a][b]) continue;
            if (abs(high[a][b] - high[t.first][t.second]) > mid) continue;
            st[a][b] = true;
            q[++tt] = { a,b };
            if (flag[a][b] == 1) {
                cnt++;
                  if (cnt == flag_cnt) return true;   
            }         
        }
    }
    return false;
}

int main() {
    cin >> row >> colum;
    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            scanf("%d", &high[i][j]);
        }
    }

    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            scanf("%d", &flag[i][j]);
            
            if (flag[i][j] == 1) {
                flag_cnt++;
                x = i, y = j;
            }
        }
    }

    int l = -1, r = 10000000010;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        memset(q, 0, sizeof q);
        memset(st, false, sizeof st);
        if (check(mid)) r = mid;
        else l = mid;
    }
    cout << r;

    return 0;

}



```

### æ´›è°·p4554åŒç«¯é˜Ÿåˆ—è§£å†³

æ¨¡æ‹Ÿå¯çŸ¥ï¼Œæˆ‘ä»¬æ¯æ¬¡éƒ½æƒ³èµ°è´¹ç”¨ä¸ºé›¶çš„è·¯ï¼Œå³æ¯æ¬¡éƒ½ä¼˜å…ˆæŠŠè´¹ç”¨ä¸ºé›¶çš„èŠ‚ç‚¹å…¥é˜Ÿ

```c++
#include<iostream>
#include<deque>
#include<cstring>
using namespace std;
typedef pair<int,int> PII;
int n,m,x1,y1,x2,y2;
string map[510];
int mx[]={-1,0,1,0};
int my[]={0,1,0,-1};
deque<PII>q;
int dis[510][510];
int bfs(int x,int y){
    //å…¥é˜Ÿèµ·ç‚¹
    q.push_back({x,y});
    dis[x][y]=0;//è®¾ç½®èµ·ç‚¹è·ç¦»èµ·ç‚¹çš„è·ç¦»æ˜¯é›¶
    while(!q.empty()){
        auto t=q.front();//è·å–å½“å‰é˜Ÿå¤´å…ƒç´ 
        q.pop_front();//æ¯æ¬¡ä¼˜å…ˆè®¿é—®è´¹ç”¨ä¸ºé›¶çš„èŠ‚ç‚¹
        char ch=map[t.first][t.second];
        for(int i=0;i<4;i++){
            int a=t.first+mx[i],b=t.second+my[i];
            if(a<0||a>=n||b<0||b>=m) continue;
            if(dis[a][b]>=0) continue;
           
            if(map[a][b]==ch){
                q.push_front({a,b});
                dis[a][b]=dis[t.first][t.second];
            }
            if(map[a][b]!=ch){
                q.push_back({a,b});
                dis[a][b]=dis[t.first][t.second]+1;
            }
          
            if(a==x2&&b==y2) return dis[a][b];
        }
    }
  return -1;
}
int main(){
    while(cin>>n>>m,n||m){//é€—å·è¿ç®—ç¬¦ï¼Œä¼šæ‰§è¡Œä¸¤ä¸ªæ“ä½œæ•°ï¼Œå¹¶è¿”å›æœ€åä¸€ä¸ªæ“ä½œæ•°çš„ç»“æœä½œä¸ºè¿”å›å€¼
        for(int i=0;i<n;i++){
            cin>>map[i];
        }
        
        //æ¯æ¬¡éå†éƒ½éœ€è¦é‡æ–°è®¾ç½®è·ç¦»ä¸ºæ²¡æœ‰è®¿é—®è¿‡
        memset(dis,-1,sizeof dis);
        q.clear();
        cin>>x1>>y1>>x2>>y2;
        int res=bfs(x1,y1);
        cout<<res<<endl;
    }
    return 0;
}
```

### p1746ç¦»å¼€ä¸­å±±è·¯

```c++
#include<iostream>
#include<cstring>
using namespace std;
typedef pair<int,int>PII;
PII q[1010*1010];
char map[1010][1010];
int dis[1010][1010];
int vis[1010][1010];
int mx[]={-1,0,1,0};
int my[]={0,1,0,-1};
int n,x1,y1,x2,y2;
int bfs(){
    memset(dis,-1,sizeof dis);
    memset(vis,-1,sizeof vis);
    q[0]={x1,y1};
    q[1]={x2,y2};
    dis[x1][y1]=0;
    dis[x2][y2]=0;
    vis[x1][y1]=1;
    vis[x2][y2]=2;
    int hh=0,tt=1;
    while(hh<=tt){
        auto t=q[hh++];
        for(int i=0;i<4;i++){
            int a=t.first+mx[i],b=t.second+my[i];
            if(a<1||a>n||b<1||b>n) continue;
            if(map[a][b]=='1') continue;
            if(vis[a][b]+vis[t.first][t.second]==3){
                return dis[a][b]+dis[t.first][t.second]+1;
            }
            if(dis[a][b]>0) continue;
            dis[a][b]=dis[t.first][t.second]+1;
            if(vis[a][b]==-1){
                vis[a][b]=vis[t.first][t.second];
            }
            q[++tt]={a,b};//è¿™é‡Œä½¿å¾—é˜Ÿåˆ—æ˜¯äº¤æ›¿æ’å…¥èµ·ç‚¹å’Œç»ˆç‚¹çš„èŠ‚ç‚¹çš„
        }
    }
    return -1;
    
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%s",map[i]+1);
    }
    scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
    int res=bfs();
    cout<<res;
    return 0;
}
```



### æ´›è°·p1379å…«æ•°ç éš¾é¢˜

```c++
#include<iostream>
#include<algorithm>
#include<string>
#include<queue>
#include<unordered_map>
using namespace std;
int mx[] = { -1,0,1,0 };
int my[] = { 0,1,0,-1 };
unordered_map<string, int>dist;//è®°å½•èµ°åˆ°è¯¥çŠ¶æ€éœ€è¦å¤šå°‘æ­¥
queue<string>q;
string end1 = "123804765";
int bfs(string start) {
    q.push(start);
    dist[start] = 0;
    while (q.size()) {
        auto t = q.front();
        q.pop();
        if (t == end1) return dist[t];
        int distance = dist[t];
        int a = t.find('0');
        int x1 = a / 3, y1 = a % 3;//çŠ¶æ€å‹ç¼©,è½¬åŒ–ä¸ºçŸ©é˜µçš„ä¸‹æ ‡
       
        for (int i = 0; i < 4; i++) {
            int x2 = x1 + mx[i], y2 = y1 + my[i];//æ¯æ¬¡äº¤æ¢ä¸Šä¸‹å·¦å³å››ä¸ªä½ç½®
            if (x2 < 0 || x2 >= 3 || y2 < 0 || y2 >= 3) continue;//è¶Šç•Œ
            int tmp = x2 * 3 + y2;//åˆè½¬åŒ–ä¸ºå­—ç¬¦ä¸²ä¸‹æ ‡
            swap(t[a], t[tmp]);//åœ¨å­—ç¬¦ä¸²ä¸­å°†è¿™ä¸¤ä¸ªä½ç½®äº’æ¢
            if (!dist.count(t)) {//å¦‚æœè¿™ä¸ªå­—ç¬¦ä¸²æ²¡æœ‰è¯•è¿‡
                dist[t] = distance + 1;//è¯•ä¸€è¯•å˜›
                q.push(t);
            }
            swap(t[a], t[tmp]);//å›æº¯
        }
    }
    return -1;

}
int main() {
    string start;
    cin >> start;
    int res = bfs(start);
    cout << res;
    return 0;

}
```



åŒå‘é˜Ÿåˆ—ä¼˜åŒ–ä»£ç 

```c++


#include<iostream>
#include<cstring>
#include<algorithm>
#include<string>
#include<queue>
#include<unordered_map>
using namespace std;
int mx[] = { -1,0,1,0 };
int my[] = { 0,1,0,-1 };
unordered_map<string, int>dist;//è®°å½•èµ°åˆ°è¯¥çŠ¶æ€éœ€è¦å¤šå°‘æ­¥
unordered_map<string,int>vis;
queue<string>q;
string end1 = "123804765";
int bfs(string start) {
    q.push(start);
    q.push(end1);
    dist[start] = 0;
    dist[end1]=0;
    vis[start]=1;
    vis[end1]=2;
    
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        int flag=vis[t];//è®°å½•å½“å‰èŠ‚ç‚¹çš„æ ‡è®°
        int distance = dist[t];//è®°å½•å½“å‰èŠ‚ç‚¹åˆ°èµ·ç‚¹æˆ–ç»ˆç‚¹çš„è·ç¦»
        
        int a = t.find('0');
        int x1 = a / 3, y1 = a % 3;//çŠ¶æ€å‹ç¼©,è½¬åŒ–ä¸ºçŸ©é˜µçš„ä¸‹æ ‡
       
        for (int i = 0; i < 4; i++) {
            int x2 = x1 + mx[i], y2 = y1 + my[i];//æ¯æ¬¡äº¤æ¢ä¸Šä¸‹å·¦å³å››ä¸ªä½ç½®
            if (x2 < 0 || x2 >= 3 || y2 < 0 || y2 >= 3) continue;//è¶Šç•Œ
            int tmp = x2 * 3 + y2;//åˆè½¬åŒ–ä¸ºå­—ç¬¦ä¸²ä¸‹æ ‡
            swap(t[a], t[tmp]);//ç°åœ¨çš„tæ˜¯æ‹“å±•çš„t
            
            if (vis[t]+flag==3){//å¦‚æœå½“å‰èŠ‚ç‚¹å’Œæ‹“å±•èŠ‚ç‚¹ç›¸é‡
                int res1=dist[t];
                swap(t[a],t[tmp]);
                int res2=dist[t];
                return res1+res2+1;
            }
            
            if (!dist.count(t)) {//å¦‚æœè¿™ä¸ªå­—ç¬¦ä¸²æ²¡æœ‰è¯•è¿‡
                dist[t] = distance + 1;//è¯•ä¸€è¯•å˜›
                vis[t]=flag;
                q.push(t);
            }
   
            swap(t[a], t[tmp]);//å›æº¯
        }
    }
    return -1;

}
int main() {
    string start;
    cin >> start;
    if(start==end1){
        cout<<0;
        return 0;
    }
    int res = bfs(start);
    cout << res;
    return 0;

}
```

###   p2730é­”æ¿

```c++
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
#include<string>
#include<unordered_map>
using namespace std;
unordered_map<string, int>dist;//èµ°åˆ°å½“å‰çŠ¶æ€éœ€è¦å‡ æ­¥
unordered_map<string, pair<char, string>>pre;
queue<string>q;
char arr[2][4];

void to_arr(string s) {
    for (int i = 0; i < 8; i++) {
        if (i < 4) {
            arr[0][i] = s[i];
        }
        else arr[1][7-i] = s[i];
    }
}

string To_string() {
    string res;
    for (int i = 0; i < 4; i++) {
        res += arr[0][i];
    }
    for (int i = 3; i >= 0; i--) {
        res += arr[1][i];
    }
    return res;
}

//äº¤æ¢ä¸Šä¸‹ä¸¤è¡Œ
string move0(string s) {
    to_arr(s);
    for (int i = 0; i < 4; i++) {
        swap(arr[0][i], arr[1][i]);
    }
    return To_string();
}

//å°†æœ€å³è¾¹çš„ä¸€åˆ—æ’å…¥æœ€å·¦è¾¹
string move1(string s) {
    to_arr(s);
    int a = arr[0][3], b = arr[1][3];
    for (int i = 3; i >= 1; i--) {
        for (int j = 0; j < 2; j++) {
            arr[j][i] = arr[j][i - 1];
        }
    }
    arr[0][0] = a;
    arr[1][0] = b;
    return To_string();
}

string move2(string s) {
    to_arr(s);
    int a = arr[0][2];
    arr[0][2] = arr[0][1];
    arr[0][1] = arr[1][1];
    arr[1][1] = arr[1][2];
    arr[1][2] = a;
    return To_string();
}



int bfs(string start, string end) {
    q.push(start);
    dist[start] = 0;
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t == end) return dist[end];
        string m[3];
        m[0] = move0(t);
        m[1] = move1(t);
        m[2] = move2(t);
        for (int i = 0; i<3; i++) {
            string s = m[i];
            if (!dist.count(s)) {
                dist[s] = dist[t] + 1;
                pre[s] = {i + 'A',t};
                if (s == end) return dist[end];
                q.push(s);
            } 
           
        }
    }
    return -1;
}
int main() {
    int x;

    string end;
    string start;
    for (int i = 0; i < 8; i++) {
        cin >> x;
        start += char(x + '0');
        end += char(i + 1 + '0');
    }

    int res = bfs(start, end);
    cout << res << endl;
    string res2;
    while (end != start) {
        res2 += pre[end].first;
        end = pre[end].second;
    }
    reverse(res2.begin(), res2.end());
    if (res2.size()) {
        cout << res2;
    }
    return 0;
}

```

### p1443é©¬çš„éå†

bfsæœ‰å¾ˆå¤šç§å½¢å¼å•¦

```c++
#include<iostream>//P1443
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
const int dx[8]={-1,-2,-2,-1,1,2,2,1};
const int dy[8]={2,1,-1,-2,2,1,-1,-2};//8ä¸ªæ–¹å‘
queue<pair<int,int> > q;
int f[500][500];//å­˜æ­¥æ•°
bool vis[500][500];//èµ°æ²¡èµ°è¿‡
int main()
{
	int n,m,x,y;
	memset(f,-1,sizeof(f));memset(vis,false,sizeof(vis));
	cin>>n>>m>>x>>y;
	f[x][y]=0;vis[x][y]=true;q.push(make_pair(x,y));
	while(!q.empty())
	{
		int xx=q.front().first,yy=q.front().second;q.pop();//å–é˜Ÿé¦–å¹¶å‡ºé˜Ÿ
		for(int i=0;i<8;i++)
		{
			int u=xx+dx[i],v=yy+dy[i];
			if(u<1||u>n||v<1||v>m||vis[u][v])continue;//å‡ºç•Œæˆ–èµ°è¿‡å°±ä¸èµ°
		    vis[u][v]=true;q.push(make_pair(u,v));f[u][v]=f[xx][yy]+1;
		}
	}
	for(int i=1;i<=n;i++)
	 {for(int j=1;j<=m;j++)printf("%-5d",f[i][j]);printf("\n");}//æ³¨æ„åœºå®½ï¼ï¼
	return 0;
}
```



### åŠ›æ‰£p1747å¥½å¥‡æ€ªçš„æ¸¸æˆ

éå†äº†æ‰€æœ‰çš„æƒ…å†µï¼Œå”¯ç‹¬æ²¡æœ‰æƒ³åˆ°æ˜¯æ•°æ®èŒƒå›´å‡ºé—®é¢˜äº†ï¼Œç‰¢å¼Ÿï¼Œæˆ‘æƒ³æŠŠåœ°çƒä¸€æ‹³é”¤çˆ†

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstring>
using namespace std;
typedef pair<int, int> PII;

int vis[25][25];
int dis[25][25];//åŠè®°å½•è·ç¦»
int mx[] = { -2,-2,-1,1,2,2,2,2,1,-1,-2,-1 };
int my[] = { -1,-2,-2,-2,-2,-1,1,2,2,2,2,1 };

int bfs(int x, int y) {
    if (x == 1 && y == 2 || x == 2 && y == 1) return 2;
    //ç»ˆç‚¹å’Œèµ·ç‚¹éƒ½æ˜¯å·²çŸ¥çš„ï¼ŒåŒå‘é˜Ÿåˆ—
    memset(dis, -1, sizeof dis);
    memset(vis, -1, sizeof vis);
    PII q[25 * 25];//å®šä¹‰åˆ—è¡¨

    q[0] = { x,y };
    q[1] = { 1,1 };
    dis[x][y] = 0;
    dis[1][1] = 0;
    vis[x][y] = 1;
    vis[1][1] = 2;
    int hh = 0, tt = 1;
    while (hh <= tt) {
        auto t = q[hh++];
        for (int i = 0; i < 12; i++) {
            int a = t.first + mx[i], b = t.second + my[i];
            if (a<=1 || a>21 || b<=1 || b>21) continue;
          
            if (vis[a][b] + vis[t.first][t.second] == 3) {
                return dis[a][b] + dis[t.first][t.second] + 1;
            }
            if (dis[a][b] > 0) continue;
            dis[a][b] = dis[t.first][t.second] + 1;
            if (vis[a][b] == -1) vis[a][b] = vis[t.first][t.second];
            q[++tt] = { a,b };
        }
    }
    return -1;
}


int main() {
    int x1, y1, x2, y2;
    scanf("%d %d", &x1, &y1);
    scanf("%d %d", &x2, &y2);
    int res1 = bfs(x1, y1);
    int res2 = bfs(x2, y2);
    cout << res1 << endl;
    cout << res2 << endl;
    return 0;

}
```



### åŠ›æ‰£p2385

æˆ‘æ±‚æ±‚ä½ äº†ï¼Œæ•°æ®å¼€å¤§ä¸€ç‚¹å§ï¼Œè¦ä¸ç„¶ä½ åˆä»¥ä¸ºæ˜¯å“ªä¸ªåœ°æ–¹å†™é”™äº†ç„¶åæ”¹åŠå¤©å°ä¸‘ï¼





# äºŒåˆ†æŸ¥æ‰¾

### [ã€ç®—æ³•1-6ã€‘äºŒåˆ†æŸ¥æ‰¾ä¸äºŒåˆ†ç­”æ¡ˆ - é¢˜å• - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/training/111#problems)

### åŸºç¡€äºŒåˆ†

ã€How to avoid pitfalls in Binary Search?ã€‘https://www.bilibili.com/video/BV1EW4y1C7vA?vd_source=afced950d3df908879a570bbf5db28f2

```c++
#include <iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;
bool is_blue(int num, int x) {
	//å…·ä½“æ¡ä»¶
	if (num <= 5) return true;
	else return false;
}
int main() {
	//å‡è®¾æˆ‘è¦æ‰¾æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå¤§äºäº”çš„æ•°çš„ä¸‹æ ‡
	int arr[10] = {0};
	for (int i = 0; i < 10; i++) {
		cin >> arr[i];
	}
	int l = -1;
	int r = sizeof(arr) / sizeof(arr[0]);
	int mid;
	while (l + 1 != r) {//åˆ¤å®šæ¡ä»¶ï¼Œl+=rè¯´æ˜å·²ç»éå†äº†æ•´ä¸ªæ•°ç»„
		mid = (l + r) / 2;
		if (is_blue(arr[mid], 5)) l = mid;
		else r = mid;
	}
	cout << r;
	return 0;
}
```



### åŠ›æ‰£äºŒåˆ†æ±‚ç«‹æ–¹æ ¹

//è¾“å…¥ä¸€ä¸ªæ•°ï¼Œæ±‚å®ƒçš„ç«‹æ–¹æ ¹ï¼Œè¦æ±‚ä½¿ç”¨é«˜æ•ˆçš„ç®—æ³•

```c++
#include <iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
#include<iomanip>
using namespace std;
bool check(int num, int n) {
	return num * num * num <n;
}


int main() {
	int n;
	cin >> n;
	double l = -100, r = 100;
	double mid;
	for (int i = 0; i <50; i++) {
		mid = (r + l) / 2;
		if(check(mid,n)) l=mid;
		else r=mid;
	}
	printf("%6lf", l);
	
	return 0;
}
```

### æ´›è°·p3853

![image-20240315200520439](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240315200520439.png)

```c++
/*
å¯¹äºä»»æ„ä¸€ä¸ªç»™å‡ºçš„â€œç©ºæ—·æŒ‡æ•°â€Gï¼Œæˆ‘ä»¬åº”è¯¥æ€æ ·å»åˆ¤æ–­å®ƒæ˜¯å¦ç¬¦åˆé¢˜ç›®çš„æ„æ€å‘¢ï¼Ÿ

æˆ‘ä»¬å¯ä»¥æƒ³è±¡ï¼Œæˆ‘ä»¬å·²çŸ¥äº†è¿™æ¡è·¯ä¸Šçš„æ‰€æœ‰çš„è·¯æ ‡ï¼Œæˆ‘ä»¬ä»å¤´å¼€å§‹æšä¸¾ä¸¤ä¸¤ç›¸é‚»çš„è·¯æ ‡çš„é—´è·ï¼Œå¦‚æœå¤§äºG,é‚£ä¹ˆå·²ç»ä¸ç¬¦åˆGä¸ºæœ€å¤§è·ç¦»çš„æ¡ä»¶äº†ï¼Œä¸ºäº†ä½¿Gæ»¡è¶³,æˆ‘ä»¬å°±å¯ä»¥åœ¨å‰ä¸€ä¸ªè·¯æ ‡å‰é¢Gç±³å¤„åŠ ä¸€ä¸ªè·¯æ ‡ï¼Œè¿™æ ·ä¸å‰é¢ä¸€ä¸ªå°±ç¬¦åˆæ¡ä»¶äº†ï¼Œå†åˆ¤æ–­æ–°è®¾çš„è·¯æ ‡å’Œåé¢çš„è·¯æ ‡æ˜¯å¦è·ç¦»å°äºG,å¦‚æœä¸ï¼Œç»§ç»­é‡å¤æ“ä½œè®¾ç½®æ–°è·¯æ ‡

å½“æ–°è®¾çš„è·¯æ ‡æ•°å·²ç»è¶…è¿‡é¢˜ç›®æ‰€ç»™æœ€å¤§å¢è®¾å€¼æ—¶ï¼Œå¦‚æœè¿˜æœ‰è·¯æ ‡ä¸æ»¡è¶³G,ä½†å·²ç»ä¸èƒ½è®¾ç½®æ–°è·¯æ ‡äº†ï¼Œæ‰€ä»¥è¯¥Gå€¼å°±ä¸æ»¡è¶³æ¡ä»¶ã€‚ç›¸åï¼Œåˆ™Gæˆç«‹ã€‚

æ³¨æ„åˆ°ï¼Œå¦‚æœä¸€ä¸ªâ€œç©ºæ—·æŒ‡æ•°â€æˆç«‹ï¼Œé‚£ä¹ˆå¯èƒ½å­˜åœ¨æ¯”å®ƒæ›´å°çš„è§£ï¼Œä½†å¦‚æœä¸€ä¸ªâ€œç©ºæ—·æŒ‡æ•°â€ä¸æˆç«‹ï¼Œé‚£ä¹ˆç­”æ¡ˆåªèƒ½æ¯”è¯¥å€¼æ›´å¤§*/

//æˆ‘æ˜¯å¦‚æ­¤å¼€å¿ƒæˆ‘èƒ½æ¥è§¦åˆ°å¦‚æ­¤ç¾å¦™çš„ç®—æ³•
#include<iostream>
using namespace std;
int L,N,K;
int arr[100010],s[100010];
bool check(int x){
    int cnt=0;
    for(int i=1;i<=N;i++){
        if(s[i]>x){
            cnt++;
            int num=s[i]-x;
            while(num>x){
                cnt++;
                num-=x;
            }
        }
    }
    
    return cnt<=K;
}


int main(){
    cin>>L>>N>>K;
    int highest=0;
    
    for(int i=1;i<=N;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
        s[i]=arr[i]-arr[i-1];
    }
    
    arr[N+1]=L;
    s[N+1]=arr[N+1]-arr[N];
    int l=0,r=L+1;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    if(check(l)) cout<<l;
    else cout<<r;
    return 0;
}
```



### **æœ€å°å€¼æœ€å¤§æ¨¡å‹**

![image-20240315200512608](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240315200512608.png)

#### **æ´›è°·p1873**

```c++
#include<iostream>
using namespace std;
int n,m;
int arr[1000010];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        sum+=max(0,arr[i]-x);
        if(sum>=m) return true;
    }
    return false;
   
  
}
int main(){
    cin>>n>>m;
    int highest=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
    }
    int l=0,r=highest;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    if(check(r)) cout<<r;
  
    else cout<<l;
    return 0;
}
```



#### **æ´›è°·p2440**

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,k;
int arr[100010];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        sum+=arr[i]/x;
        if(sum>=k) return true;
    }
    return false;
}

int main(){
    cin>>n>>k;
    int highest=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
    }
    int l=0,r=highest;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    if(check(r)) cout<<r;
    else cout<<l;
    
    return 0;
}
```



#### **æ´›è°·p2678è·³çŸ³å¤´**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
int L, N, M;
int arr[50010];

bool check(int x) {
    int cnt = 0;//è®°å½•ç§»åŠ¨çŸ³å¤´çš„æ¬¡æ•°
    int i = 0, now = 0;//iä»£è¡¨çš„æ˜¯å½“å‰çš„çŸ³å¤´ï¼Œi<N+1çš„åŸå› æ˜¯æˆ‘ä»¬ä¸èƒ½æŠŠç»ˆç‚¹æ¬èµ°
    while (i < N + 1) {
        i++;
        if (arr[i] - arr[now] < x) cnt++;
        else now = i;
    }
    return cnt <= M;

}
//ç®—æ³•æ€è·¯
//æ¯æ¬¡éƒ½æŠŠæœ€å°è·ç¦»ç§»èµ°ï¼Œå¹¶ä¸”éšç€ç§»åŠ¨çš„æ¬¡æ•°å˜å¤§ï¼Œæœ€å°è·³è·ƒè·ç¦»æ˜¯åœ¨å˜å¤§çš„
//äºŒåˆ†ï¼Œå‡è®¾ä¸­é—´çš„å€¼æ˜¯ç­”æ¡ˆï¼Œé‚£ä¹ˆæŒ‰ç…§æ¯”è¿™ä¸ªç­”æ¡ˆå°çš„çŸ³å¤´ä¸€å®šä¼šè¢«ç§»èµ°ï¼Œå¹¶ä¸”ç§»èµ°çš„çŸ³å¤´ä¸€å®šæ˜¯Mä¸ª
//æ‰€ä»¥äºŒåˆ†çš„åˆ¤æ–­æ¡ä»¶å°±æ˜¯ï¼Œç§»èµ°çš„çŸ³å¤´çš„ä¸ªæ•°æ˜¯ä¸æ˜¯Mï¼Œå¦‚æœå¤§äºMï¼Œå°±è¯´æ˜ä¸æ˜¯ç­”æ¡ˆ
//å¦‚æœæˆ‘ä»¬å‡è®¾çš„æ¡ä»¶ç¬¦åˆï¼Œæˆ‘ä»¬è¿˜è¦æ£€æŸ¥æ¯”å®ƒå°çš„åœ°æ–¹æ˜¯ä¸æ˜¯æœ‰ç­”æ¡ˆ

int main() {
    cin >> L >> N >> M;
    for (int i = 1; i <= N; i++) {
        scanf("%d", &arr[i]);
    }
    arr[N + 1] = L;  //ç›¸å½“äºç»ˆç‚¹ 
    int l = 0, r = L + 1;//è¾¹ç•Œæ¡ä»¶
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;//è¿™ä¸ªæ˜¯æˆ‘ä»¬å‡è®¾çš„ç­”æ¡ˆ
        if (check(mid)) l = mid;
        else r = mid;
    }

    if (check(r)) cout << r;
    else cout << l;

}
```

#### ACWing1236é€’å¢ä¸‰å…ƒç»„

éœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š1.æ³¨æ„æ•°æ®çš„æ•°é‡çº§ï¼Œä¸¤ä¸ª10çš„äº”æ¬¡æ–¹ç›¸ä¹˜ï¼Œå¾—åˆ°çš„æ˜¯10çš„åæ¬¡æ–¹ï¼Œè¶…è¿‡intçš„æœ€å¤§å€¼ï¼Œæ‰€ä»¥è¦å¼€long long

ç¬¬äºŒä¸ªå°±æ˜¯**å½“ç¨‹åºå‡ºé—®é¢˜æ—¶ï¼Œå¦‚æœç¡®ä¿¡è‡ªå·±çš„é€»è¾‘æ˜¯ï¼Œæ²¡é—®é¢˜çš„ï¼Œå°±è¦é‡æ–°æ£€æŸ¥ä¸€éï¼Œå› ä¸ºå¾ˆæœ‰å¯èƒ½æ˜¯å› ä¸ºä¸€äº›å°ç»†èŠ‚å‡ºé”™è€Œä¸æ˜¯é€»è¾‘å‡ºé”™**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;
int N;
int a[100010];
int b[100010];
int c[100010];
bool check1(int num, int x) {
    return num < x;
}

bool check2(int num, int x) {
    return num <= x;
}
int func1(int num) {
    //æ‰¾æ•°ç»„ä¸­æœ€åä¸€ä¸ªå°äºnumçš„ä¸‹æ ‡
    int l = 0, r = N + 1, mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check1(a[mid], num)) l = mid;
        else r = mid;
    }
    return l;

}
int func2(int num) {
    //æ‰¾æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå¤§äºnumçš„ä¸‹æ ‡
    int l = 0, r = N + 1, mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check2(c[mid], num)) l = mid;
        else r = mid;
    }
    return r;

}
int main() {
    cin >> N;
    LL res = 0;
    for (int i = 1; i <= N; i++) {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= N; i++) {
        scanf("%d", &b[i]);
    }
    for (int i = 1; i <= N; i++) {
        scanf("%d", &c[i]);
    }

    //äºŒåˆ†æ³•
    sort(a+1, a + N+1);
    sort(b+1, b + N+1);
    sort(c+1, c + N+1);
    for (int i = 1; i <= N; i++) {
        LL x = func1(b[i]);
        LL y = func2(b[i]);
        res += (x * (N - y + 1));
    }
    cout << res;
    return 0;
}
```

### å˜ç§äºŒåˆ†

#### åŠ›æ‰£33æœç´¢æ—‹è½¬æ’åºæ•°ç»„

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};

```





# åŒæŒ‡é’ˆ

[åŒæŒ‡é’ˆç®—æ³•-CSDNåšå®¢](https://blog.csdn.net/qq_54773252/article/details/122836179?ops_request_misc=%7B%22request%5Fid%22%3A%22171059884416800226527499%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=171059884416800226527499&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122836179-null-null.142^v99^pc_search_result_base1&utm_term=åŒæŒ‡é’ˆç®—æ³•&spm=1018.2226.3001.4187)

åŒæŒ‡é’ˆä¸»è¦æœ‰ä¸¤ç§ï¼šå¿«æ…¢æŒ‡é’ˆå’Œå¯¹æ’æŒ‡é’ˆ

### åŠ›æ‰£16æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        //åŒæŒ‡é’ˆ
        int n=nums.size();
        sort(nums.begin(),nums.end());
        int best=1e7;
        auto update=[&](int cur){
            if(abs(cur-target)<abs(best-target)){
                best=cur;
            }
        };

        for(int i=0;i<nums.size();i++){
            if(i>0&&nums[i]==nums[i-1]) continue;//ä¸è®¡ç®—é‡å¤æƒ…å†µ
            

            //ä½¿ç”¨åŒæŒ‡é’ˆ
            int j=i+1,k=n-1;
            while(j<k){
                int sum=nums[i]+nums[j]+nums[k];
                if(sum==target) return target;
                update(sum);
                if(sum>target){
                    int k0=k-1;
                    while(j<k0&&nums[k0]==nums[k]) k0--;
                    k=k0;
                }
                else{
                    int j0=j+1;
                    while(j0<k&&nums[j0]==nums[j]) j0++;
                    j=j0;
                }
        }
    }
    return best;

    }
};
```

### åŠ›æ‰£15ä¸‰æ•°ä¹‹å’Œ

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        // æšä¸¾ a
        for (int first = 0; first < n; ++first) {
            // éœ€è¦å’Œä¸Šä¸€æ¬¡æšä¸¾çš„æ•°ä¸ç›¸åŒ
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c å¯¹åº”çš„æŒ‡é’ˆåˆå§‹æŒ‡å‘æ•°ç»„çš„æœ€å³ç«¯
            int third = n - 1;
            int target = -nums[first];
            // æšä¸¾ b
            for (int second = first + 1; second < n; ++second) {
                // éœ€è¦å’Œä¸Šä¸€æ¬¡æšä¸¾çš„æ•°ä¸ç›¸åŒ
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // éœ€è¦ä¿è¯ b çš„æŒ‡é’ˆåœ¨ c çš„æŒ‡é’ˆçš„å·¦ä¾§
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // å¦‚æœæŒ‡é’ˆé‡åˆï¼Œéšç€ b åç»­çš„å¢åŠ 
                // å°±ä¸ä¼šæœ‰æ»¡è¶³ a+b+c=0 å¹¶ä¸” b<c çš„ c äº†ï¼Œå¯ä»¥é€€å‡ºå¾ªç¯
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    ans.push_back({nums[first], nums[second], nums[third]});
                }
            }
        }
        return ans;
    }
};


```



### 18å››æ•°ä¹‹å’Œ

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> quadruplets;
        if (nums.size() < 4) {
            return quadruplets;
        }
        sort(nums.begin(), nums.end());
        int length = nums.size();
        for (int i = 0; i < length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                break;
            }
            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {
                continue;
            }
            for (int j = i + 1; j < length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
                    break;
                }
                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {
                    continue;
                }
                int left = j + 1, right = length - 1;
                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while (left < right && nums[left] == nums[left + 1]) {
                            left++;
                        }
                        left++;
                        while (left < right && nums[right] == nums[right - 1]) {
                            right--;
                        }
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return quadruplets;
    }
};


```



### æ´›è°·p1102

æˆ‘ä»¬è€ƒè™‘é¢˜ç›®è¦æ±‚æ±‚å‡ºæ‰€æœ‰`A-B=C`çš„æ•°å¯¹ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆå°†åŸæ•°ç»„æ’åºï¼Œç„¶åå°±ä¼šå‘ç°æ¯ä¸ªæ•°Aï¼Œå¯¹åº”çš„æ•°Bä¸€å®šæ˜¯ä¸€æ®µè¿ç»­çš„åŒºé—´ã€‚

ç„¶åæˆ‘ä»¬å†è€ƒè™‘å¦‚ä½•å»æ‰¾åˆ°è¿™ä¸ªåŒºé—´ã€‚

æˆ‘ä»¬æ˜¾ç„¶æ˜¯è¦æ‰¾åˆ°è¿™ä¸ªè¿ç»­åŒºé—´çš„å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹ã€‚

è€ƒè™‘åˆ°æ’åºä¹‹ååºåˆ—çš„æœ‰åºæ€§ï¼Œæˆ‘ä»¬æšä¸¾æ¯ä¸ªæ•°ï¼Œä»–ä»¬çš„å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹éƒ½æ˜¯**å•è°ƒä¸é™**çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨two-pointersï¼Œä¹Ÿå°±æ˜¯åŒæŒ‡é’ˆæ¥ç»´æŠ¤è¿™ä¸ªä¸œè¥¿ã€‚

![image-20240316225049443](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240316225049443.png)

ä»£ç å¾ˆç®€æ´ã€‚

```c++
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2e5 + 10;
int n , c;
int a[N];

int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1 , a + 1 + n);
	int l = 1, r1 = 1 , r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```



### åŠ›æ‰£27ç§»é™¤å…ƒç´ 

soooooooeasy!!!!

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int le=nums.size();
        int i=0,j=0;
        while(i<le){
            if(nums[i]==val) j++;
            else nums[i-j]=nums[i];
            i++;
        }
        nums.resize(le-j);
        return le-j;


    }
};
```



### åŠ›æ‰£11ç››æœ€å¤šæ°´çš„å®¹å™¨

ç”±é¢˜æ„å¯çŸ¥ï¼Œå®¹å™¨çš„é«˜åº¦æ˜¯ç”±çŸ­æ¿å†³å®šçš„ï¼Œå‡è®¾åˆå§‹å®¹å™¨çš„çŸ­æ¿å’Œé•¿ç‰ˆåˆ†åˆ«åœ¨ä¸¤ç«¯

å¦‚æœå‘å†…ç§»åŠ¨çŸ­æ¿ï¼ŒçŸ­æ¿çš„é•¿åº¦æœ‰å¯èƒ½å˜å¤§ï¼Œè™½ç„¶å®¹å™¨çš„å®½åº¦å˜å°äº†ï¼Œä½†æ˜¯ä»ç„¶å¯èƒ½ä½¿å¾—å®¹å™¨çš„ä½“ç§¯å˜å¤§

å¦‚æœç§»åŠ¨é•¿æ¿ï¼Œåˆ™å®¹å™¨çš„ä½“ç§¯ä¸€å®šå˜å°

ç”±æ­¤å¯çŸ¥åªè¦åœ¨æ¯æ¬¡ç§»åŠ¨ä¸­ç§»åŠ¨çŸ­æ¿ï¼Œåœ¨åˆ¤æ–­ä½“ç§¯æ˜¯å¦å˜å¤§å³å¯

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int le = height.size();
        int r1 = 0, r2 = le - 1;//çŸ­æ¿é•¿æ¿
        int res = 0;
        while(r1<r2){
            if(height[r1]<height[r2]){
                res=max(res,min(height[r1],height[r2])*(r2-r1));
                r1++;
            }
            else{
                 res=max(res,min(height[r1],height[r2])*(r2-r1));
                r2--;
            }
        }
        return res;
    }
};
```

### ACWing1236é€’å¢ä¸‰å…ƒç»„

```c++
//æ»¡è¶³æ¡ä»¶A-B<0  B-C<0
//æšä¸¾Bï¼Œæ‰€ä»¥å‡è®¾æ¯æ¬¡Bçš„å€¼éƒ½æ˜¯å›ºå®šçš„ï¼Œæˆ‘ä»¬çŸ¥é“Aiçš„å€¼æ˜¯æœ€åä¸€ä¸ªå°äºBçš„å€¼ï¼Œé‚£ä¹ˆAiä¹‹å‰çš„å€¼éƒ½æ˜¯å°äºBçš„ï¼ŒåŒç†ï¼Œæœ€åä¸€ä¸ªå°äºBçš„Ciä¹‹åçš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯å¤§äºBçš„
//æ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰¾åˆ°è¿™äº›æ•°

```



```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long LL;
const int N = 1e5+10;
int num[3][N];

int main() {
    int n;
    scanf("%d", &n);
    for(int i = 0; i < 3; ++i) 
        for(int j = 1; j <= n; ++j) 
            scanf("%d", &num[i][j]);
    for(int i = 0; i < 3; ++i)
        sort(num[i]+1, num[i]+n+1);

    LL ans = 0;
    //æšä¸¾Bï¼Œå¯»æ‰¾Aæ»¡è¶³çš„ä¸ªæ•°ä»¥åŠCæ»¡è¶³çš„ä¸ªæ•°ç›¸ä¹˜
    int a = 1, c = 1;
    for(int i = 1; i <= n; ++i) {
        int key = num[1][i];
        while(a<=n && num[0][a] < key) a++;
        while(c<=n && num[2][c] <= key) c++;

        ans += (LL)(a-1)*(n-c+1);

    }
    cout<<ans<<endl;
    return 0;
}

```



### åŠ›æ‰£80

åŒæŒ‡é’ˆ

### æ»‘åŠ¨çª—å£

#### 3åŠ›æ‰£æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­—ä¸²

æˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆç»´æŠ¤æœ€é•¿ä¸é‡å¤å­ä¸²ï¼Œ

æˆ‘ä»¬çŸ¥é“ï¼Œr0-rkä¹‹é—´çš„å­—ç¬¦ä¸²æ˜¯ä¸é‡å¤çš„ï¼Œåˆ™r1-rkä¹‹é—´çš„å­—ä¸²ä¹Ÿæ˜¯ä¸é‡å¤çš„ï¼Œè¿™æ˜¯è¯¥é¢˜è§£çš„åŸºç¡€

å½“å‡ºç°é‡å¤å­—ç¬¦çš„æ—¶å€™ï¼Œå‡ºåˆ—æœ€å·¦è¾¹ï¼Œæ­¤æ—¶r1-rkä¸€å®šæ˜¯ä¸é‡å¤çš„å•¦

```c++
//æ»‘åŠ¨çª—å£
//unordered_set
class Solution {
public:

    int lengthOfLongestSubstring(string s) {
        unordered_set<char>occ;
        int n=s.size();
        int rk=-1,ans=0;//ä¸€èˆ¬æ»‘åŠ¨æ•°ç»„éƒ½ç”¨-1ä½œä¸ºå¼€å§‹
        for(int i=0;i<n;i++){
            if(i!=0){
                occ.erase(s[i-1]);
            }
            while(rk+1<n&&!occ.count(s[rk+1])){
                occ.insert(s[rk+1]);
                ++rk;
            }
            ans=max(ans,rk-i+1);
        }
        return ans;

    }
};
```



# å›¾

### 133å…‹éš†å›¾

é¢˜è§£1æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé¢˜è§£å·²ç»å†™çš„å¾ˆæ¸…æ¥šäº†ä¸€ä¸ªæ— å‘å›¾å®é™…åœ¨ä»£ç ä¸­å¦‚ä½•å­˜å‚¨ï¼š

![image-20240506194705392](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240506194705392.png)

é¢˜è§£2å¹¿æœï¼Œè¿˜æ˜¯è¦æ¨¡æ‹Ÿä¸€ä¸‹æ‰å¯ä»¥ï¼ï¼

# æ’åº

### å †æ’åº

#### 15å±Šè“æ¡¥æ¯çˆ¬å±±

```c++
#include <iostream>
#include<cmath>
#include<queue>
using namespace std;
//å †ç»´æŠ¤æœ€å€¼+è´ªå¿ƒ
//æ—¶é—´å¤æ‚åº¦nlogn

int main() {
    priority_queue<int>pq;//å¤§æ ¹å †
    int n, p, q; cin >> n>>p >> q;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        pq.push(x);
    }

    while (p || q) {
        int cur = pq.top();
        pq.pop();
        if (p) {
            cur = sqrt(cur);
            p--;
        }
        else if(q){
            cur /= 2;
            q--;
        }
        pq.push(cur);
    }

    int s=0;
    while (!pq.empty()) {
        s += pq.top();
        pq.pop();
    }

    cout << s;

    
    return 0;
}

```



### æ‹“æ‰‘æ’åº

#### 207è¯¾ç¨‹è¡¨

è¯¦æƒ…[æ‹“æ‰‘æ’åº - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/topo/)

# æ¨¡æ‹Ÿé¢˜

### åŠ›æ‰£100321

# é«˜ç²¾åº¦ç®—æ³•

### é«˜ç²¾åº¦åŠ æ³•

é«˜ç²¾åº¦åŠ æ³•å¯¹æ¯”é«˜ç²¾åº¦å‡æ³•ç®€å•äº†å¥½å¤š

1.å¤„ç†è¿›ä½é—®é¢˜ï¼Œcarryè®°å½•è¿›ä½ï¼Œæœ€åè¦åˆ¤æ–­è¿›ä½æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸ä¸ºé›¶ï¼Œè¿˜è¦åŠ ä¸Šè¿›ä½

```c++
#include <iostream>
#include <string>
#include <algorithm>

// é«˜ç²¾åº¦åŠ æ³•å‡½æ•°
std::string highPrecisionAdd(const std::string& num1, const std::string& num2) {
    int len1 = num1.size();
    int len2 = num2.size();
    int maxLength = std::max(len1, len2);

    std::string result;
    int carry = 0; // è¿›ä½

    // ä»æœ€ä½ä½å¼€å§‹é€ä½ç›¸åŠ  
    for (int i = 0; i < maxLength; i++) {
        int digit1 = (i < len1) ? num1[len1 - 1 - i] - '0' : 0;
        int digit2 = (i < len2) ? num2[len2 - 1 - i] - '0' : 0;
        int sum = digit1 + digit2 + carry;
        carry = sum / 10;
        result.push_back(sum % 10 + '0');
    }

    // æœ€åå¤„ç†è¿›ä½
    if (carry) {
        result.push_back(carry + '0');
    }

    // åè½¬ç»“æœå­—ç¬¦ä¸²
    std::reverse(result.begin(), result.end());

    return result;
}

int main() {
    std::string num1, num2;
    std::cout << "Enter the first large number: ";
    std::cin >> num1;
    std::cout << "Enter the second large number: ";
    std::cin >> num2;

    std::string result = highPrecisionAdd(num1, num2);
    std::cout << "Result of addition: " << result << std::endl;

    return 0;
}

```



### é«˜ç²¾åº¦å‡æ³•

é«˜ç²¾åº¦åŠ æ³•éœ€è¦è§£å†³çš„é—®é¢˜ï¼š

1.å¦‚æœä¸¤ä¸ªæ•°ç›¸ç­‰ï¼Œç›´æ¥è¿”å›0å³å¯

2.å¦‚æœä¸¤ä¸ªæ•°ä¸ç­‰ï¼Œå¦‚ä½•è®©å¤§çš„é‚£ä¸ªæ•°æ”¾åˆ°å‰é¢ï¼Œå¹¶å¤„ç†è´Ÿå·çš„é—®é¢˜

3.å¦‚ä½•å¤„ç†å€Ÿä½é—®é¢˜ï¼Œæ¯”å¦‚100å€Ÿä½

4.å¦‚ä½•å¤„ç†ä¸¤ä¸ªæ•°çš„ä½æ•°ä¸ä¸€è‡´é—®é¢˜

5.å»é™¤å‰å¯¼é›¶

```c++
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

// å­—ç¬¦ä¸²å‡æ³•ï¼Œç”¨äºé«˜ç²¾åº¦å‡æ³•è¿ç®—
string subtract(string& a, string& b) {
    // ç¡®ä¿ a >= b
    if (a == b) {
        return "0";
    }

    bool flag = false;
    if (a.size() < b.size()) {
        swap(a, b);
        flag = true;
    }

    else if (a.size() == b.size() && a < b) {
        swap(a, b);
        flag = true;
    }

    string result;
    int carry = 0;
    int lenA = a.size();
    int lenB = b.size();

    for (int i = 0; i < lenA; ++i) {
        int numA = a[lenA - 1 - i] - '0';
        int numB = i < lenB ? b[lenB - 1 - i] - '0' : 0;

        int temp = numA - numB - carry;

        if (temp < 0) {
            temp += 10;
            carry = 1;
        }
        else {
            carry = 0;
        }

        result.push_back(temp + '0');
    }
    
    

    // å»é™¤ç»“æœä¸­çš„å‰å¯¼é›¶
    while (result.size() > 1 && result.back() == '0') {
        result.pop_back();
    }
    
    reverse(result.begin(), result.end());

    
    if (flag) result.insert(result.begin(), '-');
    return result;
}

int main() {
    string a, b;
    
    cin >> a;
    //cout << "Enter the subtrahend: ";
    cin >> b;
    cout << "Result: " << subtract(a, b) << endl;
    return 0;
}

```



### é«˜ç²¾åº¦ä¹˜æ³•

é«˜ç²¾åº¦ä¹˜æ³•æ²¡æœ‰ç¿»è½¬å­—ç¬¦ä¸²

ä½¿ç”¨vectoræ•°ç»„å­˜å‚¨æ¯ä¸€ä½æ•°å­—ï¼Œæœ€åè®°å¾—è½¬åŒ–æˆå­—ç¬¦ä¸²å³å¯

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
string multiple(string a, string b) {
    int la = a.size(), lb = b.size();
    vector<int>result(la + lb, 0); 
    int sum = 0, num = 0;
    for (int i = la - 1; i >= 0; i--) {
        for (int j = lb - 1; j >= 0; j--) {
            num = (a[i] - '0') * (b[j] - '0');
            sum = num + result[i + j + 1];
            result[i + j + 1] = sum % 10;
            result[i + j] += sum / 10;
        }
    }


    string ans;
    int n = result.size();
    for (int i=0; i <n; i++) {
        if (!(ans.empty() && result[i] == 0)) {
            ans.push_back(result[i] + '0');
        }
    }

    return ans.empty() ? 0 : ans;
}
int main() {
    string a, b;
    cin >> a >> b;
    string ans = multiple(a, b);
    cout << ans;
    return 0;
}

```



### é«˜ç²¾åº¦é™¤æ³•

1.é«˜ç²¾åº¦é™¤ä»¥ä½ç²¾åº¦ï¼ˆé€ä½è¯•å•†ï¼‰ 

```c++
#include<iostream>
#include<string>
using namespace std;
string func(string a, string b) {
	long long y = stoll(b);
	int la = a.size();
	string c(la, '0');
	long long sum = 0, carry = 0;
	for (int i = 0; i < la; i++) {
		sum = (carry * 10 + a[i] - '0');
		c[i] = (sum / y)+'0';
		carry = sum % y;
	}

	int i = 0;
	while (c.size()>1&&c[i] == '0') c.erase(c.begin());
	return c;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



2.é«˜ç²¾åº¦é™¤ä»¥é«˜ç²¾åº¦

ä»¥å‡æ³•ä»£æ›¿é™¤æ³•çš„è¿ç®—

```c++
#include<iostream>
#include<string>
using namespace std;
string func2(string a, string b) {
	string result;

	int na = a.size();
	int nb = b.size();

	int i;
	int carry = 0;

	for (i = 0; i < na; i++) {
		int numa = a[na - i - 1]-'0';
		int numb = i < nb ? b[nb - i - 1]-'0' : 0;
		int temp = numa - numb - carry;
		if (temp < 0) {
			temp += 10;
			carry = 1;
		}
		else carry = 0;

		result.push_back(temp + '0');
	}


	while (result.size() > 1 && result.back() == '0') {
		result.pop_back();
	}

	reverse(result.begin(), result.end());
	return result;
}

bool issmaller(string x, string y) {
	int lx = x.size(), ly = y.size();
	if (lx < ly) return true;
	else if (lx == ly && x < y) return true;
	return false;
}
string func(string a, string b) {
	int la = a.size(), lb = b.size();
	int lc = la - lb + 1;
	string c;
	int cnt = 0;
	char ch;
	for (int i = lc; i > 0; i--) {
		string temp(i - 1, '0');
		temp = b + temp;
		while (!issmaller(a, temp)) {
			cnt++;
			a = func2(a, temp);
		}
		ch = cnt + '0';
		c += ch;
		cnt = 0;
	}

	//å»é™¤å‰å¯¼é›¶
	int i = 0;
	while (c.size() > 1 && c[i] == '0') c.erase(c.begin());
	return c;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



### é«˜ç²¾åº¦å–æ¨¡

1.é«˜ç²¾åº¦å–æ¨¡ä½ç²¾åº¦

```c++
#include<iostream>
#include<string>
using namespace std;

int main() {
	string a, b;
	cin >> a >> b;
	a += b;
	int result = 0;
	int mod = 1000000007;
	for (auto i : a) {
		result = (result * 10 + (i - '0')) % mod;
	}

	cout << result;
}
```





2é«˜ç²¾åº¦å–æ¨¡é«˜ç²¾åº¦

```
#include<iostream>
#include<string>
using namespace std;
string func2(string a, string b) {
	string c;

	int na = a.size();
	int nb = b.size();

	int carry = 0;
	int i;
	for (i = 0; i < na; i++) {
		int numa = a[na - i - 1] - '0';
		int numb = i < nb ? b[nb - 1 - i] - '0' : 0;
		int temp = numa - numb-carry;
		if (temp < 0) {
			temp += 10;
			carry = 1;
		}
		else {
			carry = 0;
		}
		c.push_back(temp + '0');

	}

	reverse(c.begin(), c.end());
	i = 0;
	while (c.size() > 1 && c[i] == '0') c.erase(c.begin());
	
	return c;
}

bool issmaller(string x, string y) {
	int lx = x.size(), ly = y.size();
	if (lx < ly) return true;
	else if (lx == ly && x < y) return true;
	return false;
}
string func(string a, string b) {
	if (issmaller(a, b)) return a;
	int la = a.size(), lb = b.size();
	int lc = la - lb + 1;
	for (int i = lc; i > 0; i--) {
		string temp(i - 1, '0');
		temp = b + temp;
		while (!issmaller(a, temp)) {
			a = func2(a, temp);
		}
	}
	return a;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



### åŠ›æ‰£100297
