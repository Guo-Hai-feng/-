

# 排序算法

### 88力扣合并两个有序数组

注解：课本学到的是构建一个额外的数组，本题固定了这个空间在num1,**所以使用倒叙**就可以了

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i=m-1;
        int j=n-1;
        int k=m+n-1;
        while(i>=0&&j>=0){
            if(nums1[i]>=nums2[j]){
                nums1[k]=nums1[i];
                k--;
                i--;
            }
            else{
                nums1[k]=nums2[j];
                k--;
                j--;
            }
        }
        while(i>=0){
            nums1[k]=nums1[i];
            k--;
            i--;
        }
        while(j>=0){
            nums1[k]=nums2[j];
            k--;
            j--;
        }

    }
};
```

### 力扣LCR075数组的相对排序

![image-20240229234611341](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229234611341.png)

```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        for (int i = 0; i < arr2.size(); ++i) {
            rank[arr2[i]] = i;
        }
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            if (rank.count(x)) {
                return rank.count(y) ? rank[x] < rank[y] : true;
            }
            else {
                return rank.count(y) ? false : x < y;
            }
        });
        return arr1;
    }
};
//sort函数接收三个参数，前两个参数是排序的起点和终点迭代器，最后一个参数是一个自定义函数，用来定义排序规则

/*[&]是lambda表达式的捕获列表（Capture List）。在C++中，lambda表达式可以捕获外部作用域中的变量，以便在lambda函数体中使用。捕获列表指定了如何捕获这些变量。

[&]是一种捕获列表的形式，其中的&表示捕获外部作用域中的所有变量并按引用（reference）捕获。这意味着lambda函数体中使用的外部变量都是通过引用访问的，对这些变量的修改会影响到外部作用域中的原始变量。

在这段代码中，lambda表达式 [&](int x, int y) 捕获了所有外部作用域中的变量，并以引用的方式访问它们。这样做的目的是在lambda函数体中可以使用 rank 这个外部作用域中的变量，而不需要额外传递参数。*/

=
```



![image-20240229234951333](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229234951333.png)



```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        for (int i = 0; i < arr2.size(); ++i) {
            rank[arr2[i]] = i;
        }
        auto mycmp = [&](int x) -> pair<int, int> {
            return rank.count(x) ? pair{0, rank[x]} : pair{1, x};
        };
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            return mycmp(x) < mycmp(y);
        });
        return arr1;
    }
};
```



![image-20240229235107812](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229235107812.png)

```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        int n = arr2.size();
        for (int i = 0; i < n; ++i) {
            rank[arr2[i]] = i - n;
        }
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            return (rank.count(x) ? rank[x] : x) < (rank.count(y) ? rank[y] : y);
        });
        return arr1;
    }
};

```



# 位运算

### 力扣位1的个数

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;

        // 遍历二进制表示中的每一位
        while (n != 0) {
            // 判断最低位是否为1
            if (n & 1) {
                count++;
            }
            // 右移一位，继续判断下一位
            n >>= 1;
        }

        return count;
    }
};

```



### 异或运算

异或运算的性质如下：

1. 任何数和0做异或运算，结果仍然是原来的数，即 a ^ 0 = a。
2. 任何数和其本身做异或运算，结果是0，即 a ^ a = 0。
3. 异或运算满足**交换律和结合律**，即 a ^ b ^ a = b ^ a ^ a = b ^ (a ^ a) = b ^ 0 = b。
4. 异或运算可以用来交换两个变量的值，例如：a = a ^ b; b = a ^ b; a = a ^ b;。

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
       int ans=nums[0];
       if(nums.size()>1)
       {
           for(int i=1;i<nums.size();i++)
           {
               ans=ans^nums[i];
           }
       }

    return ans;
    }
};
```

### 力扣汉明距离

int c = 100;

c>>=1//右移一位，表示除二

c>>=2//右移两位，表示除4

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int c = x ^ y;
        int count = 0;
        while(c != 0){
            if(c & 1){
                count +=1;
            }
            c>>=1;
        }
        return count;      
    }
};
```

### 力扣颠倒二进制位

```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        int count = 32; // 直接设置为32，无需循环计算
        long sum = 0;
        while (n != 0 && count > 0) {
            if (n & 1) {
                sum |= (1 << (count - 1)); // 使用位运算代替求幂操作
            }
            count -= 1;
            n >>= 1;
        }
        return sum;
    }
};

```

`sum |= (1 << (count - 1));` 是一个位运算操作，用于将 `sum` 的第 `(count-1)` 位设置为1。(从第0位开始计数)

1. `(count - 1)` 计算出要设置的位的位置。在二进制中，最低位的位置是0，依次递增。
2. `1 << (count - 1)` 是将数字1左移 `(count - 1)` 位。这实际上是在二进制中将1移动到指定的位置，其余位填充为0。
3. `sum |= (1 << (count - 1));` 利用 `|=` 按位或等于操作符，将 `sum` 的第 `(count-1)` 位设置为1。如果 `sum` 的这一位原本是0，它将变为1；如果原本是1，则保持不变。

#### 检测奇偶性

```c++
#include <iostream>

int main() {
    int number;

    std::cout << "Enter an integer: ";
    std::cin >> number;

    if (number & 1) {
        std::cout << "The number is odd." << std::endl;
    }
    else {
        std::cout << "The number is even." << std::endl;
    }

    return 0;
}

```



#### 循环位移

```c++
#include <iostream>
//不考虑二进制负数

int leftRotate(unsigned int value, int shift) {
    // 使用位运算实现左循环位移
    return (value << shift) | (value >> (sizeof(value) * 8 - shift));
}

int main() {
    unsigned int number = 0b110110;  // 二进制表示为 110110

    // 左循环位移3位
    unsigned int rotatedNumber = leftRotate(number, 3);
    return 0;
}

```



1. `(value << shift)`: 这部分将 `value` 左移 `shift` 位，即将二进制数左移 `shift` 位。例如，如果 `value` 是 `110110`，而 `shift` 是 `3`，那么这部分的结果就是 `110`。
2. `(value >> (sizeof(value) * 8 - shift))`: 这部分是将 `value` 右移 `(sizeof(value) * 8 - shift)` 位。`sizeof(value)` 返回的是 `value` 变量所占用的字节数，通常为 4（32 位系统）或 8（64 位系统）。因此，`(sizeof(value) * 8)` 返回的是 `value` 变量所占用的位数。`(sizeof(value) * 8 - shift)` 就是剩余的位数，即右移的位数。例如，如果 `value` 是 `110110`，而 `shift` 是 `3`，那么这部分的结果就是 `110000000`。
3. `|`: 这是按位或操作符，它会将两个操作数的对应位进行或操作，即只要有一个位是 1，结果的对应位就是 1。

# 区间问题

|          | 区间求和 | 区间最大值 | 区间修改 | 单点修改 |
| -------- | -------- | ---------- | -------- | -------- |
| 前缀和   | 1        | 0          | 0        | 0        |
| 差分     | 0        | 0          | 1        | 0        |
| 树状数组 | 1        | 1          | 0        | 1        |
| 线段树   | 1        | 1          | 1        | 1        |

## 前缀和

```c++
prefixSum[i]=arr[0]+arr[1]+⋯+arr[i−1]+arr[i]
    
//其中prefixsum[0]=0;
```



###  **求任意区间的和**

```c++
//区间[l,r]等于prefixsum[r]-prefixsum[l-1];
#include<iostream>
using namespace std;
int arr[1010];
int s[10010];
int main() {
	int n, m;
	scanf("%d ", &n,&m);
	for (int i = 1; i <= n; i++) {//下标从一开始，如果下标从零开始要重新设计
		scanf("%d", &arr[i]);
		s[i] = s[i - 1] + arr[i];
	}
	while (m--) {
		int l, r;
		scanf("%d %d", &l, &r);
		printf("%d", s[r] - s[l - 1]);
	}
	return 0;
	
	
}
```



### 力扣3179

### 二维前缀和

https://www.bilibili.com/video/BV18P411g7cu/?spm_id_from=333.337.search-card.all.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

```c++
//二维前缀和s[i][j]表示前i行前j列的矩阵元素之和
//i1行,j1列与i2行，j2列之间的矩阵元素之和


#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n, m;
    int arr[105][105] = {0}; // 初始化二维数组为0，避免垃圾值
    long long s[106][106] = {0}; // 前缀和数组

    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> arr[i][j];
        }
    }

    // 构建前缀和数组
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + arr[i][j];
        }
    }

    int t;
    cin >> t;
    for (int i = 0; i < t; i++) {
        int i1, j1, i2, j2;
        cin >> i1 >> j1 >> i2 >> j2;
        long long result = s[i2][j2] - s[i1-1][j2] - s[i2][j1-1] + s[i1-1][j1-1];
        cout << result << endl; // 每个查询结果之后换行
    }

    return 0;
}

```



### ACWing1236递增三元组

刷第二遍，看错题目了...

```c++
#include<iostream>
using namespace std;
int n;
int a[100010],b[100010],c[100010];
int cnta[100010],cntc[100010];
int sa[100010],sc[100010];
//用cnta,cntc表示数组a,c对应元素出现的次数，需要注意的是因为数组是顺序的，所以相当于我们排了序
//比如假设数组a是1，2，3，5，5，6（下标从1开始）
//那么cnta对应的是1 1 1 0 2 1
//这下清楚了吧！因为排了序，所以对于特定的b[i],在i前面的就是小于b[i]的
int main(){
    cin>>n;
    long long res=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        cnta[++a[i]]++;
    }
    
    sa[0]=cnta[0];//我终于知道为什么了！因为s[0]一般默认为零，前0项的和嘛，但是这一题的数据可以为0
    //为了避免冲突，++a[i]一定大于零了，所以cnta[0]=0,满足了sa[0]=0;
    for(int i=1;i<100010;i++) sa[i]=sa[i-1]+cnta[i];//注意这里，因为n的取值范围是100000
    //所以cnta[i]的取值范围是0-100000，万一都是一个数呢，比如11111111
    for(int i = 1; i <= n; ++i){
        scanf("%d", &b[i]);
        b[i]++;
    } 
    for(int i=1;i<=n;i++){
        scanf("%d",&c[i]);
        cntc[++c[i]]++;
    }
    sc[0]=cntc[0];
    for(int i=1;i<100010;i++) sc[i]=sc[i-1]+cntc[i];
    for(int i=1;i<=n;i++){
        res+=(long long)sa[b[i]-1]*(sc[100010-1]-sc[b[i]]);
    }
    cout<<res;
    return 0;
    
}
```



## 一维差分

差分数组用于快速更新数组的某一段区间内的元素值。差分数组的主要思想是通过记录变化量来间接表示数组的更新。相较于直接更新数组中的每个元素，**差分数组可以在常数时间内对数组进行区间更新。**

### 性质

1. 对于差分数组`0 0 0 0 0`,对d[1]加一的结果是对原数组区间[1,n-1]都加上1
2. 使用差分数组可以在常数时间内对原数组的某个区间进行更新操作。
3. 差分数组的前缀和是原数组
4. 前缀和数组做一次差分也会返回到原数组
5. 差分数组适用于多次更新，单次查询的场景
6. 对区间[l,r]都加上value，只需要将差分数组：`d[l]+value,d[r+1]-value`,在做前缀和即可得到结果

### 一维代码实现

定义差分数组`d[i]=arr[i]-arr[i-1]`

其中`d[0]=arr[0]`

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<int> constructDifferenceArray(const vector<int>& arr) {
    int n = arr.size();
    vector<int> diff(n + 1, 0);
    diff[0] = arr[0];
    for (int i = 1; i < n; i++) {
        diff[i] = arr[i] - arr[i - 1];
    }
    return diff;
}

void updateDifferenceArray(vector<int>& diff, int l, int r, int x) {
    diff[l] += x;
    if (r + 1 < diff.size()) {
        diff[r + 1] -= x;
    }
}

vector<int> restoreArrayFromDifferenceArray(const vector<int>& diff) {
    int n = diff.size();
    vector<int> arr(n, 0);
    arr[0] = diff[0];
    for (int i = 1; i < n; i++) {
        arr[i] = arr[i - 1] + diff[i];
    }
    return arr;
}

int main() {
    vector<int> arr = {2, 4, 6, 8, 10};
    vector<int> diff = constructDifferenceArray(arr);

    // Perform update operation: add 3 to the range [1, 3]
    updateDifferenceArray(diff, 1, 3, 3);

    // Restore the updated array
    vector<int> updatedArr = restoreArrayFromDifferenceArray(diff);

    for (int val : updatedArr) {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}

```





## 二维差分

https://www.bilibili.com/video/BV1pi4y1j7si/?p=4&spm_id_from=pageDriver&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

`b[i][j]=a[i][j]−a[i−1][j]−a[i][j−1]+a[i−1][j−1]`

### 性质

1. 对于二维差分数组`b[i][j]`,如果`b[i][j]+1`,会影响到后续的一整块区域



```c++
#include <iostream>
#include <vector>
using namespace std;

// 构造差分数组
void constructDifferenceArray(const vector<vector<int>>& a, vector<vector<int>>& differenceArray) {
    int m = a.size();
    int n = a[0].size();

    differenceArray[0][0] = a[0][0];
    for (int i = 1; i < m; i++) differenceArray[i][0] = a[i][0] - a[i - 1][0];
    for (int j = 1; j < n; j++) differenceArray[0][j] = a[0][j] - a[0][j - 1];
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            differenceArray[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
        }
    }
}

// 更新差分数组
void updateDifferenceArray(vector<vector<int>>& differenceArray, int x1, int y1, int x2, int y2, int value) {
    differenceArray[x1][y1] += value;
    int m = differenceArray.size();
    int n = differenceArray[0].size();

    if (x2 + 1 < m) {
        differenceArray[x2 + 1][y1] -= value;
    }
    if (y2 + 1 < n) {
        differenceArray[x1][y2 + 1] -= value;
    }
    if (x2 + 1 < m && y2 + 1 < n) {
        differenceArray[x2 + 1][y2 + 1] += value;
    }
}

// 从差分数组恢复原始数组
void restoreArrayFromDifferenceArray(vector<vector<int>>& a, const vector<vector<int>>& differenceArray) {
    int m = a.size();
    int n = a[0].size();
    a[0][0] = differenceArray[0][0];

    for (int j = 1; j < n; j++) {
        a[0][j] = a[0][j - 1] + differenceArray[0][j];
    }
    for (int i = 1; i < m; i++) {
        a[i][0] = a[i - 1][0] + differenceArray[i][0];
    }

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + differenceArray[i][j];
        }
    }
}

int main() {
    vector<vector<int>> a = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int m = a.size();
    int n = a[0].size();
    vector<vector<int>> differenceArray(m, vector<int>(n, 0));

    // 构造初始差分数组
    constructDifferenceArray(a, differenceArray);

    // 更新差分数组
    updateDifferenceArray(differenceArray, 0, 0, 1, 1, 10);

    // 恢复更新后的原数组
    restoreArrayFromDifferenceArray(a, differenceArray);

    // 打印更新后的原数组
    cout << "Updated Original Array:" << endl;
    for (const auto& row : a) {
        for (const auto& elem : row) {
            cout << elem << " ";
        }
        cout << endl;
    }

    return 0;
}

```



## 线段树

**定义**

线段树是一棵二叉树，通常用来存储数组区间的信息。每个节点表示一个区间，节点的值通常表示该区间的一些属性（如区间和、区间最小值等）。线段树的根节点表示整个数组的区间，根节点的两个子节点分别表示数组的左半部分和右半部分，依此类推。

线段树算法中常用到：

1. nodeindex：表示当前节点下标
2. start表示data数组区间左端点下标
3. end表示data数组区间右端点下标
4. leftindex表示当前访问端点左孩子下标
5. rightindex表示当前访问端点右孩子下标 



​      

**用途**

1. **区间查询**：例如，查询数组某个区间内的最小值、最大值、和、乘积等。请注意，区间查询下标是数组下标！！
2. **区间更新**：例如，将数组某个区间内的每个元素都增加一个固定值，或将某个区间内的值全部设为某个值。
3. **动态数据处理**：线段树支持在数据更新的同时，保持快速的查询性能，适合动态数据处理场景。

 		

**时间复杂度**

- 线段树的查询和更新操作的时间复杂度为 𝑂(log⁡𝑛)。
- 线段树的构建时间复杂度为 𝑂(𝑛)。





**懒惰标记线段树**

懒惰标记（Lazy Propagation）是一种优化技术，用于提高线段树处理区间更新操作的效率。它通过推迟更新操作直到真正需要时才进行，从而避免在每次更新时对整个区间进行重复操作。这样可以显著减少更新操作的时间复杂度。

在标准线段树中，每次更新操作都会影响到相关区间的所有节点，导致时间复杂度较高。懒惰标记通过以下方式优化：

1. **延迟更新**：将更新操作记录在懒惰标记数组中，而不立即更新所有相关节点。
2. **传播更新**：在查询或进一步更新操作时，再将之前记录的更新操作应用到相关节点上。



**懒惰标记机制的实现中，在进行线段树的查询和更新操作之前，通常会先检查当前节点是否有懒惰标记。这是为了确保在需要进行查询或更新操作时，首先将延迟更新应用到当前节点上，然后再进行相应的操作，从而保证数据的准确性和一致性。**



### 求和线段树

```c++
#include<iostream>
#include<vector>
#include<numeric>
using namespace std;
#include <vector>
using namespace std;

#include <vector>
#include <iostream>
using namespace std;

class SegmentTree {
private:
    vector<int> Tree;
    vector<int> Lazy;
    vector<int> data;
    int n;

    void BuildTree(int node, int start, int end) {
        if (start == end) {
            Tree[node] = data[start];
        }
        else {
            int mid = (start + end) / 2;
            int leftindex = 2 * node;
            int rightindex = 2 * node + 1;
            BuildTree(leftindex, start, mid);
            BuildTree(rightindex, mid + 1, end);
            Tree[node] = Tree[leftindex] + Tree[rightindex];
        }
    }

    void propagate(int node, int start, int end) {

        if (Lazy[node] != 0) {
            
            Tree[node] += (end - start + 1) * Lazy[node];
            if (start != end) {
                Lazy[node * 2] += Lazy[node];
                Lazy[node * 2 + 1] += Lazy[node];
            }
            Lazy[node] = 0;
        }
    }

    void updateRange(int node, int start, int end, int L, int R, int val) {
        propagate(node, start, end);
        if (start > end || start > R || end < L) {
            return;
        }

        if (L <= start && end <= R) {
            //如果当前区间被包含在查询区间中，那么就不继续向下更新，而是选择原路返回，用懒惰标记标记该节点
            //并且给左孩子和右孩子记账，等访问左孩子右孩子的时候，会先查一下该节点有没有父节点留下的帐
            //如果有，就要先更新，也就是本函数开头的propagate函数
            Tree[node] += (end - start + 1) * val;
            if (start != end) {
                Lazy[node * 2] += val;
                Lazy[node * 2 + 1] += val;
            }
            return;
        }

        int mid = (start + end) / 2;
        updateRange(node * 2, start, mid, L, R, val);
        updateRange(node * 2 + 1, mid + 1, end, L, R, val);
        Tree[node] = Tree[node * 2] + Tree[node * 2 + 1];
    }

    int queryRange(int node, int start, int end, int L, int R) {
        propagate(node, start, end);
        if (start > end || start > R || end < L) {
            return 0;
        }

        if (L <= start && end <= R) {
            return Tree[node];
        }

        int mid = (start + end) / 2;
        int leftSum = queryRange(node * 2, start, mid, L, R);
        int rightSum = queryRange(node * 2 + 1, mid + 1, end, L, R);
        return leftSum + rightSum;
    }

    


    //先找到对应节点，更新，后原路更新路径上所有节点的值
    void updateTree(int node, int start, int end, int idx, int val) {
        if (start == end) {
            data[idx] = val;
            Tree[node] = val;
        }
        else {
            int mid = (start + end) / 2;
            int leftChild = 2 * node + 1;
            int rightChild = 2 * node + 2;
            if (start <= idx && idx <= mid) {
                updateTree(leftChild, start, mid, idx, val);
            }
            else {
                updateTree(rightChild, mid + 1, end, idx, val);
            }
            Tree[node] = Tree[leftChild] + Tree[rightChild];
        }
    }

public:
    SegmentTree(const vector<int>& data) {
        this->data = data;
        this->n = data.size();
        Tree.resize(4 * n);
        Lazy.resize(4 * n, 0);
        BuildTree(1, 0, n - 1);
    }

    void update(int idx, int val) {
        updateTree(0, 0, n - 1, idx, val);
    }

    void updateRange(int L, int R, int val) {
        updateRange(1, 0, n - 1, L, R, val);
    }

  

    int queryRange(int L, int R) {
        return queryRange(1, 0, n - 1, L, R);
    }
};


int main() {
    std::vector<int> data(100);
    iota(data.begin(), data.end(), 1);
    
    SegmentTree segTree(data);
  
    
    return 0;

}
```



### 乘法(根号)线段树

当我们对区间进行同时加和乘的时候，应该有两个懒惰标记

乘法标记：初始值为1

加法标记：初始值为0

在pushdown函数中，首先获得该节点的乘法懒惰标记和加法懒惰标记

然后更新左右孩子节点的懒惰标记

左孩子的乘法懒惰标记等于左孩子乘法懒惰标记乘当前节点的乘法懒惰标记

左孩子的加法懒惰标记等于左孩子加法懒惰标记乘当前节点的乘法懒惰标记值加上当前节点的加法懒惰标记

```c++
#include <vector>
#include <iostream>

using namespace std;

const long long p = 1e9 + 7;

struct SegmentTreeNode {
    long long sum = 0;
    long long mlz = 1; // Multiplicative lazy tag, initially 1
    long long plz = 0; // Additive lazy tag, initially 0
    int l = 0, r = 0;
};

vector<SegmentTreeNode> tree;

// Initialize the segment tree with a given array size
void init(int n) {
    tree.resize(4 * n); // Allocate sufficient space for segment tree
}

// Build the segment tree
void build(vector<int>& arr, int i, int l, int r) {
    tree[i].l = l;
    tree[i].r = r;
    if (l == r) {
        tree[i].sum = arr[l];
        return;
    }
    int mid = (l + r) / 2;
    build(arr, 2 * i, l, mid);
    build(arr, 2 * i + 1, mid + 1, r);
    tree[i].sum = (tree[2 * i].sum + tree[2 * i + 1].sum) % p;
}

// Pushdown function to propagate lazy updates
void pushdown(int i) {
    long long k1 = tree[i].mlz, k2 = tree[i].plz;
    if (tree[i].l != tree[i].r) { // Not a leaf node
        // Update left child
        tree[2 * i].sum = (tree[2 * i].sum * k1 + k2 * (tree[2 * i].r - tree[2 * i].l + 1)) % p;
        tree[2 * i].mlz = (tree[2 * i].mlz * k1) % p;
        tree[2 * i].plz = (tree[2 * i].plz * k1 + k2) % p;

        // Update right child
        tree[2 * i + 1].sum = (tree[2 * i + 1].sum * k1 + k2 * (tree[2 * i + 1].r - tree[2 * i + 1].l + 1)) % p;
        tree[2 * i + 1].mlz = (tree[2 * i + 1].mlz * k1) % p;
        tree[2 * i + 1].plz = (tree[2 * i + 1].plz * k1 + k2) % p;
    }
    tree[i].mlz = 1;
    tree[i].plz = 0;
}

// Update function for range updates (multiplicative and additive)
void update(int i, int l, int r, long long k1, long long k2) {
    if (l <= tree[i].l && tree[i].r <= r) {
        tree[i].sum = (tree[i].sum * k1 + k2 * (tree[i].r - tree[i].l + 1)) % p;
        tree[i].mlz = (tree[i].mlz * k1) % p;
        tree[i].plz = (tree[i].plz * k1 + k2) % p;
        return;
    }
    pushdown(i);
    int mid = (tree[i].l + tree[i].r) / 2;
    if (l <= mid) update(2 * i, l, r, k1, k2);
    if (r > mid) update(2 * i + 1, l, r, k1, k2);
    tree[i].sum = (tree[2 * i].sum + tree[2 * i + 1].sum) % p;
}

// Query function to get the sum of a range
long long query(int i, int l, int r) {
    if (l <= tree[i].l && tree[i].r <= r) {
        return tree[i].sum;
    }
    pushdown(i);
    int mid = (tree[i].l + tree[i].r) / 2;
    long long res = 0;
    if (l <= mid) res = (res + query(2 * i, l, r)) % p;
    if (r > mid) res = (res + query(2 * i + 1, l, r)) % p;
    return res;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    init(n);
    build(arr, 1, 0, n - 1);

    // Example usage: updating range [1, 3] with k1 = 2 (multiplicative) and k2 = 3 (additive)
    update(1, 1, 3, 2, 3);
    cout << query(1, 1, 3) << endl; // Query the sum of range [1, 3]

    return 0;
}

```



### 线段树的应用

1. 区间最值查询和更新
应用：在给定数组中，查询某个区间内的最小值或最大值，以及在数组的某个位置更新一个值。
示例：在电商平台中，查询某一时间段内商品的最低价格。
2. 区间和查询和更新
应用：求数组某个区间内的元素和，以及在某个位置或区间内进行更新操作。
示例：统计某段时间内网站的总访问量，并能快速更新某天的访问量。
3. 区间乘积查询和更新
应用：查询数组某个区间内元素的乘积，并支持单点更新。
示例：在金融系统中，计算某段时间内的投资收益，并能快速更新某天的收益。
4. 区间最大公约数 (GCD) 查询
应用：查询数组某个区间内的最大公约数。
示例：在数学分析中，找到某个区间内所有数的最大公约数。
5. 区间最小公倍数 (LCM) 查询
应用：查询数组某个区间内的最小公倍数。
示例：在排班系统中，找到某段时间内多个周期任务的共同周期。
6. 区间众数查询
应用：在数组的某个区间内，查找出现次数最多的元素。
示例：统计某段时间内最热门的商品。
7. 区间逆序对查询
应用：计算数组某个区间内的逆序对数量。
示例：在排序算法的优化中，统计逆序对的数量以决定是否使用归并排序。
8. 区间最小值差查询
应用：查询某个区间内最小值和次小值之间的差值。
示例：在比赛成绩分析中，找到某段时间内成绩最接近的两名选手。
9. 动态求解直方图中的最大矩形面积
应用：求解动态变化的直方图中的最大矩形面积问题。
示例：在图像处理和分析中，找出图像中最大连通块的面积。
10. 字符串问题
应用：处理字符串的一些查询和更新操作，如区间字符统计、区间回文判断等。
示例：在文本编辑器中，统计某段文字中的特定字符出现次数。
11. 区间覆盖问题
应用：解决区间覆盖问题，如区间涂色、区间覆盖等。
示例：在地理信息系统（GIS）中，查询某块区域内的覆盖情况。
12. 数据压缩
应用：利用线段树进行数据压缩和稀疏矩阵的存储。
示例：在数据压缩算法中，用线段树记录稀疏矩阵的非零元素。
13. 动态排列统计
应用：统计动态排列中的逆序对、排列的顺序统计等。
示例：在实时排序系统中，统计动态排序结果的逆序对数量。
14. 多维线段树
应用：解决多维数据的区间查询和更新问题，如二维线段树。
示例：在图像处理和分析中，进行二维区域的快速统计和更新。

## 力扣100306

## 力扣3619

## 删除顺序表所有值为x的元素

要求时间复杂度为O（n），空间复杂度为O（1）

```c++
//整体建表
void func1(vector<int>& arr, int x) {
	int n = arr.size();
	int k = 0;
	for (int i = 0; i < n; i++) {
		if (arr[i] != x) {
			arr[k] = arr[i];
			k++;
		}		
	}

	arr.resize(k);
}

//元素移动法
void func2(vector<int>& arr, int x) {
	int i = 0;
	int n = arr.size();
	int k = 0;
	while (i < n) {
		if (arr[i] == x) {
			k++;
		}
		else {
			arr[i - k] = arr[i];
		}

		i++;
	}

	arr.resize(n - k);
}
```



### 把数组中奇数放到偶数的前面

```c++
//区间划分法
void func(vector<int>& arr) {
	int i = -1;
	int j = 0;
	int n = arr.size();
	for (j; j < n; j++) {
		if (arr[j] % 2 == 1) {
			i++;
			if (i != j) {
				swap(arr[i], arr[j]);
			}
		}
		
	}
	
}
```



# 树



### 力扣二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：  

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
//c语言先序递归遍历
//算法思路
//我们要理解搜索二叉树要保证所有左子树都比根节点小，所有右子树都比根节点大
//所以我们设置一个范围，首先是根节点的范围最大，然乎依次减小这个范围去递归，才能保证实现
//第一次这个范围很大，设置为整型数字的大小
//遍历左节点的时候，这个范围的上界变成根节点的数值，遍历右节点时，下界变成根节点的数值
//保证节点的数值在这个范围之内之后，遍历左子树,遍历右子树
bool judge(struct TreeNode* root,long int min_val,long int max_val){
    if (root==NULL){
        return true;
    }
    if ((root->val>=max_val)||(root->val<=min_val)){
        return false;
    }

    return judge(root->left,min_val,root->val) && judge(root->right,root->val,max_val);

}

bool isValidBST(struct TreeNode* root){
    long int min_val = -2147483649;
    long int max_val = 2147483648;
    return judge(root,min_val,max_val);

}
```

```c++
//c++递归遍历
//算法思路
//我们要理解搜索二叉树要保证所有左子树都比根节点小，所有右子树都比根节点大
//所以我们设置一个范围，首先是根节点的范围最大，然乎依次减小这个范围去递归，才能保证实现
//第一次这个范围很大，设置为整型数字的大小
//遍历左节点的时候，这个范围的上界变成根节点的数值，遍历右节点时，下界变成根节点的数值
//保证节点的数值在这个范围之内之后，遍历左子树,遍历右子树
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;//如果是空树，手动认为属于搜索二叉树
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        //遍历左子树和右子树，并且满足左子树和右子树都是搜索二叉树才可以
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};



//非递归
//记得使用STL里面的stack
class Solution {
public:
    bool helper(TreeNode* root) {
        if (root == nullptr) {
            return true;//如果是空树，认为属于搜索二叉树
        }
        //创建一个栈s
        stack<TreeNode*>s;
        TreeNode *prev=NULL;//pre是节点前一个节点
        while(root||s.empty())
        {
            while(root)
            {
                s.push(root);
                root=root->left;
            }
            root=s.pop();
            if(pre!=NULL&&root->val<=pre->val)//如果节点小于当前节点
                return false
            pre=root;
            root=root->right
        }
        return true;      
};
```

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def helper(node, lower=float('-inf'), upper=float('inf')) -> bool:
            if not node:
                return True

            val = node.val
            if val <= lower or val >= upper:
                return False

            if not helper(node.right, val, upper):
                return False
            if not helper(node.left, lower, val):
                return False
            return True

        return helper(root)
    
    #在这段代码中，float('-inf') 表示负无穷大，而 float('inf') 表示正无穷大。在Python中，这两个表示无穷大的常量可以用来表示一个范围的边界，例如在二叉搜索树的问题中，用于表示节点值的上下边界。
    
    
#中序非递归算法
#设置一个前节点
#二叉树的非递归遍历一般用栈来实现
#当根节点不等于空或者栈非空时，说明还没有遍历结束
#把当前根节点入栈，然后访问左孩子
#如果左孩子不等于空，继续循环，直到访问到空节点
#此时我们出栈根节点，然后判断这个根节点的数值是不是比前节点的数值大，如果是说明满足
#因为使用了非递归算法，当程序运行到结尾的时候还没有返回false，说明是搜索二叉树
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        if not root:
            return True
        prev = None
        stack = []
        #二叉搜索树中序遍历非递归方式
        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            #判断前一个节点是否大于等于当前节点，是则不是有效的搜索二叉树，返回False
            if prev and root.val <= prev.val:
                return False
            #保存前一个节点
            prev = root
            root = root.right
        return True
```

### 力扣对称二叉树

我的思路是：中序遍历二叉树，得到一个字符串，然后再判断该字符串是否是回文字符串，但是：

对于对称二叉树，中序遍历结果确实是一个回文串，但对于非对称二叉树，中序遍历结果同样可以是回文串。因此，中序遍历结果无法唯一地反映二叉树的对称性。

不过也有收获，你正确的写出了如何中序遍历二叉树然后的到字符串

```c++
    void InOrderTraverse(TreeNode* root, string &str) {
        if (root == nullptr) {
            return;
        }

        else
        {
            InOrderTraverse(root->left, str);
            str.push_back((char)root->val+'0');
            InOrderTraverse(root->right, str);
        }
    }

```

**算法思路**

**递归**

二叉树的问题通常涉及树的深度周游和广度周游算法

使用递归或迭代进行比较左右子树

```c++
#include <iostream>
#include <vector>
#include <utility>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr)
            return true;

        return isMirror(root->left, root->right);
    }

    bool isMirror(TreeNode* left, TreeNode* right) {
        if (left == nullptr && right == nullptr)
            return true;

        if (left == nullptr || right == nullptr)
            return false;

        return (left->val == right->val) &&
               isMirror(left->left, right->right) &&
               isMirror(left->right, right->left);
    }
};

int main() {
    // 创建一个对称的二叉树
    TreeNode* symmetricTree = new TreeNode(1);
    symmetricTree->left = new TreeNode(2);
    symmetricTree->right = new TreeNode(2);
    symmetricTree->left->left = new TreeNode(3);
    symmetricTree->left->right = new TreeNode(4);
    symmetricTree->right->left = new TreeNode(4);
    symmetricTree->right->right = new TreeNode(3);

    // 创建一个非对称的二叉树
    TreeNode* nonSymmetricTree = new TreeNode(1);
    nonSymmetricTree->left = new TreeNode(2);
    nonSymmetricTree->right = new TreeNode(2);
    nonSymmetricTree->left->right = new TreeNode(3);
    nonSymmetricTree->right->right = new TreeNode(3);

    Solution solution;

    // 测试对称的二叉树
    if (solution.isSymmetric(symmetricTree)) {
        cout << "symmetricTree is symmetric." << endl;
    } else {
        cout << "symmetricTree is not symmetric." << endl;
    }

    // 测试非对称的二叉树
    if (solution.isSymmetric(nonSymmetricTree)) {
        cout << "nonSymmetricTree is symmetric." << endl;
    } else {
        cout << "nonSymmetricTree is not symmetric." << endl;
    }

    return 0;
}

```

**迭代**

「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？**首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。**初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```c++
class Solution {
public:
    bool check(TreeNode *u, TreeNode *v) {
        queue <TreeNode*> q;
        q.push(u); q.push(v);
        while (!q.empty()) {
            u = q.front(); q.pop();
            v = q.front(); q.pop();
            if (!u && !v) continue;
            if ((!u || !v) || (u->val != v->val)) return false;

            q.push(u->left); 
            q.push(v->right);

            q.push(u->right); 
            q.push(v->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};


```

时间复杂度和空间复杂度都是on

### 力扣非递归层次遍历二叉树

```c++
#include <iostream>
#include <queue>

// 二叉树节点结构
struct BiNode {
    char data;  // 节点数据
    BiNode* lchild;  // 左孩子指针
    BiNode* rchild;  // 右孩子指针

    BiNode(char value) : data(value), lchild(nullptr), rchild(nullptr) {}
};

// 层次遍历函数
void LevelOrder(BiNode* root) {
    if (root == nullptr) {
        return;
    }

    std::queue<BiNode*> nodeQueue;
    nodeQueue.push(root);

    while (!nodeQueue.empty()) {
        BiNode* current = nodeQueue.front();//访问当前节点
        nodeQueue.pop();//弹出当前节点

        // 访问当前节点数据
        std::cout << current->data << " ";

        // 将左孩子入队
        if (current->lchild != nullptr) {
            nodeQueue.push(current->lchild);
        }

        // 将右孩子入队
        if (current->rchild != nullptr) {
            nodeQueue.push(current->rchild);
        }
    }
}

int main() {
    // 构建一个简单的二叉树
    BiNode* root = new BiNode('A');
    root->lchild = new BiNode('B');
    root->rchild = new BiNode('C');
    root->lchild->lchild = new BiNode('D');
    root->lchild->rchild = new BiNode('E');
    root->rchild->lchild = new BiNode('F');
    root->rchild->rchild = new BiNode('G');

    // 执行层次遍历
    std::cout << "层次遍历结果: ";
    LevelOrder(root);

    return 0;
}
```



# 字符串

### 15届蓝桥杯R格式

高精度加法加高精度乘法加快速幂

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
string multiple(string a, string b) {
    int la = a.size(), lb = b.size();
    vector<int>result(la + lb, 0);
    int sum = 0, num = 0;
    for (int i = la - 1; i >= 0; i--) {
        for (int j = lb - 1; j >= 0; j--) {
            num = (a[i] - '0') * (b[j] - '0');
            sum = num + result[i + j + 1];
            result[i + j + 1] = sum % 10;
            result[i + j] += sum / 10;
        }
    }


    string ans;
    int n = result.size();
    for (int i=0; i <n; i++) {
        if (!(ans.empty() && result[i] == 0)) {
            ans.push_back(result[i] + '0');
        }
    }

    return ans.empty() ? "0" : ans;
}

int finddot(double d) {
    string dd = to_string(d);
    int i = 0;
    i = dd.find('.');
    return dd.size() - 1 - i;

}

string quickmultiple(int n) {
    string ans = "1";
    string b = "2";
    while (n) {
        if (n & 1) {
            ans = multiple(ans, b);
        }
        b = multiple(b,b);
        
        n >>=1;
    }
    return ans;
}

//再写一个高精度加法，万一是999.5
int main() {
    int n;
    string d;
    cin >> n >> d;
    int dotindex = d.find('.');
    int count = d.size() - dotindex - 1;
    d.erase(d.begin() + dotindex, d.begin() + dotindex + 1);
    string two = quickmultiple(n);
    string ans = multiple(two, d);
   
    //不是简单的向上取整
    int judge = ans[ans.size() - count] - '0';
    if (judge > 4) {
        int carry = 1;
        int n = ans.size()-count;
        while (n--) {      
           int sum= ans[n] -'0'+carry;
           ans[n] = sum % 10 + '0';
           carry = sum / 10;
        }
        if (carry != 0) {
            ans.insert(ans.begin(), carry % 10 + '0');
        }

        ans.resize(ans.size() - count);

        cout << ans;
        
    }
    else {
        ans.resize(ans.size() - count);
        cout << ans;

    }
    
    return 0;
}

```





### 十六进制转八进制

数据范围：保证每个十六进制数，位数不多余100000位

第一行输入n表示有n个十六进制数

第2-n+1行输入十六进制数



//需要注意的是这个数太大，我们只能通过字符串读取

```c++
#include<bits/stdc++.h>
using namespace std;
string hextobin(string hexstring) {
	string binstring;
	int n=hexstring.size();
	for (int i=0;i<n;i++) {
		switch (hexstring[i]) {
		case '0': binstring += "0000";
			break;
		case '1': binstring += "0001";
			break;
		case '2': binstring += "0010";
			break;
		case '3': binstring += "0011"; 
			break;
		case '4': binstring += "0100";
			break;
		case '5': binstring += "0101";
			break;
		case '6': binstring += "0110";
			break;
		case '7': binstring += "0111";
			break;
		case '8': binstring += "1000";
			break;
		case '9': binstring += "1001";
			break;
		case 'A': binstring += "1010";
			break;
		case 'B': binstring += "1011";
			break;
		case 'C': binstring += "1100";
			break;
		case 'D': binstring += "1101";
			break;
		case 'E': binstring += "1110";
			break;
		case 'F': binstring += "1111";
			break;
		}
	}
	return binstring;
}

string bintooct(string binstring){
	string octstring;
	int n=binstring.size();
	string tmp;
	int tmpt;
	for(int i=0;i<n;i+=3){
		tmp=binstring.substr(i,3);
		tmpt=((tmp[0]-'0')*pow(2,2))+((tmp[1]-'0')*pow(2,1))+(tmp[2]-'0');
		octstring+=tmpt+'0';
	}
	return octstring;
}
int main() {
	int n;
	cin >> n;
	string hexstring,binstring,octstring;
	for (int i = 0; i < n; i++) {
		cin >> hexstring;
		binstring=hextobin(hexstring);
		int addzero=3-(binstring.size()%3);
		binstring.insert(0,addzero,'0');
		octstring=bintooct(binstring);
		cout<<octstring<<endl;
	}

	return 0;

}

```



### 十六进制转十进制

题目条件是不大于八位的十六进制数，八位的最大值是FFFFFFFF，恰好是64位int的最大值

```c++
#include<bits/stdc++.h>
using namespace std;
int hextodec(string hexstring){
	string decstring;
	int ans;
	int n=hexstring.size();
	for (int i=0;i<n;i++) {
		switch (hexstring[i]) {
		case '0': ans+=0;
			break;
		case '1': ans+=pow(16,n-i-1);
			break;
		case '2': ans+=2*pow(16,n-i-1);
			break;
		case '3': ans+=3*pow(16,n-i-1); 
			break;
		case '4': ans+=4*pow(16,n-i-1);
			break;
		case '5': ans+=5*pow(16,n-i-1);
			break;
		case '6': ans+=6*pow(16,n-i-1);
			break;
		case '7': ans+=7*pow(16,n-i-1);
			break;
		case '8': ans+=8*pow(16,n-i-1);
			break;
		case '9': ans+=9*pow(16,n-i-1);
			break;
		case 'A': ans+=10*pow(16,n-i-1);
			break;
		case 'B': ans+=11*pow(16,n-i-1);
			break;
		case 'C': ans+=12*pow(16,n-i-1);
			break;
		case 'D': ans+=13*pow(16,n-i-1);
			break;
		case 'E': ans+=14*pow(16,n-i-1);
			break;
		case 'F': ans+=15*pow(16,n-i-1);
			break;
			}
		}
	return ans;	
}


int main() {
	string hexstring;
	int decstring;
	cin >> hexstring;
	decstring=hextodec(hexstring);
	cout<<decstring;

	return 0;

}
```



### 十进制转16进制

题目要求的是该数字在int的范围之内

偷懒做法：

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
	int num;
	cin>>num;
	cout<<hex<<num;
	return 0;

}
```



辗转相除

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
	int num;
	cin>>num;
	string hexstring="";
	while(num>0){
		int x=num%16;
		switch(x){
			case 0: hexstring.insert(0,"0");
				break;
			case 1: hexstring.insert(0,"1");
				break;
			case 2: hexstring.insert(0,"2");
				break;
			case 3: hexstring.insert(0,"3");
				break;
			case 4: hexstring.insert(0,"4");
				break;
			case 5: hexstring.insert(0,"5");
				break;
			case 6: hexstring.insert(0,"6");
				break;
			case 7: hexstring.insert(0,"7");
				break;
			case 8: hexstring.insert(0,"8");
				break;
			case 9: hexstring.insert(0,"9");
				break;
			case 10: hexstring.insert(0,"A");
				break;
			case 11: hexstring.insert(0,"B");
				break;
			case 12: hexstring.insert(0,"C");
				break;
			case 13: hexstring.insert(0,"D");
				break;
			case 14: hexstring.insert(0,"E");
				break;
			case 15: hexstring.insert(0,"F");
				break;
		}
		num/=16;  
	}
	cout<<hexstring;
	
	return 0;

}
```

如果需要排序字典序的，有时候可以利用数组，数组下标表示字典序，因为'a'的ASCII码是97，z的ASCII码是122，所以都减去97，得到1~25的值

### 蓝桥日期问题（103）

![image-20240227213938918](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240227213938918.png)

```c++
#include<iostream>
using namespace std;
const int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
bool check(int y, int m, int d) {
	//检查日期是否合法
	if (m == 0 || m>12||d==0) return false;
	if (m != 2 && d > days[m]) return false;
	if (m == 2) {
		if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) {
			if (d > 29) return false;
		}
		else {
			if (d > 28) return false;
		}
	}
	return true;

}
int main() {
	int a, b, c;
	scanf("%d/%d/%d", &a, &b, &c);//第一步格式输入
	for (int i = 19600101; i <= 20591231; i++) {
		int y = i / 10000;//i/10000的意思是从后面截断四位数，舍去，只留前面的
		int m = i % 10000 / 100;//i%10000的意思是从后面截断四位数，只留后面的
		int d = i % 100;//求一个数的后两位
		if (check(y, m, d)) {
			if ((y % 100 == a && m == b && d == c) || (y % 100 == c && m == b && d == a) ||
				(y % 100 == c && m == a && d == b)) {
				printf("%d-%02d-%02d\n", y, m, d);//注意格式打印
			}
		}

	}
}
```

常见的判断日期是否合法可以用到的代码

```c++
const int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
bool check(int y, int m, int d) {
	//检查日期是否合法
	if (m == 0 || m>12||d==0) return false;
	if (m != 2 && d > days[m]) return false;
	if (m == 2) {
		if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) {
			if (d > 29) return false;
		}
		else {
			if (d > 28) return false;
		}
	}
	return true;

}
```



### 力扣判断回文串

判断一个串是否是回文串：双指针

```c++
bool check(string s){
    for(int i=0;j=s.size()-1;i<j;i++,j--){
        if(s[i]!=s[j]) return false;
    }
    return true;
}
```

### 蓝桥刷题统计2098

n的大小给到了10e18,要开long long

```c++
#include <iostream>
using namespace std;
typedef long long ll;
int main()
{
  // 请在此输入您的代码
  ll a,b,n;
  scanf("%lld%lld%lld",&a,&b,&n);
  ll m=a*5+b*2;
  ll wsum=n/m;
  ll ans=wsum*7;
  n%=m;
  int w=1;
  while(n>0){
    if(w==8){
      w=1;
    }
    if(w<=5){//如果今天在周一到周五
      n-=a;
    }
    else{//如果今天在周末
      n-=b;
    }
    w++;
    ans++;
  }
  printf("%lld",ans);


  return 0;
}
```



### 力扣交换字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**双指针**

```java
    public void reverseString(char[] s) {
        int length = s.length;
        //两个指针一个从第1个，一个从最后一个开始，
        //两两交换
        int left = 0;
        int right = length - 1;
        while (left < right) {
            swap(s, left++, right--);
        }
    }

    private void swap(char[] array, int i, int j) {
        //第1种交换方式
        char temp = array[i];
        array[i] = array[j];
        array[j] = temp;

        //第2种交换方式
//        array[i] = (char) (array[i] + array[j]);
//        array[j] = (char) (array[i] - array[j]);
//        array[i] = (char) (array[i] - array[j]);

        //第3种交换方式
//        array[i] = (char) (array[i] - array[j]);
//        array[j] = (char) (array[i] + array[j]);
//        array[i] = (char) (array[j] - array[i]);

        //第4种交换方式
//        array[i] ^= array[j];
//        array[j] ^= array[i];
//        array[i] ^= array[j];
    }


```





```c++
#include<iostream>
#include<vector>
using namespace std;
class Solution {
public:
    void reverseString(vector<char>& s) {
        if (s.empty() || s.size() == 0)
        {
            return;
        }
        reverseStringhelper(s, 0, s.size() - 1);
    }
    void reverseStringhelper(vector<char>& s, int left, int right)
    {
        if (left >= right)
        {
            return;
        }
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        reverseStringhelper(s, ++left, --right);
    }
};
```

### 力扣翻转数字

core:**判断整数溢出**

```java
//何其幸运能够学习到如此美妙的算法!!!!
class Solution {
    public int reverse(int x) {
        int res = 0;
        while(x!=0) {
            //每次取末尾数字
            int tmp = x%10;
            //判断是否 大于 最大32位整数
            if (res>214748364 || (res==214748364 && tmp>7)) {
                return 0;
            }
            //判断是否 小于 最小32位整数
            if (res<-214748364 || (res==-214748364 && tmp<-8)) {
                return 0;
            }
            res = res*10 + tmp;
            x /= 10;
        }
        return res;
    }
}
```

### 力扣字符串第一个不重复的字符

给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 

```c++
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<int, int> frequency;
        for (char ch: s) {
            ++frequency[ch];
        }
        for (int i = 0; i < s.size(); ++i) {
            if (frequency[s[i]] == 1) {
                return i;
            }
        }
        return -1;
    }
};

```

### 蓝桥字符串转化成整数

![image-20240302195337802](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240302195337802.png)

1.**字符串去除前导空格**

cin输入自动去除空格！！！

**转化成数字时判断溢出**

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231205163818189.png" alt="image-20231205163818189" style="zoom: 80%;" />



**完整代码**

```c++
#include<iostream>
#include<string>
using namespace std;

int main() {
    string s;
    cin >> s;

    // 判断是否为空字符串
    if (s.empty()) {
        cout << 0;
        return 0;
    }

    int i = 0;
    bool flag = true; // 默认为正数
    int res = 0;

    // 处理负号
    if (s[0] == '-') {
        flag = false;
        i++;
    }

    // 去除前导零
    while (i < s.size() && s[i] == '0') {
        i++;
    }

    // 处理数字部分
    while (i < s.size()) {
        int tmp = s[i] - '0';

        // 判断是否会溢出
        if ((res > INT_MAX / 10) || (res == INT_MAX / 10 && tmp > INT_MAX % 10)) {
            cout << (flag ? INT_MAX : INT_MIN);
            return 0;
        }

        // 更新结果
        res = res * 10 + tmp;
        i++;
    }

    cout << (flag ? res : -res);
    return 0;
}

```

**自动机做法**

```python
INT_MAX = 2 ** 31 - 1
INT_MIN = -2 ** 31

class Automaton:
    def __init__(self):
        self.state = 'start'
        self.sign = 1
        self.ans = 0
        self.table = {
            'start': ['start', 'signed', 'in_number', 'end'],
            'signed': ['end', 'end', 'in_number', 'end'],
            'in_number': ['end', 'end', 'in_number', 'end'],
            'end': ['end', 'end', 'end', 'end'],
        }
        
    def get_col(self, c):
        if c.isspace():
            return 0
        if c == '+' or c == '-':
            return 1
        if c.isdigit():
            return 2
        return 3

    def get(self, c):
        self.state = self.table[self.state][self.get_col(c)]
        if self.state == 'in_number':
            self.ans = self.ans * 10 + int(c)
            self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN)
        elif self.state == 'signed':
            self.sign = 1 if c == '+' else -1

class Solution:
    def myAtoi(self, str: str) -> int:
        automaton = Automaton()
        for c in str:
            automaton.get(c)
        return automaton.sign * automaton.ans


```

### 蓝桥串的处理

![image-20240208145227753](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240208145227753.png)

**1.输入，cin和scanf一样，会截断空格**

**2.输出,记得cout输出变量时会输出字符，但是如果只是一个计算结果，如cout<<s-32此时会输出数字,所以在本题解中进行了类型转换**

```c++
#include<iostream>
#include<string>
using namespace std;
void change(char& ch) {
	ch = ch - 32;//把小写字母大写
}
int main() {
	string ss;
	getline(cin, ss);//getline也没有截断的特性，即接收空格
	int len = ss.length();
	if (isalpha(ss[0])) {
		change(ss[0]);
	}
	for (int i = 0, j = 1; i < len; i++, j++) {
		if (ss[i] == ' '&&j<len) {
			if (ss[j] == ' ') continue;
			else {
				//如果ss[i]是空格而ss[j]不是空格，说明是单词开头
				cout << ss[i];
				change(ss[j]);
			}
		}
		else if ((isdigit(ss[i]) && isalpha(ss[j])) || (isalpha(ss[i]) && isdigit(ss[j]))) {
			cout << ss[i] << '_';
		}

		else {
			cout << ss[i];
		}
		
	}
	return 0;
}
```

### 蓝桥密文搜索

![image-20240208180432011](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240208180432011.png)



```c++
#include<iostream>
#include<string>
#include<algorithm>
#include<map>
using namespace std;
map<string, int>mp;
string str, s;
int n;
int main() {
	cin >> str >> n;
	while (n--) {
		cin >> s;
		sort(s.begin(), s.end());
		mp[s]++;
	}
	int ans=0;
	cout << endl;
	for (int i = 0; i <= str.size() - 8; i++) {
		string t = str.substr(i, 8);
		sort(t.begin(), t.end());
		ans += mp[t];
	}

	return 0;
}
```



### 哈希表实例

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 定义哈希表的节点结构
typedef struct Node {
    char key;
    int count;
    struct Node* next;
} Node;

// 定义哈希表结构
typedef struct {
    Node** array;
    int size;
} HashMap;

// 初始化哈希表
HashMap* initHashMap(int size) {
    //问题一
    //头节点是一个哈希表指针，初始化不用开辟多余空间！！！
    HashMap* hashMap = (HashMap*)malloc(sizeof(HashMap));
    if (hashMap == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }

    hashMap->size = size;
    
    //问题二，一般都用一个二维指针来存储哈希桶，经过我浪费的时间来看，这样构建比较简单！！！
    //注意二维数组的构建哦，这里使用了calloc函数一次到位了，否则还要多一个for循环来实现二维数组的动态分配内存
    hashMap->array = (Node**)calloc(size, sizeof(Node*));
    if (hashMap->array == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }

    return hashMap;
}

// 哈希函数，简单地返回字符的ASCII码对哈希表大小取余
int hashFunction(char key, int size) {
    return (int)key % size;
}

// 在哈希表中查找节点
Node* findNode(HashMap* hashMap, char key) {
    //首先找到哈希桶中对应的的位置
    int index = hashFunction(key, hashMap->size);
    Node* current = hashMap->array[index];

    //在该位置中找是否有符合条件的
    while (current != NULL) {
        if (current->key == key) {
            return current;
        }
        current = current->next;
    }

    return NULL;
}

// 插入节点或更新计数
void insertOrUpdate(HashMap* hashMap, char key) {
    //老规矩，找到哈希桶中对应的位置
    int index = hashFunction(key, hashMap->size);
    Node* current = hashMap->array[index];
    //查找，看是否找到，如果原结构中已经有了，就计数加一
    Node* node = findNode(hashMap, key);

    if (node != NULL) {
        // 节点已存在，更新计数
        node->count++;
    } 
    //如果没找到，需要头插法加入哈希桶对应的位置中去哦
    else {
        // 节点不存在，插入新节点
        Node* newNode = (Node*)malloc(sizeof(Node));
        if (newNode == NULL) {
            perror("Memory allocation failed");
            exit(EXIT_FAILURE);
        }

        newNode->key = key;
        newNode->count = 1;
        
        //头插法
        newNode->next = current;
        hashMap->array[index] = newNode;
    }
}

// 统计字符串中每个字符的出现次数
void countCharacters(HashMap* hashMap, const char* str) {
    while (*str != '\0') {
        insertOrUpdate(hashMap, *str);
        str++;
    }
}

// 打印哈希表内容
void printHashMap(HashMap* hashMap) {
    printf("Character Counts:\n");
    for (int i = 0; i < hashMap->size; i++) {
        Node* current = hashMap->array[i];
        while (current != NULL) {
            printf("'%c': %d\n", current->key, current->count);
            current = current->next;
        }
    }
}

// 释放哈希表的内存
void freeHashMap(HashMap* hashMap) {
    for (int i = 0; i < hashMap->size; i++) {
        Node* current = hashMap->array[i];
        while (current != NULL) {
            Node* next = current->next;
            free(current);
            current = next;
        }
    }
    free(hashMap->array);
    free(hashMap);
}

int main() {
    const char* inputString = "programming";
    int hashMapSize = 10;

    HashMap* hashMap = initHashMap(hashMapSize);

    countCharacters(hashMap, inputString);

    printHashMap(hashMap);

    freeHashMap(hashMap);

    return 0;
}

```



### 力扣67二进制求和

```c++
class Solution {
public:
    string addBinary(string a, string b) {
        int la=a.size();
        int lb=b.size();
        while(la<lb){
            a='0'+a;
            ++la;    
        }
        while(lb<la){
            b='0'+b;
            ++lb;         
        }
        
        int j=b.size()-1;
        for(j;j>0;j--){
            a[j]=a[j]-'0'+b[j];//把字符串转化成数字相加再转化回来
            if(a[j]>='2'){
                a[j]=(a[j]-'0')%2+'0';
                a[j-1]=a[j-1]+1;//注意这里！字符2和字符1的ASCII码只相差1

            }            
        }
        
        //涉及到进位问题，我们需要单独把第零位拿出来算
        a[0]=a[0]-'0'+b[0];
        if(a[0]>='2'){
                a[0]=(a[0]-'0')%2+'0';
                a='1'+a;

            }
            return a;
    }
};
```





### 去除两端空格

```c++
int main() {
    string s = "     hello    ";
    int i = 0;
    for (i; s[i] == ' '; i++);
    int j = 0;
    for (j = s.size(); s[j] == ' '; --j);
    int n = j - i + 1;
    s = s.substr(i, n);
    cout << s;
}

```

### 去除适当空格，使字符串表示一个正确的句子

```c++
#include <iostream>
#include <sstream>
using namespace std;
void trim(string &s) {
    int len = s.size();
    int i = 0, j = 0;
    for (i; s[i] == ' '; i++);
    for (j = len - 1; s[j] == ' '; j--);
    s = s.substr(i, j - i + 1);
}
int main() {
    std::string s = "    你好       世界   巴拉巴拉     ";
    trim(s);
    int i = 0;
    while (i < s.size()) {
        if (s[i] == ' ') {
            int j = i;
            while (s[j] == ' ') j++;
            s.replace(i, j-i, " ");
            i+=1;
            continue;
        }
        i++;      
    }
    cout << s;   
    return 0;
}



```



### 力扣500键盘行

变化的哈希表，题解设置了每个字母所在的行号，使得查询变得快捷

遍历啦

```c++
class Solution {
public:
    vector<string> findWords(vector<string>& words) {
        vector<string> ans;
        string rowIdx = "12210111011122000010020202";
        for (auto & word : words) {
            bool isValid = true;
            char idx = rowIdx[tolower(word[0]) - 'a'];
            for (int i = 1; i < word.size(); ++i) {
                if(rowIdx[tolower(word[i]) - 'a'] != idx) {
                    isValid = false;
                    break;
                }
            }
            if (isValid) {
                ans.emplace_back(word);
            }
        }
        return ans;
    }
};

```

### 去除字符串指定字符

比如我想去除字符串里面的空格

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

void trim(string& s) {
    int len = s.size();
    int i = 0, j = 0;
    for (i; s[i] == ' '; i++);
    for (j = len - 1; s[j] == ' '; j--);
    s = s.substr(i, j - i + 1);
}
int main() {
    std::string s = "    你好       世界   巴拉巴拉     ";
    trim(s);
    int i = 0;
    int k = 0;
    int n = s.size();
    while (i < n) {
        if (s[i] == ' ') k++;
        else s[i - k] = s[i];
        i++;
    }
    s.resize(n - k);
    cout << s;
    return 0;
}
```



# 顺序表

哑节点dummy，如果题目不给哨兵节点的话，可以自己开辟一个，计算比较方便

### 力扣237删除链表的节点

```c
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val=node->next->val;
        node->next=node->next->next;
      
        
    }
};
```



### 力扣合并两个链表



```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
//我是小猫怪，遇到好的题解只会大喊：喵！！！！！！
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* pstr1 = list1;
    struct ListNode* pstr2 = list2;
    struct ListNode* head = NULL; // 用于保存合并后的链表的头指针
    struct ListNode* tail = NULL; // 用于保存合并后的链表的尾指针

    while (pstr1 && pstr2) {
        // 比较两个链表的当前节点值，将较小值的节点插入合并后的链表
        if (pstr1->val <= pstr2->val) {
            if (tail == NULL) {
                head = tail = pstr1;
            } else {
                tail->next = pstr1;
                tail = pstr1;
            }
            pstr1 = pstr1->next;
        } else {
            if (tail == NULL) {
                head = tail = pstr2;
            } else {
                tail->next = pstr2;
                tail = pstr2;
            }
            pstr2 = pstr2->next;
        }
    }

    // 处理剩余的节点
    if (pstr1 != NULL) {
        if (tail == NULL) {
            head = pstr1;
        } else {
            tail->next = pstr1;
        }
    } else if (pstr2 != NULL) {
        if (tail == NULL) {
            head = pstr2;
        } else {
            tail->next = pstr2;
        }
    }

    return head;
}

```



### 快慢指针

1.快指针每次走两步，慢指针每次走一步，快指针到达链表尾部时，因为慢指针走的步数一定是快指针的一半，所以此时慢指针在链表中部

2.快指针先走k-1步，然后慢指针和快指针再每次都走一步，当快指针到链表尾部时，慢指针此时就在链表的倒数第k个节点

3.快指针每次走两步，慢指针每次走一步，如果快慢指针能相遇，说明链表有环，此时让快指针重新回到头指针的位置然后让快慢指针每次都走一步，下次相遇的节点就是入环节点

![image-20240302230930445](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240302230930445.png)

第一次相遇之后，如果fast回到头节点，则它走了l步时，慢指针走了（n-1）+c-x步，正好在入环节点



4.**fast走3步，4步，5步或者走n步呢，请证明**

结论：fast走n步n如果大于2，不一定会相遇。

如果fast一次走三步。，slow进环以后，他们的距离是n。

假设n是偶数，则它们的距离变化：n   n-2   n-4   n-6...2 0,如果n是奇数，它们的距离变化：n   n-2   n-4   n-6...1 -1;所以如果n是偶数能追上，n是奇数追不上

如果fast一次走4步，则它们的距离变化为n   n-3   n-6...同以上分析

### 力扣92翻转链表2

穿针引线，先翻转目标链表，在把链表连起来

```c++
class Solution {
private:
    void reverseLinkedList(ListNode *head) {
        // 也可以使用递归反转一个链表
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while (cur != nullptr) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
    }

public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        ListNode *dummyNode = new ListNode(-1);
        dummyNode->next = head;

        ListNode *pre = dummyNode;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        // 建议写在 for 循环里，语义清晰
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode *rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode->next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        ListNode *leftNode = pre->next;
        ListNode *curr = rightNode->next;

        // 注意：切断链接
        pre->next = nullptr;
        rightNode->next = nullptr;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseLinkedList(leftNode);

        // 第 5 步：接回到原来的链表中
        pre->next = rightNode;
        leftNode->next = curr;
        return dummyNode->next;
    }
};


```

### 力扣86分隔链表

```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smlDummy = new ListNode(0), *bigDummy = new ListNode(0);
        ListNode *sml = smlDummy, *big = bigDummy;
        while (head != nullptr) {
            if (head->val < x) {
                sml->next = head;
                sml = sml->next;
            } else {
                big->next = head;
                big = big->next;
            }
            head = head->next;
        }
        sml->next = bigDummy->next;
        big->next = nullptr;
        return smlDummy->next;
    }
};

```

### 力扣143重排链表

```c++
class Solution {
public:
    void reorderList(ListNode* head) {
        if (head == nullptr) {
            return;
        }
        ListNode* mid = middleNode(head);
        ListNode* l1 = head;
        ListNode* l2 = mid->next;
        mid->next = nullptr;
        l2 = reverseList(l2);
        mergeList(l1, l2);
    }

    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next != nullptr && fast->next->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) {
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    void mergeList(ListNode* l1, ListNode* l2) {
        ListNode* l1_tmp;
        ListNode* l2_tmp;
        while (l1 != nullptr && l2 != nullptr) {
            l1_tmp = l1->next;
            l2_tmp = l2->next;

            l1->next = l2;
            l1 = l1_tmp;

            l2->next = l1;
            l2 = l2_tmp;
        }
    }
};

```

### 力扣82删除重复元素

### 力扣155最小栈

### 力扣1249移除无效的括号

思路：如果是左括号，那么就入栈，如果是右括号，有两种情况，栈为空，说明之前的括号完全匹配，删除即可，如果栈不为空，说明栈顶的左括号和该右括号匹配，出栈左括号

```c++
class Solution {
public:
    string minRemoveToMakeValid(string s) {
        stack<int> braket;
        int sLen = s.size();
        for(int i =0; i<sLen ; ++i){
            if(s[i] == '(' || s[i] == ')'){
                if(s[i] == '(') braket.push(i);
                else if(braket.empty()) {
                    s.erase(i,1);
                    --sLen;//这是一个非常有意思的写法
                    //一般来说因为删除字符串元素之后，字符串大小会改变，所以for循环的条件应该是
                    //i<s.size()
                    //但是这个时间复杂度比较高
                    //所以使用这个变量
                    --i;
                }
                else braket.pop();
            }
        }
        while(!braket.empty()){
            int i = braket.top();
            s.erase(i,1);
            braket.pop();
        }
        return s;
    }
};
```

### 力扣227基本运算器

不多说，审题，题目已经加粗标黑了条件，没有负数，没有括号，简化板的求后缀表达式再求值

注意根据后缀表达式求值的时候，

int a=pop();

int b=pop();

结果都是b-a。还有除零错误的规避

### 力扣1441

栈的特点，先进的元素一定先出，所以对于严格递增序列，想要构建135这样的数组，必须要进栈2，再出栈2，进栈4，再出栈4这样

### 返回元素第K大元素

```c++
#include<bits/stdc++.h>
int main(){
    priority_queue<int>a;
    vector<int>b;
    for(int num:b){
        a.push(num);
        if(a.size()>k) a.pop();
    }
    return a.top();
}
```



# 数学/设计

### 最小公倍数

数学上：求A  B的最小公倍数=A*B/GCD(最大公约数)

### 最大公约数

辗转相除算法

辗转相除法一般指欧几里得算法。是指用于计算两个非负整数a，b的最大公约数。那么辗转相除法的原理是什么？

1、 原理：设两数为a、b(ab)，用gcd(a，b)表示a，b的最大公约数，r=a(mod b)为a除以b的余数，k为a除以b的商，即a÷b=k。。。。。。。r。辗转相除法即是要证明gcd(a，b)=gcd(b，r)。

2、 第一步：令c=gcd(a，b)，则设a=mc，b=nc。

3、 第二步：根据前提可知r=a-kb=mc-knc=(m-kn)c。

4、 第三步：根据第二步结果可知c也是r的因数。

5、 第四步：可以断定m-kn与n互质(假设m-kn=xd，n=yd(d1)，则m=kn+xd=kyd+xd=(ky+x)d，则a=mc=(ky+x)cd，b=nc=ycd，则a与b的一个公约数cdc，故c非a与b的最大公约数，与前面结论矛盾)，因此c也是b与r的最大公约数。

6、 从而可知gcd(b，r)=c，继而gcd(a，b)=gcd(b，r)。

7、 证毕。以上步骤的操作是建立在刚开始时r≠0的基础之上的。即m与n亦互质。

```c++
//辗转相除法
int main() {
	int a;
	int b;    
	printf("请输入两个正整数：");
	scanf("%d %d", &a, &b);
	int k = 0;
	while (k = a % b) {
		a = b;
		b = k;
	}
	printf("最大公约数为:%d\n", b);
	return 0;
}
```



### 质数筛

质数筛是一种用于**找出一定范围内所有质数的算法**。其中最著名的是埃拉托斯特尼斯筛法（Sieve of Eratosthenes）。这个算法的基本思想是从小到大依次标记并删除每个数的倍数，最终剩下的未被标记的数就是质数。

二刷，记得在分配空间时多分配一个

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	//质数筛
	vector<int>arr(101,1);
	int n;
	cin>>n;
	arr[2]=true;
	for(int i=2;i*i<=n;i++){
		if(arr[i]==1){
			for(int j=i*i;j<=n;j+=i){
				arr[j]=0;
			}
		}
	}
	
	for(int i=2;i<=n;i++){
		if(arr[i]) cout<<i<<' ';
	}
    return 0;
}

```



### 把数字转化成字符串

```c++
#include <iostream>
#include <string>

std::string intToString(int number) {
    // 处理特殊情况，如果数字是0，直接返回字符串"0"
    if (number == 0) {
        return "0";
    }

    std::string result;  // 用于存储最终的字符串结果

    // 处理负数情况
    if (number < 0) {
        result.push_back('-');
        number = -number;  // 将负数转换为正数进行处理
    }

    // 逐位提取数字并转换为字符，然后拼接到结果字符串中
    while (number > 0) {
        char digit = '0' + (number % 10);  // 提取最后一位数字并转换为字符
        result.insert(result.begin(), digit);  // 在字符串的开头插入字符
        number /= 10;  // 去掉已经处理的最后一位数字
    }

    return result;
}

int main() {
    int number = -12345;
    std::string str_number = intToString(number);

    std::cout << "Number as string: " << str_number << std::endl;

    return 0;
}

```

### 力扣罗马数字转换

题干被你吃掉了，啊啊啊啊啊，长点心吧啊啊啊啊啊

```c++
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int>a;
        a['I'] = 1;
        a['V'] = 5;
        a['X'] = 10;
        a['L'] = 50;
        a['C'] = 100;
        a['D'] = 500;
        a['M'] = 1000;
        int i = 0;
        int num = 0;
        int len = s.length() - 1;
        for (i = 0; i < len; i++) {
            char temp1 = s[i];
            char temp2 = s[i + 1];   
            int num1 = a[temp1];
            int num2 = a[temp2];
            if (num1 >= num2) {
                num += num1;
            }
            else {
                num -= num1;
            }
        }
        num +=a[s[i]];
        return num;


    }
};
```

### 洗牌算法

[卡牌大师：玩转“洗牌算法”，幸运女神在微笑 (*^_^*) - 掘金 (juejin.cn)](https://juejin.cn/post/6984925268754317320)

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <ctime> // 用于获取当前时间戳

class Solution {
private:
    std::vector<int> original_nums;
    std::vector<int> current_nums;

public:
    Solution(const std::vector<int>& nums) {
        original_nums = nums;
        current_nums = nums;
        // 使用当前时间戳作为种子，以增加随机性
        srand(static_cast<unsigned>(time(nullptr)));
    }

    std::vector<int> reset() {
        current_nums = original_nums;
        return original_nums;
    }

    std::vector<int> shuffle() {
        int len = current_nums.size();

        while (len > 1) {
            int randIndex = rand() % len;
            --len;

            // 交换元素
            std::swap(current_nums[len], current_nums[randIndex]);
        }

        return current_nums;
    }
};

int main() {
    // 示例用法
    std::vector<int> nums = {1, 2, 3, 4, 5};
    Solution obj(nums);

    std::cout << "Initial Array: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::vector<int> shuffled = obj.shuffle();
    std::cout << "Shuffled Array: ";
    for (int num : shuffled) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::vector<int> resetted = obj.reset();
    std::cout << "Resetted Array: ";
    for (int num : resetted) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

`static_cast<unsigned>` 是 C++ 中的静态类型转换（static cast）。在这个上下文中，`unsigned` 是一种整数类型，而 `static_cast<unsigned>` 用于将某个值转换为无符号整数类型。

具体来说，`static_cast<unsigned>` 将其后的表达式转换为 `unsigned` 类型。这样的转换可能用于避免警告或错误，或者是为了满足特定的类型要求。

在前述代码中，`static_cast<unsigned>(time(nullptr))` 将 `time(nullptr)` 的返回值转换为无符号整数类型 `unsigned`。这是因为 `srand` 函数接受的参数类型是 `unsigned int`，为了匹配这个类型，进行了相应的类型转换。

### 力扣3178

遇到这种数学的就要想起高中的思想





# 动态规划

[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/xac615na)



[从零开始学动态规划-CSDN博客](https://blog.csdn.net/qq_32400847/article/details/51148917)

### 力扣爬楼梯

根据推理得出：爬上第n级台阶的步数=爬上n-1级台阶的步数+爬上n-2级台阶的步数

**递归（dfs）**



```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        return climbStairs(n-1)+climbStairs(n-2);

    }
};
```

画出递归的树形结构：

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207121907933.png" alt="image-20240207121907933" style="zoom:50%;" />

我们发现每次有些台阶数被计算了多次，导致时间复杂度变大，所以使用记忆化递归的方式减小时间复杂度

**记忆化递归**

```c++
class Solution {
public:
    int climbStairs(int n) {
        int *mem=new int[n+1];//创建记忆数组
        //记忆数组中存储的是第i级台阶需要的步数，当需要使用的时候是直接使用即可
        //空间换时间
        return func(n,mem);

    }
    int func(int n,int*mem){
        if(mem[n]>0){
            return mem[n];
        }
        if(n==1){
            mem[1]=1;
        }
        else if(n==2){
            mem[2]=2;
        }
        else{
            mem[n]=func(n-1,mem)+func(n-2,mem);
        }
        return mem[n];
    }
};
```

**动态规划(递推)**

```c++
class Solution {
public:
    int climbStairs(int n) {
              if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int*mem=new int[n+1];
        mem[1]=1;
        mem[2]=2;
        for(int i=3;i<=n;i++){
            mem[i]=mem[i-1]+mem[i-2];
        }
        return mem[n];

    }
};
```

**滚动数组**

优化了动态规划，因为我们只需要最后一个n级台阶的解，不需要其他的，所以这些被细化的子问题被覆盖也可以

```c++
class Solution {
public:
    int climbStairs(int n) {
              if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int first=1;
        int second=2;
        int third;
        for(int i=3;i<=n;i++){
            third=first+second;
            first=second;
            second=third;

        }
        return third;

    }
};
```

**通项公式矩阵形式**

斐波那契数列的矩阵表达：

![image-20240207173623609](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207173623609.png)

![image-20240207173936045](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207173936045.png)



```c++
class Solution {
public:
    //该函数模拟矩阵相乘
    vector<vector<long long>> multiply(vector<vector<long long>> &a, vector<vector<long long>> &b) {
        vector<vector<long long>> c(2, vector<long long>(2));
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
            }
        }
        return c;
    }
    

    vector<vector<long long>> matrixPow(vector<vector<long long>> a, int n) {
        vector<vector<long long>> ret = {{1, 0}, {0, 1}};//这里利用单位矩阵和任何矩阵相乘都等于1来初始化
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, a);
            }
            n >>= 1;
            a = multiply(a, a);
        }
        return ret;
    }

    int climbStairs(int n) {
        vector<vector<long long>> ret = {{1, 1}, {1, 0}};
        vector<vector<long long>> res = matrixPow(ret, n);
        return res[0][0];
    }
};

```

**Binet's  Formula**

就是用数学的方法解矩阵M的n次方，你们数学好的到底要怎么样

![image-20240207175746964](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207175746964.png)

![image-20240207175813215](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207175813215.png)



### 背包问题

https://www.acwing.com/file_system/file/content/whole/index/content/6798055/

#### 01背包问题

每件物品只能选择一次



```c++
#include<iostream> 
#include<vector>
using namespace std;
const int N=1010;
int dp[N];
int volum[N];
int values[N];
int f[N][N];
int main(){
	int n,v;//物品数和背包能存放的最大重量
	cin>>n>>v;
	for(int i=1;i<=n;i++){
		cin>>volum[i]>>values[i];
	}
	
	//f(x,w),w代表的是能选的物品数目，w代表的是背包的容量
	//最终输出f(n,v); 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=v;j++){
			if(j<volum[i]) f[i][j]=f[i-1][j];
			else{
				f[i][j]=max(f[i-1][j],f[i-1][j-volum[i]]+values[i]);
			}
			
		} 
	}
	
	cout<<f[n][v];
	return 0;	
	 
} 

```



#### 01背包一维数组

dp[j]代表的是当物品数目为i的时候，背包容量为j时能得到的最大价值

背包问题中的状态转移方程是在不同的背包容量下更新最大价值。当我们遍历每个物品时，如果我们选择正序遍历背包容量`j`，则在更新`dp[j]`时，可能会用到当前循环中已经更新过的`dp[j - v[i]]`值，这会导致错误的结果，因为这些值已经是当前轮次的更新结果，而不是上一轮次的值。

```c++
#include<iostream>
using namespace std;
int dp[1010];
int v[1010];//代表物品的体积数组
int w[1010];//代表物品的价值数组 
int main(){
	int n,m;//n,m分别代表物品数目和背包容量
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>v[i]>>w[i];
	} 
	
	for(int i=1;i<=n;i++){
		for(int j=m;j>=v[i];j--){
			dp[j]=max(dp[j],dp[j-v[i]]+w[i]);		
		}	
    }	
	cout<<dp[5];	
	return 0;	
} 
```



#### 二维01背包

理解了一维背包的一维数组之后才理解二维背包的解法，也是滚动数组，不过多了一个体积

```c++
#include <bits/stdc++.h>

using namespace std;

int n, V, M;
const int N = 1e3 + 5;
int v[N], m[N], w[N], f[N][N];

signed main () {
    cin >> n >> V >> M;
    for (int i = 1; i <= n; i ++) {
        cin >> v[i] >> m[i] >> w[i];//体积，重量，价值
    }
    
    
    //f[V][M]表示背包体积为V,质量为的时候，所能存放的最大价值
    //不断更细f[V][M],当i的值变为N的时候，是要求的答案    
    for (int i = 1; i <= n; i ++)
        for (int j = V; j >= v[i]; j --)
            for (int k = M; k >= m[i]; k --)
                f[j][k] = max (f[j - v[i]][k - m[i]] + w[i], f[j][k]);//动态转移方程，01 背包的思路
    cout << f[V][M];
}


```



#### 多重背包

物品的个数是不定的，比如物品A有2件物品B有3件

```c++
#include <bits/stdc++.h>
using namespace std;
int dp[1010];
int weight[1010];
int value[1010];
int s[1010];
int main () {
	int w,v,s;
	int n,m,cnt=1;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>w>>v>>s;
		int pos=1;
		while(pos<=s){
			value[cnt]=v*pos;
			weight[cnt]=w*pos;
			s-=pos;
			pos*=2;
			cnt++;		
		}
		
		if(s){
			weight[cnt]=s*w;
			value[cnt]=v*s;	
			cnt++;	
		}
	}
	
	for(int i=1;i<cnt;i++){
		for(int j=m;j>=weight[i];j--){
			dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);
		}
	}
	
	cout<<dp[m];

	
}
```



#### 完全背包

完全背包的含义是，物品是无限的，我们不必考虑

```c++
#include<iostream>

using namespace std;

int dp[1010][1010];
int weight[1010];
int value[1010];
int main() {
	int n, m;//n种物品，背包容量为m
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> weight[i] >> value[i];
	}


	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			dp[i][j] = dp[i - 1][j];
			if (j >= weight[i]){
				dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);
				}	
		}
	}

	cout << dp[n][m];
}

```



#### 完全背包一维数组

为什么一维数组从v[i]开始计算呢？因为一维数组是滚动数组，是一层一层叠加的，党j<w[i]的时候，根本不用考虑选这个物品

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int f[N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)
    {
        cin>>v[i]>>w[i];
    }

    for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
    cout<<f[m]<<endl;
}
```



#### 混合背包问题

```c++
int n, m, f[1010];

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
    {
        int v, w, s;
        cin >> v >> w >> s;
        if (!s)     // 完全背包问题
        {
            for (int j = v; j <= m; j ++ )
                f[j] = max(f[j], f[j - v] + w);
        }
        else
        {
            if (s == -1) s = 1;     // 01 背包问题

            // 完全背包问题转化为 01 背包问题，二进制拆分优化
            for (int k = 1; k <= s; k *= 2)
            {
                for (int j = m; j >= k * v; j -- )
                    f[j] = max(f[j], f[j - k * v] + k * w);
                s -= k;
            }
            if (s)
            {
                for (int j = m; j >= s * v; j -- )
                    f[j] = max(f[j], f[j - s * v] + s * w);
            }
        }
    }

    cout << f[m] << endl;
    return 0;
}

```



#### 分组背包问题

```c++
const int N = 110;
int n, m, v[N][N], w[N][N], f[N], s[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> s[i];
        for (int j = 1; j <= s[i]; j ++ )
            cin >> v[i][j] >> w[i][j];
    }
    

    for (int i = 1; i <= n; i ++ ）
        for (int j = m; j >= 0; j -- )//一维
            for (int k = 1; k <= s[i]; k ++ )   // 组内编号
                if (j >= v[i][k])
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);

    cout << f[m] << endl;
    return 0;
}


```



#### 01背包最佳方案数



```c++
const int N = 1100, mod = 1e9 + 7;
int n, m, f[N], cnt[N];

int main()
{
    cin >> n >> m;
    for (int i = 0; i <= m; i ++ ) cnt[i] = 1;

    for (int i = 1; i <= n; i ++ )
    {
        int v, w;
        cin >> v >> w;

        for (int j = m; j >= v; j -- )
        {
            int value = f[j - v] + w;
            if (value > f[j])
            {
                f[j] = value;
                cnt[j] = cnt[j - v];
            } else if (value == f[j]) 
                cnt[j] = (cnt[j] + cnt[j - v]) % mod;
        }
    }

    cout << cnt[m] << endl;
    return 0;
}


```



#### 01背包最佳方案数字典序最小

```c++
const int N = 1010;
int n, m, v[N], w[N], f[N][N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = n; i >= 1; i -- )
        for (int j = 1; j <= m; j ++ )
        {
            f[i][j] = f[i + 1][j];
            if (j >= v[i]) f[i][j] = max(f[i + 1][j], f[i + 1][j - v[i]] + w[i]);
        }



    int j = m;
    for (int i = 1; i <= n; i ++ )   // 往前推
        if (j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i])
        {
            cout << i << ' ';
            j -= v[i];  // 选了第 i 个物品，总体积要减少
        }

    return 0;
}


```



### 背包问题求方案数、具体方案

[背包问题求方案数、具体方案-CSDN博客](https://blog.csdn.net/qq_43851311/article/details/128981355?ops_request_misc=&request_id=&biz_id=102&utm_term=背包问题最佳方案数&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128981355.142^v100^pc_search_result_base1&spm=1018.2226.3001.4187)

#### 货币系统

给你一个n种面值的货币系统，，求组成面值为m的货币有多少种

```c++
//推到过程
//dp[i][j]==dp[1][j]+dp[i[j-v[i]]]
//我们可以知道dp[i-1][j]表示不适用当前面值的货币所有的方案数，再加上使用了该货币的方案数就是所求的
//使用了该货币的方案数等于dp[i][j-v[i]],即我们默认使用了一次v[i]货币，现在总面值变成了j-v[i]
#include<iostream>
using namespace std;
int money[1010];
long long dp[1010][1010];
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>money[i];
		dp[i][0]=1;
	}
	


	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){	
			if(j<money[i]) dp[i][j]=dp[i-1][j];
			else dp[i][j]=dp[i-1][j]+dp[i][j-money[i]];
		}
	}
	cout<<dp[n][m];

    return 0;
}

```



#### ACWing278

```c++
#include<iostream>
using namespace std;
long long dp[10010];
int num[110];
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>num[i];
    }
    
    dp[0]=1;//显然什么都不选也是一种方案数
    for(int i=1;i<=n;i++){
        for(int j=m;j>=num[i];j--){
            dp[j]=dp[j]+dp[j-num[i]];
        }
    }
    
    cout<<dp[m];
   
    return 0;
}
```



#### ACWing1023

```c++
#include<iostream>
using namespace std;
int money[]={0,1,2,5,10};
int dp[1010];
int main()
{
	int n;
	cin>>n;
	dp[0]=1;
	for(int i=1;i<=4;i++){
		for(int j=money[i];j<=n;j++){
			dp[j]=dp[j]+dp[j-money[i]];
		}
	}
	cout<<dp[n];
    return 0;
}


```



### 硬币问题

硬币问题可以贪心的情况通常包括以下几种：

1. 每一种面值的硬币都可以无限使用：如果每种面值的硬币数量是无限的，并且面值之间满足某种关系，比如每种面值都是前一种面值的整数倍，那么可以使用贪心算法。
2. 面值之间满足某种性质：如果硬币的面值之间存在某种特殊的关系，比如是等比数列、斐波那契数列等，那么也可以使用贪心算法。
3. 最优子结构性质：硬币问题的最优解可以由子问题的最优解组合而成，而且子问题之间相互独立，不存在依赖关系。

当我们要凑出w=15，首先面临三种情况的选择

当我们选择了价值为1的硬币时，问题转化成了1+凑出价值为14的问题

当我们选择了价值为5的硬币的时候，问题转化成了1+凑出价值为10的问题

当我们选择了价值为11的硬币的时候，问题转化成了凑出价值为4的问题



![image-20240402214153424](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402214153424.png)



```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main() {
    int dp[100], i;
    dp[0] = 0;//f(0)的情况，价值为0那我们还凑个集贸啊，硬币数直接为0即可
    int cost;
    for (int i = 1; i <= 15; i++) {
        cost = 9999;
        if (i - 1 >= 0) cost = min(cost, dp[i - 1] + 1);//表示我们使用了此硬币一次，所以加一
        if (i - 5 >= 0) cost = min(cost, dp[i - 5] +1);
        if (i - 11 >= 0)cost = min(cost, dp[i - 11] + 1);
        dp[i] = cost;
        printf("dp[%d]=%d\n", i, dp[i]);
    }


    return 0;
}

```

![image-20240402215125353](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402215125353.png)



### 力扣198打家劫舍

面对一道题的时候，我们首先想到的应该都是dfs

分析这题的思路，对于某一店铺来说，我们有两种情况，选或者是不选。如果我们选择该店铺，那么我们就不能选择它的邻居，根据贪心思想，我们只能选择它的邻居的邻居，所以我们最大值为dfs(x+2)+stores[x]

如果我们没有选择这家店铺，那么我们只能选择它的邻居，所以dfs(x+1)

比较两者的最大值就是我们想要的

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 10010;//店铺最多有这么多家
int n;
int stores[N];
int dfs(int x) {
    if (x > n) return 0;
    else return max(dfs(x +1), dfs(x + 2) + stores[x]);
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &stores[i]);
    }
    printf("%d\n", dfs(1));
    return 0;
}

```



但是dfs的时间复杂度太高了呀，我们要想办法做优化

我们画出dfs的递归树，发现有很多重复的搜索（你知道的）



//tips，要是想实现记忆化搜索，那么dfs的参数要尽可能的小，不应该把没有影响到边界的参数放进来

//尽可能的把能剪枝的参数写上来

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 10010;//店铺最多有这么多家
int memory[N];
int n,sum;
int stores[N];
int dfs(int x) {
    if (memory[x]) return memory[x];
    int sum = 0;
    if (x > n) sum = 0;//如果x的值大于n的值，没有我们可以打劫的店铺
    else {
        sum = max(dfs(x + 1), dfs(x + 2) + stores[x]);
        memory[x] = sum;
    }
    return sum;

}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &stores[i]);
    }
    printf("%d\n", dfs(1));
    return 0;
}

```



然后，我们继续分析搜索树

![image-20240402223230821](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402223230821.png)

有些天才就在想，那为什么不可以从底层出发，省去归的过程呢？这就是递推

动态规划的状态转移方程也就是dfs得到的式子，但是我个人的理解就是它结合了记忆化搜索，变成了：

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 10010;//店铺最多有这么多家
int ans[N];
int n;
int stores[N];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &stores[i]);
    }
    for (int i = n; i>=1; i--) {
        ans[i] = max(ans[i+1], ans[i +2] + stores[i]);
    }

    cout << ans[1];
    return 0;
}
//这里的i表示的是从i开始抢劫的最大值
//假设dp[i]表示从第i家店抢劫的答案
//如果我们从第n家店开始抢劫，那之后就没有可以抢的店了，所以dp[i]=stores[i]
//然后我们从第n-1家店开始抢劫，我们有两种情况，第一个是抢n-1家，第二个是抢第n家
//然后我们从第n-2家开始抢劫，我们也有两种情况，选1、3或者是选2
```



### 使用最小花费爬楼梯

### 零钱兑换

完全背包问题

### 力扣53最大子数组和

看题解，写的很精彩

### 整数拆分

两种解法

### 力扣比特位计数

方法一就是遍历数组，每一次都计算x&(x-1)变成零所需要的次数，但是这有很多重复计算

所以动态规划

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        int highBit = 0;
        for (int i = 1; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
};


```



### 最长上升子序列

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {

        int n=nums.size();
        if(n==0) return 0;
        vector<int>dp(n,0);
        for(int i=0;i<n;i++){
            dp[i]=1;
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i]=max(dp[i],dp[j]+1);
                }
            }
            
        }
        return *max_element(dp.begin(),dp.end());

    }
};
```



### 力扣1668最大重复子字符串

KMP算法

### 力扣399双周赛第四题

# 快速幂算法

https://www.bilibili.com/video/BV16Z4y1M7y1/?spm_id_from=333.337.search-card.all.click

快速幂算法用于计算幂预算，（当n很大的时候，朴素算法的时间复杂度为o(n),这个算法可以进行提速),原理就是把n转化成2的幂运算，再简化,时间复杂度为o(logn)

### 斐波那契数列的第n项 

**递归**

```c++
#include <iostream>
using namespace std;

long long fastPowerRecursive(long long base, long long exponent) {
    if (exponent == 0)
        return 1;
    else if (exponent % 2 == 0)
        return fastPowerRecursive(base * base, exponent / 2);
    else
        return base * fastPowerRecursive(base * base, (exponent - 1) / 2);
}

int main() {
    long long base, exponent;
    cout << "请输入底数和指数: ";
    cin >> base >> exponent;

    cout << "快速幂的结果是: " << fastPowerRecursive(base, exponent) << endl;

    return 0;
}

```

**非递归**

```c++
#include <iostream>
using namespace std;

long long fastPowerIterative(long long base, long long exponent) {
    long long result = 1;
    while (exponent > 0) {
        if (exponent % 2 == 1)
            result *= base;
        base *= base;
        exponent /= 2;
    }
    return result;
}

int main() {
    long long base, exponent;
    cout << "请输入底数和指数: ";
    cin >> base >> exponent;

    cout << "快速幂的结果是: " << fastPowerIterative(base, exponent) << endl;

    return 0;
}

```





# 递推求解

![image-20240313043844402](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313043844402.png)



n条线段，最后一条线段一定与前n-1跟线短相交，并且该线段被前n-1个线段分成n段，这个恰好是第n条线段加上之后多出的部分

所以状态转移方程f(n)=f(n-1)+n

f(1)=2   f(2)=4

```c++
#include<iostream>
using namespace std;
int func(int x) {
    if (x == 1) {
        return 2;
    }

    if (x == 2) {
        return 4;
    }
    return func(x - 1) + x;
}
int main()
{
    int n;
    cin >> n;
    cout << func(n);

    return 0;
}
```





![image-20240313044505011](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313044505011.png)



只有一根折线的情况

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313044533512.png" alt="image-20240313044533512" style="zoom:50%;" />

有两根折线的情况

![image-20240313045453327](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045453327.png)

可知一根折线会与另一个折现有4个交点

所以状态转移方程  f(n)=4*(n-1)+1,其中(n-1)是交点数，交点数加一就是线段数



![image-20240313045653763](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045653763.png)

这一题的状态转移方程是斐波那契数列

假设f(n-1)已经知道，那么有两种情况

第一种是最后一个格子放数条，那么只有这一种放法，总共有f(n-1)种

第二种是最后两个格子放横条，因为上面两个各自放了横条，那么下面那两个格子也只能放横条，也只有一种方法，总共有f(n-2)种

所以f(n)=f(n-1)+f(n-2)



![image-20240313045940604](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045940604.png)





![image-20240313050000122](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050000122.png)



<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050438505.png" alt="image-20240313050438505" style="zoom:50%;" />

状态转移方程f(n)=f(n-1)+f(n-2)+f(n-4)



![image-20240313050730568](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050730568.png)



# 卡特兰数列

[卡特兰数(Catalan Number)-CSDN博客](https://blog.csdn.net/Melody_Gogo/article/details/121800213?ops_request_misc=%7B%22request%5Fid%22%3A%22171030664816800213029071%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=171030664816800213029071&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121800213-null-null.142^v99^pc_search_result_base1&utm_term=卡特兰数的性质&spm=1018.2226.3001.4187)

![image-20240313050816661](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050816661.png)

1  2   5  14  42

# 组合数（卢卡斯）

[组合数（卢卡斯定理）-CSDN博客](https://blog.csdn.net/qq_43956340/article/details/104483451?ops_request_misc=%7B%22request%5Fid%22%3A%22171030723016800182139199%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=171030723016800182139199&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-104483451-null-null.142^v99^pc_search_result_base1&utm_term=组合数公式&spm=1018.2226.3001.4187)



# 斐波那契数列

[斐波那契数列的常用性质_斐波那契数列常考的5个性质-CSDN博客

[](https://blog.csdn.net/ltrbless/article/details/88565442?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-4-88565442-blog-82112564.235^v43^pc_blog_bottom_relevance_base3&spm=1001.2101.3001.4242.3&utm_relevant_index=7)



斐波那契数列,随着n的增大，前一项比上后一项的结果越来越接近0.618



# 枚举/暴力

枚举法又被成为暴力法

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207140355190.png" alt="image-20240207140355190" style="zoom:50%;" />

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207140544310.png" alt="image-20240207140544310" style="zoom:50%;" />

```c++
#include <iostream>
using namespace std;
int main() {
	for (int i = 0; i <= 1; i++) {
		for (int j = 0; j <= 1; j++) {
			for (int k = 0; k <= 1; k++) {
				for (int m = 0; m <= 1; m++) {
					for (int n = 0; n <= 1; n++) {
						cout << i << j << k << m << n << endl;
					}
				}
			}
		}
	}
	
}

```



![image-20240207140722333](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207140722333.png)

```c++
//质数筛的时间复杂度是on(n*logn)
#include <iostream>
using namespace std;
int a[10001] = { 0 };
int main() {
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++) {
		if (a[i] == 0) {
			for (int j = i * 2; j <= n; j += i) {
				a[j] = 1;
			}
		}
	}
}
```



**数的质因数分解**

```c++
#include <iostream>
using namespace std;
int a[101] = { 0 };
int main() {
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++) {
		if (a[i] == 0) {
			for (int j = i * 2; j <= n; j += i) {
				a[j] = 1;
			}
		}
	}
	//一个数的质因数只能在比这个数小的质数中去找
	int i = 2;
	while (n >= 1&&i<=n) {
		if (a[i] == 0 && n % i == 0) {
			cout << i << " ";
			n = n / i;
		}
		else {
			i++;
		}
	}
}
```



有一个边长为n、m的棋盘，求棋盘内有多少个正方形和长方形

枚举法解题，时间复杂度是on(n的平方+m的平方)

```c++
#include <iostream>
using namespace std;
int main() {
	long long n, m, a1 = 0, a2 = 0;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (i == j) a1 += (n - i + 1) * (m - j + 1);
			else {
				a2 += (n - i + 1) * (m - j + 1);
			}
		}
	}
	cout << a1 << " " << a2 << endl;
}

```

# 时间问题

### 24小时制转换为12小时制

```c++
#include <iostream>
#include <string>

using namespace std;

string convertTo12HourFormat(int hour) {
    if (hour <= 12) {
        return to_string(hour) + " AM";
    } else {
        return to_string(hour - 12) + " PM";
    }
}

int main() {
    int hour;
    cout << "Enter hour in 24-hour format: ";
    cin >> hour;

    cout << "Time in 12-hour format: " << convertTo12HourFormat(hour) << endl;

    return 0;
}

```

### 时间加减法

**时间加减法可以通过将时间转换为分钟数进行计算，然后再将结果转换回时间格式。**

给一个时间，求该时间提前45分钟的时间

```c++
#include <iostream>
#include <sstream>

using namespace std;

int main() {
    int h, m;
    char colon;
    cin >> h >> colon >> m;

    // 计算当前时间总共的分钟数
    int totalMinutes = h * 60 + m;

    // 计算45分钟之前的时刻
    totalMinutes -= 45;
    if (totalMinutes < 0) {
        totalMinutes += 24 * 60;  // 调整到前一天
    }

    // 计算新的小时和分钟
    int newHour = totalMinutes / 60;
    int newMinute = totalMinutes % 60;

    // 输出结果
    cout << newHour << ":" << newMinute / 10 << newMinute % 10 << endl;

    return 0;
}

```



### 时区转换



```c++
#include <iostream>

using namespace std;

// 将给定时间转换为UTC时间
void convertToUTC(int& hour, int& minute, int& offset) {
    // 计算UTC时间
    int totalMinutes = hour * 60 + minute - offset;
    if (totalMinutes < 0) {
        totalMinutes += 24 * 60;  // 调整到前一天
    }
    hour = totalMinutes / 60;
    minute = totalMinutes % 60;
}

// 将UTC时间转换为目标时区的时间
void convertToTimeZone(int& hour, int& minute, int& offset) {
    // 计算目标时区的时间
    int totalMinutes = hour * 60 + minute + offset;
    hour = totalMinutes / 60;
    minute = totalMinutes % 60;
}

int main() {
    int hour, minute, offset, targetOffset;
    cout << "Enter hour and minute: ";
    cin >> hour >> minute;
    cout << "Enter offset of current time zone: ";
    cin >> offset;
    cout << "Enter offset of target time zone: ";
    cin >> targetOffset;

    // 将给定时间转换为UTC时间
    convertToUTC(hour, minute, offset);

    // 将UTC时间转换为目标时区的时间
    convertToTimeZone(hour, minute, targetOffset);

    cout << "Time in target time zone: " << hour << ":" << minute << endl;

    return 0;
}

```



### 时间差

```c++
#include <iostream>

using namespace std;

// 将时间转换为分钟数
int timeToMinutes(int hour, int minute) {
    return hour * 60 + minute;
}

// 计算时间差
void calculateTimeDifference(int hour1, int minute1, int hour2, int minute2, int& diffHour, int& diffMinute) {
    // 将时间转换为分钟数
    int time1 = timeToMinutes(hour1, minute1);
    int time2 = timeToMinutes(hour2, minute2);

    // 计算差值
    int diffMinutes = time2 - time1;
    if (diffMinutes < 0) {
        diffMinutes += 24 * 60;  // 调整到前一天
    }

    // 将差值转换为小时和分钟
    diffHour = diffMinutes / 60;
    diffMinute = diffMinutes % 60;
}

int main() {
    int hour1, minute1, hour2, minute2;
    cout << "Enter first time (hour and minute): ";
    cin >> hour1 >> minute1;
    cout << "Enter second time (hour and minute): ";
    cin >> hour2 >> minute2;

    int diffHour, diffMinute;
    calculateTimeDifference(hour1, minute1, hour2, minute2, diffHour, diffMinute);

    cout << "Time difference: " << diffHour << " hours " << diffMinute << " minutes" << endl;

    return 0;
}

```



# 数组

### 力扣1两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

```c++
//解题思路：插入到哈希表中去
struct hashTable {
    int key;
    int val;
    UT_hash_handle hh;
};

//全局变量，方便再twosum函数中操作
struct hashTable* hashtable;

//结构体函数
struct hashTable* find(int ikey) {
    struct hashTable* tmp;
    HASH_FIND_INT(hashtable, &ikey, tmp);
    return tmp;
}

void insert(int ikey, int ival) {
    struct hashTable* it = find(ikey);
    if (it == NULL) {
        struct hashTable* tmp = malloc(sizeof(struct hashTable));
        tmp->key = ikey, tmp->val = ival;
        HASH_ADD_INT(hashtable, key, tmp);
    }
}

int* twoSum(int* nums, int numsSize, int target, int* returnSize)
{
    hashtable = NULL;
    for (int i = 0; i < numsSize; i++) 
    {
        //先寻找哈希表中是否有target-nums[i]
        //如果存在，则可以直接返回，如果不存在的话，就把这个数插入到哈希表中去
        struct hashTable* it = find(target - nums[i]);
        if (it != NULL) 
        {
            int* ret = malloc(sizeof(int) * 2);
            ret[0] = it->val, ret[1] = i;
            *returnSize = 2;
            return ret;
        }
        insert(nums[i], i);
    }
    *returnSize = 0;
    return NULL;
}
```



### 力扣31下一个排列

如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：

我们希望下一个数 比当前数大，这样才满足 “下一个排列” 的定义。因此只需要 将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
我们还希望下一个数 增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
在 尽可能靠右的低位 进行交换，需要 从后向前 查找
将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列
以上就是求 “下一个排列” 的分析过程。



```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        if (n <= 1) {
            return;
        }
        int i = n - 2, j = n - 1, k = n - 1;
        // find: A[i] < A[j]
        while (i >= 0 && nums[i] >= nums[j]) {
            --i; --j;
        }
        if (i >= 0) { // 不是最后一个排列
            // find: A[i] < A[k]
            while (nums[i] >= nums[k]) {
                --k;
            }
            swap(nums[i], nums[k]);
        }
        // reverse A[j:end]
        i = j;
        j = n - 1;
        while (i < j) {
            swap(nums[i], nums[j]);
            ++i;
            --j;
        }
    }
};
```



# 贪心

### [从零开始学贪心算法-CSDN博客](https://blog.csdn.net/qq_32400847/article/details/51336300?ops_request_misc=%7B%22request%5Fid%22%3A%22170970936516800226558001%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=170970936516800226558001&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-51336300-null-null.142^v99^pc_search_result_base1&utm_term=贪心算法&spm=1018.2226.3001.4187)



贪心算法是特殊的动态规划？？？

贪心算法求硬币，只要硬币之间是整除关系



### 给定正整数N，求N个N相乘的个位数

```c++
#include<iostream>
#include<vector>
using namespace std;

int func(int x) {
   vector<int> a(10);
   a[0] = 0;
   a[1] = 1;
   a[2] = 4;
   a[3] = 7;
   a[4] = 6;
   a[5] = 5;
   a[6] = 6;
   a[7] = 3;
   a[8] = 6;
   a[9] = 9;
   return a[x];
}

int main() {
    // 取输入的数
    int n;
    cin >> n;
    
    // 计算个位数
    int ge = n % 10;
    
    // 调用函数并输出结果
    cout << func(ge); 
    
    return 0;
}

```

### 特殊的斐波那契

**有一种fibonacci数列，定义如下：**

**f(0)=7,f(1)=11,f(n)=f(n-1)+f(n-2),给定一个n(n<1000000),请判断f(n)能否被3整除**

(a+b)%3=(a%3+b%3)%3

f(0) = 7 % 3 = 1 

f(1) = 11 % 3 = 2 

f(2) = f(1) + f(0) = 2 + 1 = 3 % 3 = 0

f(3) = f(2) + f(1) = 0 + 2 = 2 

f(4) = f(3) + f(2) = 2 + 0 = 2 

f(5) = f(4) + f(3) = 2 + 2 = 4 % 3 = 1 

f(6) = f(5) + f(4) = 1 + 2 = 3 % 3 = 0 

f(7) = f(6) + f(5) = 0 + 1 = 1

周期为8.

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
using namespace std;
bool func(int m) {
    if (m == 2 || m == 6) {
        return true;
   }
    return false;
    
}

int main() {
    //思路：个位数只和个位数相关
    int n;
    cin >> n;
    int m = n % 8;
   
    cout << func(m); 
    return 0;
}

```



### 求A^B的最后三位表示的整数

```c++
#include <iostream>
using namespace std;

long long fastPowerIterative(long long base, long long exponent) {
    long long result = 1;
    while (exponent > 0) {
        if (exponent % 2 == 1)
            result *= base;
        base *= base;
        exponent /= 2;
    }
    return result;
}

int main() {
    long long base, exponent;
    cout << "请输入底数和指数: ";
    cin >> base >> exponent;
    long long res = fastPowerIterative(base, exponent);
    cout << res % 1000;
    return 0;
}

```

### 力扣1217玩筹码

服了狗屎题目这么简单我不会

### 力扣402移掉k位数字

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240306184035499.png" alt="image-20240306184035499" style="zoom: 67%;" />



考虑从左往右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过 k 次个数字后，所能得到的最小整数。根据之前的讨论：在使用 k个删除次数之前，栈中的序列从栈底到栈顶单调不降。

因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到

1. 栈为空

2. 或者新的栈顶元素不大于当前数字
3. 或者我们已经删除了 kkk 位数字

上述步骤结束后我们还需要针对一些情况做额外的处理：

如果我们删除了 m 个数字且 m<km<km<k，这种情况下我们需要从序列尾部删除额外的 k−mk-mk−m 个数字。

1. 如果最终的数字序列存在前导零，我们要删去前导零。
2. 如果最终数字序列为空，我们应该返回 0。
3. 最终，从栈底到栈顶的答案序列即为最小数。

考虑到栈的特点是后进先出，如果通过栈实现，则需要将栈内元素依次弹出然后进行翻转才能得到最小数。为了避免翻转操作，可以使用双端队列代替栈的实现。

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        vector<char> stk;
        for (auto& digit: num) {
            while (stk.size() > 0 && stk.back() > digit && k) {
                stk.pop_back();
                k -= 1;
            }
            stk.push_back(digit);
        }

        for (; k > 0; --k) {
            stk.pop_back();
        }

        string ans = "";
        bool isLeadingZero = true;
        for (auto& digit: stk) {
            if (isLeadingZero && digit == '0') {
                continue;
            }
            isLeadingZero = false;
            ans += digit;
        }
        return ans == "" ? "0" : ans;
    }
};


```

### 力扣605种花问题

1.对于两朵已经种花且中间没有种花的切片:它们之间可以种花的范围是[i+2,j-2],此时可以种花的格子数是j-i-3。假设有k个空格种花，可以种花的个数是（k+1）/2,所以在i,j之间可以种的花是（j-i-2）/2。

2.在第一个种花之前的切片：第一朵下标i,则可以种i/2朵花

3.在最后一朵花到末尾，同上，令最后一朵花的位置是r,花坛总长m,则可以种（m-r-1）/2朵花

基于以上分析，我们可以遍历花坛数组，对于第一种情况，我们设置开头是-1

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int count=0;//计数
        int prev=-1;//表示开头
        int m=flowerbed.size();
        for(int i=0;i<m;i++){
            if(flowerbed[i]==1){
                if(prev<0){
                    count+=i/2;     
                }
                else{
                    count+=(i-prev-2)/2;
                }
                prev=i;
            }
        }
        if(prev<0){
            //一朵花也没种
            count+=(m+1)/2;
        }
        else{
            count+=(m-prev-1)/2;
        }

        return count>=n;
    }
       

};


```

### 力扣608验证回文串

我们发现：最外层的两个字母如果不同，一定不是回文串！，如果是，则可以继续遍历内层的字串，这就是贪心的思想。

当我们发现有两个字母不同的时候，**必须删除一个字母**，删除之后，其他序列是回文串，因为最外层已经是回文不用考虑，所以只要判断右边和左边是否有一个是回文串就好。

```
class Solution {
public:
    bool ishuiwen(const string&s,int low,int high){
        for(int i=low,j=high;i<j;++i,--j){
            if(s[i]!=s[j]){
                return false;
            }
        }
        return true;
    }
    bool validPalindrome(string s) {
        //对于一个字符串是都是回文串，可以先判断两端是否是字符串，如果最外部都不是，则一定不是
        int low=0,high=s.size()-1;
        while(low<high){
            char c1=s[low],c2=s[high];
            if(c1==c2){
                low++;
                high--;
            }
            else{
                return ishuiwen(s,low+1,high)||ishuiwen(s,low,high-1);
            }
        }      
        return true;
    }
};
```

# 深度优先

### [云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com)](https://www.luogu.com/paste/vjf2z3hi)



### 15届蓝桥杯数字接龙

```c++
#include <iostream>
#include <string>
using namespace std;
const int N = 20;
int map[N][N];//地图
bool vis[N][N];//状态数组
string res;//存放答案,输出第一次搜索到的字符串
//搜索不到，输出-1也有分
int dx[8] = {-1,-1,0,1,1,1,0,-1};//方向数组,下标和给定方向一致
int dy[8] = {0,1,1,1,0,-1,-1,-1};

int n, k;
void dfs(int x, int y, int pre, string s, int dep) {
    if (x == n && y == n && dep == n * n) {
        //如果搜索到终点并且搜索深度等于n*n，说明已经搜索到结尾，搜索结束
        if (res.empty()) res = s;//此时为空说明一定是字典序最小的，返回
        return;
    }

    for (int i = 0; i < 8; i++) {
        int a = x + dx[i], b = y + dy[i];
        if (a<1 || b<1 || a>n || b>n) continue;
        if (vis[a][b]) continue;

        //防止交叉搜索
        //思想是会出现交叉搜索的是1、3、5、7这四条
        //如果相邻点被标记过，说明被交叉搜索了
        if (i == 1 && vis[x - 1][y] && vis[x][y + 1]) continue;
        else if (i == 3 && vis[x + 1][y] && vis[x][y+1]) continue;
        else if (i == 5 && vis[x+1][y] && vis[x][y-1]) continue;
        else if (i == 7 && vis[x-1][y] && vis[x][y - 1]) continue;

        //保证搜索方向是0，1，2，k-1...
        if ((map[a][b] < k && map[a][b] == pre + 1) || (pre+1==k &&map[a][b]==0)) {
            //开始搜索
            vis[a][b] = true;
            dfs(a, b, map[a][b], s + to_string(i), dep + 1);

            //最优性剪枝
            if (!res.empty()) return;//如果结果字符串非空，逐层返回
            
            vis[a][b] = false;//本题必须引入回溯

        }
    }
}

int main() {
    //首先你要把题目都清楚
    //题目都不清楚怎么模拟呢？
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> map[i][j];
        }
    }

    string emp;
    vis[1][1] = 1;
    
    //参数分别是下标x,y,搜索序列，拼接字符串和搜索深度
    dfs(1, 1, 0, emp, 1);
    if (res.empty()) cout << -1 << endl;
    else cout << res << endl;

    
    return 0;
}

```



### 力扣99恢复二叉搜索树

空间复杂度为0n的做法

```c++
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& nums) {
        if (root == nullptr) {
            return;
        }
        inorder(root->left, nums);
        nums.push_back(root->val);
        inorder(root->right, nums);
    }

    pair<int,int> findTwoSwapped(vector<int>& nums) {
        int n = nums.size();
        int index1 = -1, index2 = -1;
        for (int i = 0; i < n - 1; ++i) {
            if (nums[i + 1] < nums[i]) {
                index2 = i + 1;
                if (index1 == -1) {
                    index1 = i;
                } else {
                    break;
                }
            }
        }
        int x = nums[index1], y = nums[index2];
        return {x, y};
    }
    
    void recover(TreeNode* r, int count, int x, int y) {
        if (r != nullptr) {
            if (r->val == x || r->val == y) {
                r->val = r->val == x ? y : x;
                if (--count == 0) {
                    return;
                }
            }
            recover(r->left, count, x, y);
            recover(r->right, count, x, y);
        }
    }

    void recoverTree(TreeNode* root) {
        vector<int> nums;
        inorder(root, nums);
        pair<int,int> swapped= findTwoSwapped(nums);
        recover(root, 2, swapped.first, swapped.second);
    }
};


```

### 力扣110判断平衡二叉树

```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return depth(root)!=-1;
    }
    int depth(TreeNode*root){
        if(root==nullptr) return 0;
        int left =depth(root->left);
        if(left==-1) return -1;
        int right=depth(root->right);
        if(right==-1) return -1;
        return abs(left-right)<2?max(left,right)+1:-1;    
    }
};
```



### 力扣113路径总和

```c++
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;

    void dfs(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return;
        }
        path.emplace_back(root->val);
        targetSum -= root->val;
        if (root->left == nullptr && root->right == nullptr && targetSum == 0) {
            ret.emplace_back(path);
        }
        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        path.pop_back();//回溯
    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }
};


```



### 力扣114二叉树展开为链表

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        // 算法之神保佑！
        // 左子树为空，直接考虑下一个节点
        while (root != nullptr) {
            if (root->left == nullptr) {
                root = root->right;
            } else {
                TreeNode* pre = root->left;
                while (pre->right != nullptr) {
                    pre = pre->right;
                }
                pre->right = root->right;
                root->right = root->left;
                root->left = nullptr;
                root = root->right;
            }
        }
    }
};
```

### ACWing递归实现组合型枚举

分析代码，觉得难点在于怎样表示每次枚举的数都比当前值要大

比如第一个数是3，那么我的下一个数必须在4，5中选

代码中定义了for循环，定义了变量start,解决了该问题

```c++
#include<iostream>
using namespace std;
int n,r;
const int N=21;
int arr[N];
void dfs(int x,int start){
    if(x>r){
        for(int i=1;i<=r;i++){
            cout<<arr[i]<<' ';
        }
        cout<<endl;
        return;
    }
    
    for(int i=start;i<=n;i++){
        arr[x]=i;
        dfs(x+1,i+1);//每次递归一定是下一位，保证数据不重复
        arr[x]=0;
    }
}
int main(){
    cin>>n>>r;
    dfs(1,1);
    return 0;
    
}
```



### ACWing递归实现排列型枚举

递归树依据：一次枚举每个位置应该放哪个数

全排列要求数字不允许重复，但是有些题目：

比如有是个位置，要求我们只填3个数的话，那就可以有重复数字  

```c++
#include<iostream>
using namespace std;
const int N=20;
int n;
int st[N];
int arr[N];
void dfs(int x){
    if(x>n){
        for(int i=1;i<=n;i++){
            cout<<arr[i]<<" ";
        }
        cout<<endl;
    }
    for(int i=1;i<=n;i++){
        if(!st[i]){//如果这个数还没有被选过
            st[i]=1;
            arr[x]=i;
            dfs(x+1);
            st[i]=0;
            arr[x]=0;
        }
    }
}
int main(){
    cin>>n;
    dfs(1);
    return 0;
}
```



### ACWing递归实现指数型枚举

本题设置了三种状态，分别是1选取，2不选，0待定，分析问题时可知每个数字只有这三种情况，所以我们对每个数字枚举这三个值，但是枚举下一个值之前需要恢复现场

```c++
#include<iostream>
using namespace std;
int n;
const int N = 20;
int arr[N];

void dfs(int x) {
    if (x > n) {
        for (int i = 1; i <= n; i++) {
            if (arr[i] == 1) {
                cout << i << ' ';
            }
        }
        cout << endl;
        return;
    }
    
    //记得回溯
    arr[x] = 1;
    dfs(x + 1);
    arr[x] = 0;
    /*
在这个特定的代码中，arr[x] = 0; 这一行可以省略。因为在每次调用 dfs 函数时，arr 数组都会被重置为全零，所以在递归回溯的过程中，arr[x] 的值不会保留到下一次调用 dfs 函数。但是在更复杂的情况下，如果在递归回溯的过程中需要保持 arr 数组的某些特定状态，那么这一行不能省略。*/

    arr[x] = 2;
    dfs(x + 1);
    arr[x] = 0;

}
int main() {
    cin >> n;
    dfs(1);
    return 0;

}
```



### 洛谷p1036选数

```c++
#include<iostream>
using namespace std;
const int N=30;
int n,k;
int arr[N];
int choose[N];
int res=0;

bool is_prime(int sum){
    for(int i=2;i<sum/i;i++){
        if(sum%i==0) return false;
    }
    return true;
}
void dfs(int x,int start){
    
    if(x>k){
        int sum=0;
        for(int i=1;i<=k;i++){
            sum+=choose[i];
        }
        if(is_prime(sum)) res++;
        return;
        
    }
    for(int i=start;i<=n;i++){//用下标表示start，但是实际上是arr[i]
        choose[x]=arr[i];//组合型枚举的简单应用辣啦
        dfs(x+1,i+1);
        choose[x]=0;
    }
}
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
    }
    //组合数
    dfs(1,1);
    cout<<res;
    return 0;
    
}
```



### 洛谷p1088火星人

//全排列模板

//设置状态数组和答案数组

//同时注意到，因为刚开始遍历的时候不一定是从最小开始，输入了mars数组，我们让i从mars[x]开始遍历

//找到之后可以停止程序

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
int N, M;
int mars[10010];
int st[10010];
int arr[10010];
int res = 0;
int return0 = 0;
void dfs(int x) {
    if (return0 == 1) {
        return;
    }
    if (x > N) {
        res++;
        if (res == M + 1) {
            return0 = 1;
            for (int i = 1; i <= N; i++) {
                printf("%d ", arr[i]);
            }
        }
    }
    for (int i = 1; i <= N; i++) {
        if (res == 0) {
            i = mars[x];
        }
            if (!st[i]) {
                st[i] = 1;
                arr[x] = i;
                dfs(x + 1);
                st[i] = 0;
                arr[x] = 0;
            }
        }
    }

int main() {
    cin >> N;
    cin >> M;
    for (int i = 1; i <= N; i++) {
        scanf("%d",&mars[i]);
    }
    dfs(1);
}
```





虽然但是，STL你是我的神，比赛就用你！！！

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	int N,M;
	string s="";
	cin>>N;
	cin>>M;
	char ch;
	for(int i=0;i<N;i++){
		cin>>ch;
		s+=ch;
	}
	while(M--){
		next_permutation(s.begin(),s.end());
	}
	cout<<s;
    return 0;
}

```



### 洛谷p2089烤鸡

我们发现数组中的每一个数只有三种状态，和指数型枚举类似

```c++
#include<iostream>
#include<vector>
using namespace std;
const int N = 11;
int n;
vector<int>choose(11);
int res = 0;
int sum = 0;
vector<vector<int>>ans;


void dfs(int x)
{
    if (x > 10) {
        if (sum == n) {
            ans.push_back(choose);
            res += 1;
        }              
        return;
    }
    for (int i = 1; i <= 3; i++) {
        choose[x] = i;
        sum += i;
        if (sum <= n) {
            dfs(x + 1);
        }
        sum -= i;
    }
}

int main() {
    cin >> n;
    dfs(1);
    cout << res << endl;
    for (auto p : ans) {
        for (int i = 1; i <= 10; i++) {
            cout << p[i] << " ";
        }
        cout << endl;
    }
    
    return 0;
}

```



### p1149火柴棒等式

我真笑了，自认为开1000数据太大了，然后改小了，答案就不对，不要太高傲了啊啊啊啊啊

```c++
#include<iostream>
using namespace std;
int n;

int ans;
int match[1000] = { 6,2,5,5,4,5,6,3,7,6 };
int arr[4];
void dfs(int x,int sum) {
	if (sum > n) return;//剪枝 
	if (x > 3) {
		if (sum == n && arr[1] + arr[2] == arr[3])  ans++;
		return;
		
	}

	for (int i = 0; i < 1000; i++) {
		arr[x] = i;	
		dfs(x + 1,sum+match[i]);
	}


}
int main() {
	cin >> n;
	n -= 4;
	for (int i = 10; i <1000; i++) {
		match[i] = match[i % 10] + match[i / 10];
	}
	dfs(1,0);
	cout << ans;

	return 0;

}
```



### 洛谷p2036

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
int n;
bool tl = false;
int difference = INT32_MAX;

int arr[11];
int brr[11];
int choosea[11];
int chooseb[11];

void dfs(int x) {
    if (x > n) {
        int sour = 1, ku = 0;
        for (int i = 1; i <= n; i++) {       
            if (choosea[i] == 1 && chooseb[i] == 1) {
                tl = true;
                sour *= arr[i];
                ku += brr[i];
            }
        }
        if (tl==true) {
            int d = abs(sour - ku);
            difference = min(d, difference);
            tl = false;
        }

        return;

    }

    choosea[x] = 1;
    chooseb[x] = 1;
    dfs(x + 1);
    choosea[x] = 0;
    chooseb[x] = 0;

    choosea[x] = 2;
    chooseb[x] = 2;
    dfs(x + 1);
    choosea[x] = 0;
    chooseb[x] = 0;

}


int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &arr[i], &brr[i]);
    }
    dfs(1);
    cout << difference;
    return 0;
}
```



### 洛谷p1135

dfs超时，我请问呢，非要卡一个数据呜呜呜

```c++
#include<iostream>
using namespace std;
int N,A,B;
int arr[210];
int res=1e9;
bool st[210];//设置状态
//剪枝，当每层楼只去过一次，是最好的状态
//x代表当前层数，cnt表示按按钮的次数
void dfs(int x,int cnt){
    if(cnt>=res){
        //剪枝
        return ;
    }
    
    if(x<0||x>N) return ;
    if(x==B){
        res=min(res,cnt);
        return;
    }
    
    //bfs的精髓就是暴力搜索
    //所以当x+arr[x]<n的时候都可以进行搜索你
    if(arr[x]+x<=N&&!st[x+arr[x]]){
        st[x+arr[x]]=true;
        dfs(x+arr[x],cnt+1);
        st[x+arr[x]]=false;
    }
    
    if(x-arr[x]>0){
         st[x-arr[x]]=true;
        dfs(x-arr[x],cnt+1);
        st[x-arr[x]]=false;
    }
    
}
int main(){
    cin>>N>>A>>B;
    
    for(int i=1;i<=N;i++){
        scanf("%d",&arr[i]);
    }
    
    dfs(A,0);
    if(res==1e9) 
    {cout<<"-1";
    return 0;
    }
    cout<<res;

    return 0;
}

```



### 力扣257二叉树的所有路径

```c++
//使用了深度优先搜索
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string>paths;
        func(root,"",paths);
        return paths;
    }
    void func(TreeNode*root,string path,vector<string>&paths){//这里root没有用引用是因为root不需要修改
        if(root!=nullptr){
            path+=to_string(root->val);
            if(root->left==nullptr&&root->right==nullptr){
                paths.push_back(path);
            }
            else{
                path+="->";
                func(root->left,path,paths);//这里path没有用引用是因为path每次都是+=，构造了一个新的字符串插入到paths中
                func(root->right,path,paths);
            }
        }
    }
};
```



### p1135奇怪的电梯

深度优先搜索的指数型枚举模型，只有上下和未确定三种状态

别人写的dfs

```c++
#include<bits/stdc++.h>
using namespace std;
int n,a,b,k[201],dis[201];
void dfs(int node,int step){
	dis[node]=step;//一定可以更新
	int v=node-k[node];
	if(1<=v&&step+1<dis[v]/*可以更新在搜索*/)//下
		dfs(v,step+1);
	v=node+k[node];
	if(v<=n&&step+1<dis[v])//上
		dfs(v,step+1);
	return;
}
int main(){
	memset(dis,0x3f,sizeof(dis));
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)
		cin>>k[i];
	dfs(a,0);
	cout<<(dis[b]==0x3f3f3f3f?-1:dis[b]);
	return 0;
}==
```



```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 210;
int a[N];    //每层楼至多走一次为次数最少
int start, end1, n;
bool find1 = false;
int st[N];
int res=1e9;
void dfs(int i, int sum)
{
    if (sum < 1 ||sum > n||i>=res) return;
    else if (sum == end1)
    {
        find1 = true;
        res=min(res,i);
        return;
    }
    else{ 
        if(st[sum]>i||st[sum]==0) 
        {
            st[sum]=i;
            dfs(i + 1, sum + a[sum]);   //电梯上行 
            dfs(i + 1, sum - a[sum]);//电梯下行
        }
        else return;
    }
}
int main()
{
    scanf("%d %d %d", &n, &start, &end1);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    dfs(0, start);
    if (!find1) printf("-1");
    else printf("%d",res);
    return 0;
}
```



## 迷宫模型

### 洛谷p1683迷宫模型

1. **状态表示**：首先需要定义迷宫的状态表示。常见的方法是使用二维数组，其中0表示可通行的路径，1表示墙壁或不可通行的区域。同时需要一个起点和终点表示入口和出口的位置。
2. **递归搜索**：从起点开始，按照上、下、左、右四个方向进行递归搜索。每次移动到一个新位置时，都会检查是否到达了终点。如果没有到达终点，则继续从当前位置进行搜索。
3. **回溯条件**：在搜索过程中，如果遇到死路或者已经访问过的位置，就需要进行回溯。这时会返回到前一个位置，尝试其他方向的路径。
4. **记录路径**：为了避免重复走同一条路径，需要记录已经访问过的位置。一种常见的做法是用2来标记已经走过的可通行路径。
5. **求解方法**：除了回溯法，还可以使用深度优先搜索（DFS）或广度优先搜索（BFS）等其他图搜索算法来解决迷宫问题。每种方法都有其优缺点，例如DFS加回溯可能不会直接找到最短路径，而BFS可以找到最短路径，但需要记录更多的节点信息。

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
const int N = 30;
int W, H;
char map[N][N];
int st[N][N];//记录状态
int res;
int mx[4] = { -1,0,1,0 };
int my[4] = { 0,1,0,-1 };
void dfs(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int lx = x + mx[i];
        int ly = y + my[i];
        if (lx < 0 || lx > H || ly < 0 || ly >=W) continue;
        if (st[lx][ly]) continue;
        if (map[lx][ly] != '.')continue;
        st[lx][ly] = 1;
        res++;
        dfs(lx,ly);        
    }
}

int main() {
    int x, y;
    scanf("%d %d", &W, &H);
    for (int i = 0; i < H; i++) {
        scanf("%s", map[i]);
    }
    for (int i = 0; i < H; i++) {
        for (int j = 0; j < W; j++) {
            if (map[i][j] == '@') {
               
                st[i][j] = 1;
                dfs(i, j);
                break;
            }
        }
    }

    printf("%d", ++res);
    return 0;
}
```

### 洛谷p1596洪水填充模型

八连通指的是可以走斜线，好暴力的做法...所以dfs只能用于一些数据较少的地方吧

```c++
#include<iostream>
#include<string>
using namespace std;
const int n = 100;
int N, M;
int mx[] = { 1,1,1,0,0,-1,-1,-1 };
int my[] = { -1,0,1,1,-1,1,0,-1 };
bool st[n][n];
string s[n];
int res;
void dfs(int x, int y) {

    for (int i = 0; i < 8; i++) {
        int lx = x + mx[i];
        int ly = y + my[i];
        if (lx < 0 || lx >= N || ly < 0 || ly >= M) continue;
        if (s[lx][ly] != 'W') continue;
        if (st[lx][ly]) continue;
        st[lx][ly] = true;
        dfs(lx, ly);//不需要回溯，洪水模型，覆水难收
    }

}
int main() {
    cin >> N >> M;
    for (int i = 0; i < N; i++) {
        cin >> s[i];
    }

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (s[i][j] == 'W' && !st[i][j]) {
                //找到了第一个w
                s[i][j]=true;
                dfs(i, j);
                res++;
            }
        }
    }
    cout << res;
    return 0;
}

```



### ACW1114棋盘问题

对于本题，我们自然想到的是遇到一个可以放棋子的位置，放棋子，然后到其他行并且其他列的地方去找第二个可以放棋子的位置。



```c++
#include<iostream>
#include<string>
using namespace std;
const int N = 10;
int n,k,cnt;
bool st[N];
int res;
string arr[N];//记录答案的数组
void dfs(int x,int cnt) {
    if(cnt==k){
        res++;
        return;
    }
    
    if(x>n) return;
    for (int i = 0; i <n; i++) {
        if(!st[i]&&arr[x][i]=='#'){//这里的i表示列！！
            st[i]=true;
            dfs(x+1,cnt+1);
            st[i]=false;
        }
    }
    
    dfs(x+1,cnt);
}
int main() {
    while( cin >> n>>k,n>0&&k>0){
        for(int i=1;i<=n;i++){
            cin>>arr[i];
        }
        res=0;//注意这里，因为是多组样例输出，所以res要更新
        dfs(1,0);
        cout<<res<<endl;
    }

    return 0;
}

```



### 洛谷p1019

1. 设置一个记录单词使用次数的数组，以便判断单词的使用次数是否大于2
2. 设置一个数组来记录单词之间的可拼接的最短长度，当时是最短拼接长度，每次取重合最短的，可以使单词最长
3. 当开始找到龙的时候，开始暴力搜索

```c++
#include<iostream>
#include<string>
using namespace std;
const int N = 20;
int n;
string arr[N];
int used[N];//每个数组使用的次数
int cnt[N][N];//单词i与单词j的可拼接的长度
int ans;
void dfs(string s, int x) {
    ans = max(int(s.size()), ans);
    used[x]++;//当前单词使用次数加一
    for (int i = 0; i < n; i++) {
        if (cnt[x][i] && used[i] < 2) {//判断条件，如果两个单词之间可以拼接并且这个单词没有使用两次以上
            dfs(s + arr[i].substr(cnt[x][i]), i);
        }
    }

    used[x]--;//回溯，因为要找出最长距离
}
int main() {
    char start;

    cin >> n;
    string dargon;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    cin >> start;//龙头

    //预处理
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            string a = arr[i], b = arr[j];
            for (int k = 1; k < min(a.size(), b.size()); k++) {//注意这里，k必须从1开始取
                //找到一个单词的后缀和另一个单词的前缀相同
                if (a.substr(a.size() - k, k) == b.substr(0, k)) {
                    //第一个找到的一定是最短的，因为默认最短长度是1并且递增
                    cnt[i][j] = k;
                    break;
                }
            }

        }
    }

    for (int i = 0; i < n; i++) {
        if (arr[i][0] == start) {
            dfs(arr[i], i);//分别是龙和当前访问到了哪个单词
        }
    }
    cout << ans;
    return 0;
}
```



### 洛谷p1025

```c++
#include<iostream>
#include<string>
using namespace std;
int n, k;
int res;
int numsum;
int arr[210];
//组合型，但是下一次开始枚举可以是1
void dfs(int x, int start, int numsum) {
    if (x > k) {
        if (numsum == n) {
            res++;     
        }
          return;
    }


    for (int i = start;numsum+i*(k-x+1)<=n; i++) {//因为之后划分的一定大于等于i，如果剩下的位数
        //全是i的话还大于n，一定不符合情况
        //枚举k个数字
        arr[x] = i;
        dfs(x + 1, i, numsum+i);
        arr[x] = 0;
    }
}
int main() {
    cin >> n >> k;
    dfs(1, 1, 0);//从1,1开始枚举
    cout << res;
    return 0;
}

```

### 洛谷P1162

深度优先和广度优先结合哦

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
#include<string>
using namespace std;
typedef  pair<int, int> PII;
queue<PII> q;
const int n = 35;
int N;
int mx[] = { 0,1,0,-1 };
int my[] = { 1,0,-1,0 };
bool st[n][n];//状态数组
int map[n][n];//地图
bool bfs(int x, int y) {
    q.push({ x,y });
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t.first == 1 || t.second == 1 || t.first == N || t.second == N) {
            //到达边界
            return true;//可达
        }
        for (int i = 0; i < 4; i++) {
            int a = x + mx[i], b = y + my[i];
            if (map[a][b] == 1) continue;
            if (st[a][b]) continue;
            //不存在越界问题
            st[a][b] = true;
            q.push({ a,b });
        }
    }
    return false;
}

void dfs(int x, int y) {
        for (int i = 0; i < 4; i++) {
            int a = x + mx[i], b = y + my[i];
            if (map[a][b]==2||map[a][b]==1) continue;
            if (a < 2 || b < 2 || a >= N || b >= N) continue;
            //if (st[a][b]) continue;
            //不存在越界问题
            //st[a][b] = true;
            map[a][b] = 2;
            dfs(a, b);
        }
}
int main() {
    cin >> N;
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            scanf("%d", &map[i][j]);
        }
        
    }

    bool flag = false;
    for (int i = 1; i <= N; i++) {
        if (flag == true) break;
        for (int j = 1; j <= N; j++) {
            if (map[i][j] == 0 && i != 1 && i != N && j != 1 && j != N) {
                bool res=bfs(i, j);
               
                if (!res)
                {
                    map[i][j] = 2;
                    dfs(i, j);
                    flag = true;
                    break;
                }
                
            }
        }
    }

    cout << endl;
    
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            cout << map[i][j] << ' ';
        }
        cout << endl;
         
    }
    return 0;
}



```



# 广度优先

### [云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/sa0zary9)

### 迷宫问题

1. **定义迷宫的大小和状态：** 定义迷宫的大小并确定迷宫中每个位置的状态，如墙壁、可通行路径等。
2. **定义坐标结构体和方向数组：** 定义一个结构体来表示迷宫中每个位置的坐标，同时定义一个方向数组，用来指示每个位置可以移动的方向，如上、右、下、左。
3. **编写合法性检查函数：** 编写一个函数来检查给定的坐标是否合法，即是否在迷宫的范围内且对应的状态为可通行路径。其中有：越界检查，地图检查是否已经访问过，地图检查是否是障碍物，是否是终点检查，如果是终点就要返回。

1. **使用队列进行广度优先搜索：**
   - 创建一个队列，用于保存待探索的位置。
   - 将迷宫的起始位置加入队列中。
   - 进入循环，直到队列为空或者找到了终点。
   - 在每次循环中执行以下操作：
     - 从队列中取出一个位置，即队头的元素，作为当前探索的位置。
     - 判断当前位置是否为终点位置，如果是，则搜索结束，算法成功找到了通向终点的路径，结束循环。
     - 将当前位置标记为已访问过的状态，以避免重复访问。
     - 探索当前位置周围的所有相邻位置，并将未访问过的相邻位置加入队列中。
   - 重复执行以上步骤，直到队列为空（表示没有通向终点的路径）或者找到了终点。
2. **记录路径信息（可选）：** 如果需要记录路径信息，可以在找到终点后进行回溯，从终点开始，根据已经记录的父节点信息逆向回溯到起点，即可得到具体的路径信息。
3. **返回搜索结果：** 如果队列为空，则说明没有找到通向终点的路径，搜索失败；如果找到了终点，则搜索成功，算法结束。



```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
typedef pair<int, int> PII;

const int N = 110;
char map[N][N];
bool st[N][N];
PII parent[N][N]; // 记录每个点的父节点坐标
int row, colum, endx, endy;
int dx[] = { 1,0,-1,0 };
int dy[] = { 0,-1,0,1 };

void bfs(int x, int y) {
    queue<PII> q;
    q.push({ x,y });
    st[x][y] = true;
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t.first == endx && t.second == endy) return; // 找到终点直接返回
        for (int i = 0; i < 4; i++) {
            int a = t.first + dx[i], b = t.second + dy[i];
            if (a < 1 || a > row || b < 1 || b > colum) continue;
            if (st[a][b] || map[a][b] == '1') continue;
            st[a][b] = true;
            parent[a][b] = t;//该拓展点的父节点是t
            q.push({ a,b });
        }
    }
}

int main() {
    cout << "请输入迷宫的行和列" << endl;
    cin >> row >> colum;
    cout << "请输入迷宫的终点坐标" << endl;
    cin >> endx >> endy;
    cout << "请输入迷宫，其中1表示障碍物，0表示可行" << endl;
    for (int i = 1; i <= row; i++) {
        scanf("%s", map[i] + 1);
    }
    bfs(1, 1);

    if (!st[endx][endy]) {//没有解的话，就没有走过终点，则终点状态为false
        cout << "没有解！" << endl;
        return 0;
    }

    vector<PII> path;
    PII cur = { endx, endy };
    while (cur.first != 0 && cur.second != 0) { // 从终点回溯到起点
        path.push_back(cur);
        cur = parent[cur.first][cur.second];
    }
    reverse(path.begin(), path.end()); // 反转路径，得到从起点到终点的最短路径

    cout << "最短路径为：" << endl;
    for (auto p : path) {
        cout << '(' << p.first << ',' << p.second << ')' << "->";
    }
    cout << '(' << endx << ',' << endy << ')' << endl; // 打印终点

    return 0;
}

```



### 洛谷p2658汽车拉力赛

二分查找+bfs

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstring>
using namespace std;
int high[510][510];
int flag[510][510];
bool st[510][510];
typedef pair<int, int>PII;
int x, y;
int row, colum;
int flag_cnt = 0;
PII q[510 * 510];//bfs的队列
int dx[] = { -1,0,1,0 };
int dy[] = { 0,1,0,-1 };
bool check(int mid) {
    q[0] = { x,y };//入队
    int cnt = 1;
    int hh = 0, tt = 0;
    st[x][y]=true;
    while (hh <= tt) {
        auto t = q[hh++];
        for (int i = 0; i < 4; i++) {
            int a = t.first + dx[i], b = t.second + dy[i];
            if (a<1 || a>row || b<1 || b>colum) continue;
            if (st[a][b]) continue;
            if (abs(high[a][b] - high[t.first][t.second]) > mid) continue;
            st[a][b] = true;
            q[++tt] = { a,b };
            if (flag[a][b] == 1) {
                cnt++;
                  if (cnt == flag_cnt) return true;   
            }         
        }
    }
    return false;
}

int main() {
    cin >> row >> colum;
    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            scanf("%d", &high[i][j]);
        }
    }

    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            scanf("%d", &flag[i][j]);
            
            if (flag[i][j] == 1) {
                flag_cnt++;
                x = i, y = j;
            }
        }
    }

    int l = -1, r = 10000000010;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        memset(q, 0, sizeof q);
        memset(st, false, sizeof st);
        if (check(mid)) r = mid;
        else l = mid;
    }
    cout << r;

    return 0;

}



```

### 洛谷p4554双端队列解决

模拟可知，我们每次都想走费用为零的路，即每次都优先把费用为零的节点入队

```c++
#include<iostream>
#include<deque>
#include<cstring>
using namespace std;
typedef pair<int,int> PII;
int n,m,x1,y1,x2,y2;
string map[510];
int mx[]={-1,0,1,0};
int my[]={0,1,0,-1};
deque<PII>q;
int dis[510][510];
int bfs(int x,int y){
    //入队起点
    q.push_back({x,y});
    dis[x][y]=0;//设置起点距离起点的距离是零
    while(!q.empty()){
        auto t=q.front();//获取当前队头元素
        q.pop_front();//每次优先访问费用为零的节点
        char ch=map[t.first][t.second];
        for(int i=0;i<4;i++){
            int a=t.first+mx[i],b=t.second+my[i];
            if(a<0||a>=n||b<0||b>=m) continue;
            if(dis[a][b]>=0) continue;
           
            if(map[a][b]==ch){
                q.push_front({a,b});
                dis[a][b]=dis[t.first][t.second];
            }
            if(map[a][b]!=ch){
                q.push_back({a,b});
                dis[a][b]=dis[t.first][t.second]+1;
            }
          
            if(a==x2&&b==y2) return dis[a][b];
        }
    }
  return -1;
}
int main(){
    while(cin>>n>>m,n||m){//逗号运算符，会执行两个操作数，并返回最后一个操作数的结果作为返回值
        for(int i=0;i<n;i++){
            cin>>map[i];
        }
        
        //每次遍历都需要重新设置距离为没有访问过
        memset(dis,-1,sizeof dis);
        q.clear();
        cin>>x1>>y1>>x2>>y2;
        int res=bfs(x1,y1);
        cout<<res<<endl;
    }
    return 0;
}
```

### p1746离开中山路

```c++
#include<iostream>
#include<cstring>
using namespace std;
typedef pair<int,int>PII;
PII q[1010*1010];
char map[1010][1010];
int dis[1010][1010];
int vis[1010][1010];
int mx[]={-1,0,1,0};
int my[]={0,1,0,-1};
int n,x1,y1,x2,y2;
int bfs(){
    memset(dis,-1,sizeof dis);
    memset(vis,-1,sizeof vis);
    q[0]={x1,y1};
    q[1]={x2,y2};
    dis[x1][y1]=0;
    dis[x2][y2]=0;
    vis[x1][y1]=1;
    vis[x2][y2]=2;
    int hh=0,tt=1;
    while(hh<=tt){
        auto t=q[hh++];
        for(int i=0;i<4;i++){
            int a=t.first+mx[i],b=t.second+my[i];
            if(a<1||a>n||b<1||b>n) continue;
            if(map[a][b]=='1') continue;
            if(vis[a][b]+vis[t.first][t.second]==3){
                return dis[a][b]+dis[t.first][t.second]+1;
            }
            if(dis[a][b]>0) continue;
            dis[a][b]=dis[t.first][t.second]+1;
            if(vis[a][b]==-1){
                vis[a][b]=vis[t.first][t.second];
            }
            q[++tt]={a,b};//这里使得队列是交替插入起点和终点的节点的
        }
    }
    return -1;
    
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%s",map[i]+1);
    }
    scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
    int res=bfs();
    cout<<res;
    return 0;
}
```



### 洛谷p1379八数码难题

```c++
#include<iostream>
#include<algorithm>
#include<string>
#include<queue>
#include<unordered_map>
using namespace std;
int mx[] = { -1,0,1,0 };
int my[] = { 0,1,0,-1 };
unordered_map<string, int>dist;//记录走到该状态需要多少步
queue<string>q;
string end1 = "123804765";
int bfs(string start) {
    q.push(start);
    dist[start] = 0;
    while (q.size()) {
        auto t = q.front();
        q.pop();
        if (t == end1) return dist[t];
        int distance = dist[t];
        int a = t.find('0');
        int x1 = a / 3, y1 = a % 3;//状态压缩,转化为矩阵的下标
       
        for (int i = 0; i < 4; i++) {
            int x2 = x1 + mx[i], y2 = y1 + my[i];//每次交换上下左右四个位置
            if (x2 < 0 || x2 >= 3 || y2 < 0 || y2 >= 3) continue;//越界
            int tmp = x2 * 3 + y2;//又转化为字符串下标
            swap(t[a], t[tmp]);//在字符串中将这两个位置互换
            if (!dist.count(t)) {//如果这个字符串没有试过
                dist[t] = distance + 1;//试一试嘛
                q.push(t);
            }
            swap(t[a], t[tmp]);//回溯
        }
    }
    return -1;

}
int main() {
    string start;
    cin >> start;
    int res = bfs(start);
    cout << res;
    return 0;

}
```



双向队列优化代码

```c++


#include<iostream>
#include<cstring>
#include<algorithm>
#include<string>
#include<queue>
#include<unordered_map>
using namespace std;
int mx[] = { -1,0,1,0 };
int my[] = { 0,1,0,-1 };
unordered_map<string, int>dist;//记录走到该状态需要多少步
unordered_map<string,int>vis;
queue<string>q;
string end1 = "123804765";
int bfs(string start) {
    q.push(start);
    q.push(end1);
    dist[start] = 0;
    dist[end1]=0;
    vis[start]=1;
    vis[end1]=2;
    
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        int flag=vis[t];//记录当前节点的标记
        int distance = dist[t];//记录当前节点到起点或终点的距离
        
        int a = t.find('0');
        int x1 = a / 3, y1 = a % 3;//状态压缩,转化为矩阵的下标
       
        for (int i = 0; i < 4; i++) {
            int x2 = x1 + mx[i], y2 = y1 + my[i];//每次交换上下左右四个位置
            if (x2 < 0 || x2 >= 3 || y2 < 0 || y2 >= 3) continue;//越界
            int tmp = x2 * 3 + y2;//又转化为字符串下标
            swap(t[a], t[tmp]);//现在的t是拓展的t
            
            if (vis[t]+flag==3){//如果当前节点和拓展节点相遇
                int res1=dist[t];
                swap(t[a],t[tmp]);
                int res2=dist[t];
                return res1+res2+1;
            }
            
            if (!dist.count(t)) {//如果这个字符串没有试过
                dist[t] = distance + 1;//试一试嘛
                vis[t]=flag;
                q.push(t);
            }
   
            swap(t[a], t[tmp]);//回溯
        }
    }
    return -1;

}
int main() {
    string start;
    cin >> start;
    if(start==end1){
        cout<<0;
        return 0;
    }
    int res = bfs(start);
    cout << res;
    return 0;

}
```

###   p2730魔板

```c++
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
#include<string>
#include<unordered_map>
using namespace std;
unordered_map<string, int>dist;//走到当前状态需要几步
unordered_map<string, pair<char, string>>pre;
queue<string>q;
char arr[2][4];

void to_arr(string s) {
    for (int i = 0; i < 8; i++) {
        if (i < 4) {
            arr[0][i] = s[i];
        }
        else arr[1][7-i] = s[i];
    }
}

string To_string() {
    string res;
    for (int i = 0; i < 4; i++) {
        res += arr[0][i];
    }
    for (int i = 3; i >= 0; i--) {
        res += arr[1][i];
    }
    return res;
}

//交换上下两行
string move0(string s) {
    to_arr(s);
    for (int i = 0; i < 4; i++) {
        swap(arr[0][i], arr[1][i]);
    }
    return To_string();
}

//将最右边的一列插入最左边
string move1(string s) {
    to_arr(s);
    int a = arr[0][3], b = arr[1][3];
    for (int i = 3; i >= 1; i--) {
        for (int j = 0; j < 2; j++) {
            arr[j][i] = arr[j][i - 1];
        }
    }
    arr[0][0] = a;
    arr[1][0] = b;
    return To_string();
}

string move2(string s) {
    to_arr(s);
    int a = arr[0][2];
    arr[0][2] = arr[0][1];
    arr[0][1] = arr[1][1];
    arr[1][1] = arr[1][2];
    arr[1][2] = a;
    return To_string();
}



int bfs(string start, string end) {
    q.push(start);
    dist[start] = 0;
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t == end) return dist[end];
        string m[3];
        m[0] = move0(t);
        m[1] = move1(t);
        m[2] = move2(t);
        for (int i = 0; i<3; i++) {
            string s = m[i];
            if (!dist.count(s)) {
                dist[s] = dist[t] + 1;
                pre[s] = {i + 'A',t};
                if (s == end) return dist[end];
                q.push(s);
            } 
           
        }
    }
    return -1;
}
int main() {
    int x;

    string end;
    string start;
    for (int i = 0; i < 8; i++) {
        cin >> x;
        start += char(x + '0');
        end += char(i + 1 + '0');
    }

    int res = bfs(start, end);
    cout << res << endl;
    string res2;
    while (end != start) {
        res2 += pre[end].first;
        end = pre[end].second;
    }
    reverse(res2.begin(), res2.end());
    if (res2.size()) {
        cout << res2;
    }
    return 0;
}

```

### p1443马的遍历

bfs有很多种形式啦

```c++
#include<iostream>//P1443
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
const int dx[8]={-1,-2,-2,-1,1,2,2,1};
const int dy[8]={2,1,-1,-2,2,1,-1,-2};//8个方向
queue<pair<int,int> > q;
int f[500][500];//存步数
bool vis[500][500];//走没走过
int main()
{
	int n,m,x,y;
	memset(f,-1,sizeof(f));memset(vis,false,sizeof(vis));
	cin>>n>>m>>x>>y;
	f[x][y]=0;vis[x][y]=true;q.push(make_pair(x,y));
	while(!q.empty())
	{
		int xx=q.front().first,yy=q.front().second;q.pop();//取队首并出队
		for(int i=0;i<8;i++)
		{
			int u=xx+dx[i],v=yy+dy[i];
			if(u<1||u>n||v<1||v>m||vis[u][v])continue;//出界或走过就不走
		    vis[u][v]=true;q.push(make_pair(u,v));f[u][v]=f[xx][yy]+1;
		}
	}
	for(int i=1;i<=n;i++)
	 {for(int j=1;j<=m;j++)printf("%-5d",f[i][j]);printf("\n");}//注意场宽！！
	return 0;
}
```



### 力扣p1747好奇怪的游戏

遍历了所有的情况，唯独没有想到是数据范围出问题了，牢弟，我想把地球一拳锤爆

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstring>
using namespace std;
typedef pair<int, int> PII;

int vis[25][25];
int dis[25][25];//及记录距离
int mx[] = { -2,-2,-1,1,2,2,2,2,1,-1,-2,-1 };
int my[] = { -1,-2,-2,-2,-2,-1,1,2,2,2,2,1 };

int bfs(int x, int y) {
    if (x == 1 && y == 2 || x == 2 && y == 1) return 2;
    //终点和起点都是已知的，双向队列
    memset(dis, -1, sizeof dis);
    memset(vis, -1, sizeof vis);
    PII q[25 * 25];//定义列表

    q[0] = { x,y };
    q[1] = { 1,1 };
    dis[x][y] = 0;
    dis[1][1] = 0;
    vis[x][y] = 1;
    vis[1][1] = 2;
    int hh = 0, tt = 1;
    while (hh <= tt) {
        auto t = q[hh++];
        for (int i = 0; i < 12; i++) {
            int a = t.first + mx[i], b = t.second + my[i];
            if (a<=1 || a>21 || b<=1 || b>21) continue;
          
            if (vis[a][b] + vis[t.first][t.second] == 3) {
                return dis[a][b] + dis[t.first][t.second] + 1;
            }
            if (dis[a][b] > 0) continue;
            dis[a][b] = dis[t.first][t.second] + 1;
            if (vis[a][b] == -1) vis[a][b] = vis[t.first][t.second];
            q[++tt] = { a,b };
        }
    }
    return -1;
}


int main() {
    int x1, y1, x2, y2;
    scanf("%d %d", &x1, &y1);
    scanf("%d %d", &x2, &y2);
    int res1 = bfs(x1, y1);
    int res2 = bfs(x2, y2);
    cout << res1 << endl;
    cout << res2 << endl;
    return 0;

}
```



### 力扣p2385

我求求你了，数据开大一点吧，要不然你又以为是哪个地方写错了然后改半天小丑！





# 二分查找

### [【算法1-6】二分查找与二分答案 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/training/111#problems)

### 基础二分

【How to avoid pitfalls in Binary Search?】https://www.bilibili.com/video/BV1EW4y1C7vA?vd_source=afced950d3df908879a570bbf5db28f2

```c++
#include <iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;
bool is_blue(int num, int x) {
	//具体条件
	if (num <= 5) return true;
	else return false;
}
int main() {
	//假设我要找数组中第一个大于五的数的下标
	int arr[10] = {0};
	for (int i = 0; i < 10; i++) {
		cin >> arr[i];
	}
	int l = -1;
	int r = sizeof(arr) / sizeof(arr[0]);
	int mid;
	while (l + 1 != r) {//判定条件，l+=r说明已经遍历了整个数组
		mid = (l + r) / 2;
		if (is_blue(arr[mid], 5)) l = mid;
		else r = mid;
	}
	cout << r;
	return 0;
}
```



### 力扣二分求立方根

//输入一个数，求它的立方根，要求使用高效的算法

```c++
#include <iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
#include<iomanip>
using namespace std;
bool check(int num, int n) {
	return num * num * num <n;
}


int main() {
	int n;
	cin >> n;
	double l = -100, r = 100;
	double mid;
	for (int i = 0; i <50; i++) {
		mid = (r + l) / 2;
		if(check(mid,n)) l=mid;
		else r=mid;
	}
	printf("%6lf", l);
	
	return 0;
}
```

### 洛谷p3853

![image-20240315200520439](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240315200520439.png)

```c++
/*
对于任意一个给出的“空旷指数”G，我们应该怎样去判断它是否符合题目的意思呢？

我们可以想象，我们已知了这条路上的所有的路标，我们从头开始枚举两两相邻的路标的间距，如果大于G,那么已经不符合G为最大距离的条件了，为了使G满足,我们就可以在前一个路标前面G米处加一个路标，这样与前面一个就符合条件了，再判断新设的路标和后面的路标是否距离小于G,如果不，继续重复操作设置新路标

当新设的路标数已经超过题目所给最大增设值时，如果还有路标不满足G,但已经不能设置新路标了，所以该G值就不满足条件。相反，则G成立。

注意到，如果一个“空旷指数”成立，那么可能存在比它更小的解，但如果一个“空旷指数”不成立，那么答案只能比该值更大*/

//我是如此开心我能接触到如此美妙的算法
#include<iostream>
using namespace std;
int L,N,K;
int arr[100010],s[100010];
bool check(int x){
    int cnt=0;
    for(int i=1;i<=N;i++){
        if(s[i]>x){
            cnt++;
            int num=s[i]-x;
            while(num>x){
                cnt++;
                num-=x;
            }
        }
    }
    
    return cnt<=K;
}


int main(){
    cin>>L>>N>>K;
    int highest=0;
    
    for(int i=1;i<=N;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
        s[i]=arr[i]-arr[i-1];
    }
    
    arr[N+1]=L;
    s[N+1]=arr[N+1]-arr[N];
    int l=0,r=L+1;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    if(check(l)) cout<<l;
    else cout<<r;
    return 0;
}
```



### **最小值最大模型**

![image-20240315200512608](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240315200512608.png)

#### **洛谷p1873**

```c++
#include<iostream>
using namespace std;
int n,m;
int arr[1000010];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        sum+=max(0,arr[i]-x);
        if(sum>=m) return true;
    }
    return false;
   
  
}
int main(){
    cin>>n>>m;
    int highest=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
    }
    int l=0,r=highest;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    if(check(r)) cout<<r;
  
    else cout<<l;
    return 0;
}
```



#### **洛谷p2440**

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,k;
int arr[100010];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        sum+=arr[i]/x;
        if(sum>=k) return true;
    }
    return false;
}

int main(){
    cin>>n>>k;
    int highest=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
    }
    int l=0,r=highest;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    if(check(r)) cout<<r;
    else cout<<l;
    
    return 0;
}
```



#### **洛谷p2678跳石头**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
int L, N, M;
int arr[50010];

bool check(int x) {
    int cnt = 0;//记录移动石头的次数
    int i = 0, now = 0;//i代表的是当前的石头，i<N+1的原因是我们不能把终点搬走
    while (i < N + 1) {
        i++;
        if (arr[i] - arr[now] < x) cnt++;
        else now = i;
    }
    return cnt <= M;

}
//算法思路
//每次都把最小距离移走，并且随着移动的次数变大，最小跳跃距离是在变大的
//二分，假设中间的值是答案，那么按照比这个答案小的石头一定会被移走，并且移走的石头一定是M个
//所以二分的判断条件就是，移走的石头的个数是不是M，如果大于M，就说明不是答案
//如果我们假设的条件符合，我们还要检查比它小的地方是不是有答案

int main() {
    cin >> L >> N >> M;
    for (int i = 1; i <= N; i++) {
        scanf("%d", &arr[i]);
    }
    arr[N + 1] = L;  //相当于终点 
    int l = 0, r = L + 1;//边界条件
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;//这个是我们假设的答案
        if (check(mid)) l = mid;
        else r = mid;
    }

    if (check(r)) cout << r;
    else cout << l;

}
```

#### ACWing1236递增三元组

需要注意的地方：1.注意数据的数量级，两个10的五次方相乘，得到的是10的十次方，超过int的最大值，所以要开long long

第二个就是**当程序出问题时，如果确信自己的逻辑是，没问题的，就要重新检查一遍，因为很有可能是因为一些小细节出错而不是逻辑出错**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;
int N;
int a[100010];
int b[100010];
int c[100010];
bool check1(int num, int x) {
    return num < x;
}

bool check2(int num, int x) {
    return num <= x;
}
int func1(int num) {
    //找数组中最后一个小于num的下标
    int l = 0, r = N + 1, mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check1(a[mid], num)) l = mid;
        else r = mid;
    }
    return l;

}
int func2(int num) {
    //找数组中第一个大于num的下标
    int l = 0, r = N + 1, mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check2(c[mid], num)) l = mid;
        else r = mid;
    }
    return r;

}
int main() {
    cin >> N;
    LL res = 0;
    for (int i = 1; i <= N; i++) {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= N; i++) {
        scanf("%d", &b[i]);
    }
    for (int i = 1; i <= N; i++) {
        scanf("%d", &c[i]);
    }

    //二分法
    sort(a+1, a + N+1);
    sort(b+1, b + N+1);
    sort(c+1, c + N+1);
    for (int i = 1; i <= N; i++) {
        LL x = func1(b[i]);
        LL y = func2(b[i]);
        res += (x * (N - y + 1));
    }
    cout << res;
    return 0;
}
```

### 变种二分

#### 力扣33搜索旋转排序数组

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};

```





# 双指针

[双指针算法-CSDN博客](https://blog.csdn.net/qq_54773252/article/details/122836179?ops_request_misc=%7B%22request%5Fid%22%3A%22171059884416800226527499%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=171059884416800226527499&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122836179-null-null.142^v99^pc_search_result_base1&utm_term=双指针算法&spm=1018.2226.3001.4187)

双指针主要有两种：快慢指针和对撞指针

### 力扣16最接近的三数之和

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        //双指针
        int n=nums.size();
        sort(nums.begin(),nums.end());
        int best=1e7;
        auto update=[&](int cur){
            if(abs(cur-target)<abs(best-target)){
                best=cur;
            }
        };

        for(int i=0;i<nums.size();i++){
            if(i>0&&nums[i]==nums[i-1]) continue;//不计算重复情况
            

            //使用双指针
            int j=i+1,k=n-1;
            while(j<k){
                int sum=nums[i]+nums[j]+nums[k];
                if(sum==target) return target;
                update(sum);
                if(sum>target){
                    int k0=k-1;
                    while(j<k0&&nums[k0]==nums[k]) k0--;
                    k=k0;
                }
                else{
                    int j0=j+1;
                    while(j0<k&&nums[j0]==nums[j]) j0++;
                    j=j0;
                }
        }
    }
    return best;

    }
};
```

### 力扣15三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        // 枚举 a
        for (int first = 0; first < n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second < n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    ans.push_back({nums[first], nums[second], nums[third]});
                }
            }
        }
        return ans;
    }
};


```



### 18四数之和

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> quadruplets;
        if (nums.size() < 4) {
            return quadruplets;
        }
        sort(nums.begin(), nums.end());
        int length = nums.size();
        for (int i = 0; i < length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                break;
            }
            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {
                continue;
            }
            for (int j = i + 1; j < length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
                    break;
                }
                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {
                    continue;
                }
                int left = j + 1, right = length - 1;
                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while (left < right && nums[left] == nums[left + 1]) {
                            left++;
                        }
                        left++;
                        while (left < right && nums[right] == nums[right - 1]) {
                            right--;
                        }
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return quadruplets;
    }
};


```



### 洛谷p1102

我们考虑题目要求求出所有`A-B=C`的数对，我们可以先将原数组排序，然后就会发现每个数A，对应的数B一定是一段连续的区间。

然后我们再考虑如何去找到这个区间。

我们显然是要找到这个连续区间的左端点和右端点。

考虑到排序之后序列的有序性，我们枚举每个数，他们的左端点和右端点都是**单调不降**的，因此我们可以用two-pointers，也就是双指针来维护这个东西。

![image-20240316225049443](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240316225049443.png)

代码很简洁。

```c++
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2e5 + 10;
int n , c;
int a[N];

int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1 , a + 1 + n);
	int l = 1, r1 = 1 , r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```



### 力扣27移除元素

soooooooeasy!!!!

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int le=nums.size();
        int i=0,j=0;
        while(i<le){
            if(nums[i]==val) j++;
            else nums[i-j]=nums[i];
            i++;
        }
        nums.resize(le-j);
        return le-j;


    }
};
```



### 力扣11盛最多水的容器

由题意可知，容器的高度是由短板决定的，假设初始容器的短板和长版分别在两端

如果向内移动短板，短板的长度有可能变大，虽然容器的宽度变小了，但是仍然可能使得容器的体积变大

如果移动长板，则容器的体积一定变小

由此可知只要在每次移动中移动短板，在判断体积是否变大即可

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int le = height.size();
        int r1 = 0, r2 = le - 1;//短板长板
        int res = 0;
        while(r1<r2){
            if(height[r1]<height[r2]){
                res=max(res,min(height[r1],height[r2])*(r2-r1));
                r1++;
            }
            else{
                 res=max(res,min(height[r1],height[r2])*(r2-r1));
                r2--;
            }
        }
        return res;
    }
};
```

### ACWing1236递增三元组

```c++
//满足条件A-B<0  B-C<0
//枚举B，所以假设每次B的值都是固定的，我们知道Ai的值是最后一个小于B的值，那么Ai之前的值都是小于B的，同理，最后一个小于B的Ci之后的所有元素都是大于B的
//所以我们需要找到这些数

```



```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long LL;
const int N = 1e5+10;
int num[3][N];

int main() {
    int n;
    scanf("%d", &n);
    for(int i = 0; i < 3; ++i) 
        for(int j = 1; j <= n; ++j) 
            scanf("%d", &num[i][j]);
    for(int i = 0; i < 3; ++i)
        sort(num[i]+1, num[i]+n+1);

    LL ans = 0;
    //枚举B，寻找A满足的个数以及C满足的个数相乘
    int a = 1, c = 1;
    for(int i = 1; i <= n; ++i) {
        int key = num[1][i];
        while(a<=n && num[0][a] < key) a++;
        while(c<=n && num[2][c] <= key) c++;

        ans += (LL)(a-1)*(n-c+1);

    }
    cout<<ans<<endl;
    return 0;
}

```



### 力扣80

双指针

### 滑动窗口

#### 3力扣无重复字符的最长字串

我们使用两个指针维护最长不重复子串，

我们知道，r0-rk之间的字符串是不重复的，则r1-rk之间的字串也是不重复的，这是该题解的基础

当出现重复字符的时候，出列最左边，此时r1-rk一定是不重复的啦

```c++
//滑动窗口
//unordered_set
class Solution {
public:

    int lengthOfLongestSubstring(string s) {
        unordered_set<char>occ;
        int n=s.size();
        int rk=-1,ans=0;//一般滑动数组都用-1作为开始
        for(int i=0;i<n;i++){
            if(i!=0){
                occ.erase(s[i-1]);
            }
            while(rk+1<n&&!occ.count(s[rk+1])){
                occ.insert(s[rk+1]);
                ++rk;
            }
            ans=max(ans,rk-i+1);
        }
        return ans;

    }
};
```



# 图

### 133克隆图

题解1深度优先搜索，题解已经写的很清楚了一个无向图实际在代码中如何存储：

![image-20240506194705392](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240506194705392.png)

题解2广搜，还是要模拟一下才可以！！

# 排序

### 堆排序

#### 15届蓝桥杯爬山

```c++
#include <iostream>
#include<cmath>
#include<queue>
using namespace std;
//堆维护最值+贪心
//时间复杂度nlogn

int main() {
    priority_queue<int>pq;//大根堆
    int n, p, q; cin >> n>>p >> q;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        pq.push(x);
    }

    while (p || q) {
        int cur = pq.top();
        pq.pop();
        if (p) {
            cur = sqrt(cur);
            p--;
        }
        else if(q){
            cur /= 2;
            q--;
        }
        pq.push(cur);
    }

    int s=0;
    while (!pq.empty()) {
        s += pq.top();
        pq.pop();
    }

    cout << s;

    
    return 0;
}

```



### 拓扑排序

#### 207课程表

详情[拓扑排序 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/topo/)

# 模拟题

### 力扣100321

# 高精度算法

### 高精度加法

高精度加法对比高精度减法简单了好多

1.处理进位问题，carry记录进位，最后要判断进位是否为0，如果不为零，还要加上进位

```c++
#include <iostream>
#include <string>
#include <algorithm>

// 高精度加法函数
std::string highPrecisionAdd(const std::string& num1, const std::string& num2) {
    int len1 = num1.size();
    int len2 = num2.size();
    int maxLength = std::max(len1, len2);

    std::string result;
    int carry = 0; // 进位

    // 从最低位开始逐位相加 
    for (int i = 0; i < maxLength; i++) {
        int digit1 = (i < len1) ? num1[len1 - 1 - i] - '0' : 0;
        int digit2 = (i < len2) ? num2[len2 - 1 - i] - '0' : 0;
        int sum = digit1 + digit2 + carry;
        carry = sum / 10;
        result.push_back(sum % 10 + '0');
    }

    // 最后处理进位
    if (carry) {
        result.push_back(carry + '0');
    }

    // 反转结果字符串
    std::reverse(result.begin(), result.end());

    return result;
}

int main() {
    std::string num1, num2;
    std::cout << "Enter the first large number: ";
    std::cin >> num1;
    std::cout << "Enter the second large number: ";
    std::cin >> num2;

    std::string result = highPrecisionAdd(num1, num2);
    std::cout << "Result of addition: " << result << std::endl;

    return 0;
}

```



### 高精度减法

高精度加法需要解决的问题：

1.如果两个数相等，直接返回0即可

2.如果两个数不等，如何让大的那个数放到前面，并处理负号的问题

3.如何处理借位问题，比如100借位

4.如何处理两个数的位数不一致问题

5.去除前导零

```c++
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

// 字符串减法，用于高精度减法运算
string subtract(string& a, string& b) {
    // 确保 a >= b
    if (a == b) {
        return "0";
    }

    bool flag = false;
    if (a.size() < b.size()) {
        swap(a, b);
        flag = true;
    }

    else if (a.size() == b.size() && a < b) {
        swap(a, b);
        flag = true;
    }

    string result;
    int carry = 0;
    int lenA = a.size();
    int lenB = b.size();

    for (int i = 0; i < lenA; ++i) {
        int numA = a[lenA - 1 - i] - '0';
        int numB = i < lenB ? b[lenB - 1 - i] - '0' : 0;

        int temp = numA - numB - carry;

        if (temp < 0) {
            temp += 10;
            carry = 1;
        }
        else {
            carry = 0;
        }

        result.push_back(temp + '0');
    }
    
    

    // 去除结果中的前导零
    while (result.size() > 1 && result.back() == '0') {
        result.pop_back();
    }
    
    reverse(result.begin(), result.end());

    
    if (flag) result.insert(result.begin(), '-');
    return result;
}

int main() {
    string a, b;
    
    cin >> a;
    //cout << "Enter the subtrahend: ";
    cin >> b;
    cout << "Result: " << subtract(a, b) << endl;
    return 0;
}

```



### 高精度乘法

高精度乘法没有翻转字符串

使用vector数组存储每一位数字，最后记得转化成字符串即可

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
string multiple(string a, string b) {
    int la = a.size(), lb = b.size();
    vector<int>result(la + lb, 0); 
    int sum = 0, num = 0;
    for (int i = la - 1; i >= 0; i--) {
        for (int j = lb - 1; j >= 0; j--) {
            num = (a[i] - '0') * (b[j] - '0');
            sum = num + result[i + j + 1];
            result[i + j + 1] = sum % 10;
            result[i + j] += sum / 10;
        }
    }


    string ans;
    int n = result.size();
    for (int i=0; i <n; i++) {
        if (!(ans.empty() && result[i] == 0)) {
            ans.push_back(result[i] + '0');
        }
    }

    return ans.empty() ? 0 : ans;
}
int main() {
    string a, b;
    cin >> a >> b;
    string ans = multiple(a, b);
    cout << ans;
    return 0;
}

```



### 高精度除法

1.高精度除以低精度（逐位试商） 

```c++
#include<iostream>
#include<string>
using namespace std;
string func(string a, string b) {
	long long y = stoll(b);
	int la = a.size();
	string c(la, '0');
	long long sum = 0, carry = 0;
	for (int i = 0; i < la; i++) {
		sum = (carry * 10 + a[i] - '0');
		c[i] = (sum / y)+'0';
		carry = sum % y;
	}

	int i = 0;
	while (c.size()>1&&c[i] == '0') c.erase(c.begin());
	return c;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



2.高精度除以高精度

以减法代替除法的运算

```c++
#include<iostream>
#include<string>
using namespace std;
string func2(string a, string b) {
	string result;

	int na = a.size();
	int nb = b.size();

	int i;
	int carry = 0;

	for (i = 0; i < na; i++) {
		int numa = a[na - i - 1]-'0';
		int numb = i < nb ? b[nb - i - 1]-'0' : 0;
		int temp = numa - numb - carry;
		if (temp < 0) {
			temp += 10;
			carry = 1;
		}
		else carry = 0;

		result.push_back(temp + '0');
	}


	while (result.size() > 1 && result.back() == '0') {
		result.pop_back();
	}

	reverse(result.begin(), result.end());
	return result;
}

bool issmaller(string x, string y) {
	int lx = x.size(), ly = y.size();
	if (lx < ly) return true;
	else if (lx == ly && x < y) return true;
	return false;
}
string func(string a, string b) {
	int la = a.size(), lb = b.size();
	int lc = la - lb + 1;
	string c;
	int cnt = 0;
	char ch;
	for (int i = lc; i > 0; i--) {
		string temp(i - 1, '0');
		temp = b + temp;
		while (!issmaller(a, temp)) {
			cnt++;
			a = func2(a, temp);
		}
		ch = cnt + '0';
		c += ch;
		cnt = 0;
	}

	//去除前导零
	int i = 0;
	while (c.size() > 1 && c[i] == '0') c.erase(c.begin());
	return c;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



### 高精度取模

1.高精度取模低精度

```c++
#include<iostream>
#include<string>
using namespace std;

int main() {
	string a, b;
	cin >> a >> b;
	a += b;
	int result = 0;
	int mod = 1000000007;
	for (auto i : a) {
		result = (result * 10 + (i - '0')) % mod;
	}

	cout << result;
}
```





2高精度取模高精度

```
#include<iostream>
#include<string>
using namespace std;
string func2(string a, string b) {
	string c;

	int na = a.size();
	int nb = b.size();

	int carry = 0;
	int i;
	for (i = 0; i < na; i++) {
		int numa = a[na - i - 1] - '0';
		int numb = i < nb ? b[nb - 1 - i] - '0' : 0;
		int temp = numa - numb-carry;
		if (temp < 0) {
			temp += 10;
			carry = 1;
		}
		else {
			carry = 0;
		}
		c.push_back(temp + '0');

	}

	reverse(c.begin(), c.end());
	i = 0;
	while (c.size() > 1 && c[i] == '0') c.erase(c.begin());
	
	return c;
}

bool issmaller(string x, string y) {
	int lx = x.size(), ly = y.size();
	if (lx < ly) return true;
	else if (lx == ly && x < y) return true;
	return false;
}
string func(string a, string b) {
	if (issmaller(a, b)) return a;
	int la = a.size(), lb = b.size();
	int lc = la - lb + 1;
	for (int i = lc; i > 0; i--) {
		string temp(i - 1, '0');
		temp = b + temp;
		while (!issmaller(a, temp)) {
			a = func2(a, temp);
		}
	}
	return a;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



### 力扣100297
